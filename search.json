[
  {
    "objectID": "get-started.html",
    "href": "get-started.html",
    "title": "Get Started",
    "section": "",
    "text": "To build R packages with extendr, you need to have the right tools."
  },
  {
    "objectID": "get-started.html#step-1-install-rust",
    "href": "get-started.html#step-1-install-rust",
    "title": "Get Started",
    "section": "Step 1 Install Rust",
    "text": "Step 1 Install Rust\n\n\n\n\nFollow the rustup installation instructions to install Rust. Note that the current minimum supported Rust version (msrv) in extendr is 1.64. This is to ensure CRAN compliance. Windows users will also need to install the GNU toolchain as it matches Rtools. This can be done via rustup in the terminal: rustup target add x86_64-pc-windows-gnu."
  },
  {
    "objectID": "get-started.html#step-2-update-r",
    "href": "get-started.html#step-2-update-r",
    "title": "Get Started",
    "section": "Step 2 Update R",
    "text": "Step 2 Update R\n\n\n\n\nWe recommend using a moderately new version of R (&gt;= 4.2.0). You can get that from CRAN."
  },
  {
    "objectID": "get-started.html#step-3-install-rextendr",
    "href": "get-started.html#step-3-install-rextendr",
    "title": "Get Started",
    "section": "Step 3 Install rextendr",
    "text": "Step 3 Install rextendr\n\n\n\n\nThe R package {rextendr} provides scaffolding for extendr projects and tools for documenting Rust functions and objects. To install the latest development version, use pak::pak(\"extendr/rextendr\"). Note that rextendr provides a function to check your Rust installation: rextendr::rust_sitrep()."
  },
  {
    "objectID": "get-started.html#step-4-use-rust-analyzer",
    "href": "get-started.html#step-4-use-rust-analyzer",
    "title": "Get Started",
    "section": "Step 4 Use rust-analyzer",
    "text": "Step 4 Use rust-analyzer\nThis is optional, but strongly recommended. If you use Visual Studio Code (VS Code) or a similar IDE, the rust-analyzer will provide you type hinting and auto-completion suggestions. It is very helpful!"
  },
  {
    "objectID": "user-guide/type-mapping/extendr-macro.html",
    "href": "user-guide/type-mapping/extendr-macro.html",
    "title": "The extendr Macro",
    "section": "",
    "text": "The power of extendr is in its ability to use Rust from R. The #[extendr] macro is what determines what is exported to R from Rust. This section covers the basic usage of the #[extendr] macro.\n#[extendr] is what is referred to as an attribute macro (which itself is a type of procedural macro). An attribute macro is attached to an item such as a function, struct, enum, or impl.\nThe #[extendr] attribute macro indicates that an item should be made available to R. However, it can only be used with a function or an impl block.",
    "crumbs": [
      "Type Mapping",
      "The extendr Macro"
    ]
  },
  {
    "objectID": "user-guide/type-mapping/extendr-macro.html#exporting-functions",
    "href": "user-guide/type-mapping/extendr-macro.html#exporting-functions",
    "title": "The extendr Macro",
    "section": "Exporting functions",
    "text": "Exporting functions\nIn order to make a function available to R, two things must happen. First, the #[extendr] macro must be attached to the function. For example, you can create a function answer_to_life()\n\n\n\n\n\n\nNote\n\n\n\n\n\nIn the Hitchhiker’s Guide to the Galaxy, the number 42 is the answer to the universe. See this fun article from Scientific American\n\n\n\n#[extendr]\nfn answer_to_life() -&gt; i32 {\n    42\n}\nBy adding the #[extendr] attribute macro to the answer_to_life() function, we are indicating that this function has to be compatible with R. This alone, however, does not make the function available to R. It must be made available via the extendr_module! {} macro in lib.rs.\nextendr_module! {\n    mod hellorust;\n    fn answer_to_life;\n}\n\n\n\n\n\n\nTip\n\n\n\nEverything that is made available in the extendr_module! {} macro in lib.rs must be compatible with R as indicated by the #[extendr] macro. Note that the module name mod hellorust must be the name of the R package that this is part of. If you have created your package with rextendr::use_extendr() this should be set automatically. See Hello, world!.\n\n\nWhat happens if you try and return something that cannot be represented by R? Take this example, an enum Shape is defined and a function takes a string &str. Based on the value of the arugment, an enum variant is returned.\n#[derive(Debug)]\nenum Shape {\n    Triangle,\n    Rectangle,\n    Pentagon,\n    Hexagon,\n}\n\n#[extendr]\nfn make_shape(shape: &str) -&gt; Shape {\n    match shape {\n        \"triangle\" =&gt; Shape::Triangle,\n        \"rectangle\" =&gt; Shape::Rectangle,\n        \"pentagon\" =&gt; Shape::Pentagon,\n        \"hexagon\" =&gt; Shape::Hexagon,\n        &_ =&gt; unimplemented!()\n    }\n}\nWhen this is compiled, an error occurs because extendr does not know how to convert the Shape enum into something that R can use. The error is fairly informative!\n   | ^^^^^^^^^^ the trait `ToVectorValue` is not implemented for `Shape`, which is required by `extendr_api::Robj: From&lt;Shape&gt;`\n   |\n   = help: the following other types implement trait `ToVectorValue`:\n             bool\n             i8\n             i16\n             i32\n             i64\n             usize\n             u8\n             u16\n           and 45 others\n   = note: required for `extendr_api::Robj` to implement `From&lt;Shape&gt;`\n   = note: this error originates in the attribute macro `extendr` \nIt tells you that Shape does not implement the ToVectorValue trait. The ToVectorValue trait is what enables items from Rust to be returned to R.",
    "crumbs": [
      "Type Mapping",
      "The extendr Macro"
    ]
  },
  {
    "objectID": "user-guide/type-mapping/extendr-macro.html#tovectorvalue-trait",
    "href": "user-guide/type-mapping/extendr-macro.html#tovectorvalue-trait",
    "title": "The extendr Macro",
    "section": "ToVectorValue trait",
    "text": "ToVectorValue trait\nIn order for an item to be returned from a function marked with the #[extendr] attribute macro, it must be able to be turned into an R object. In extendr, the struct Robj is a catch all for any type of R object.\n\n\n\n\n\n\nNote\n\n\n\nFor those familiar with PyO3, the Robj struct is similar in concept to the PyAny struct.\n\n\nThe ToVectorValue trait is what is used to convert Rust items into R objects. The trait is implemented on a number of standard Rust types such as i32, f64, usize, String and more (see all foreign implementations here) which enables these functions to be returned from a Rust function marked with #[extendr].\n\n\n\n\n\n\nNote\n\n\n\nIn essence, all items that are returned from a function must be able to be turned into an Robj. Other extendr types such as List, for example, have a From&lt;T&gt; for Robj implementation that defines how it is converted into an Robj.\n\n\nThis means that with a little extra work, the Shape enum can be returned to R. To do so, the #[extendr] macro needs to be added to an impl block.",
    "crumbs": [
      "Type Mapping",
      "The extendr Macro"
    ]
  },
  {
    "objectID": "user-guide/type-mapping/extendr-macro.html#exporting-impl-blocks",
    "href": "user-guide/type-mapping/extendr-macro.html#exporting-impl-blocks",
    "title": "The extendr Macro",
    "section": "Exporting impl blocks",
    "text": "Exporting impl blocks\nThe other supported item that can be made available to R is an impl block. impl is a keyword that allows you to implement a trait or an inherent implementation. The #[extendr] macro works with inherent implementations. These are impls on a type such as an enum or a struct. extendr does not support using #[extendr] on trait impls.\n\n\n\n\n\n\nNote\n\n\n\nYou can only add an inherent implementation on a type that you have own and not provided by a third party crate. This would violate the orphan rules.\n\n\nContinuing with the Shape example, this enum alone cannot be returned to R. For example, the following code will result in a compilation error\n#[derive(Debug)]\nenum Shape {\n    Triangle,\n    Rectangle,\n    Pentagon,\n    Hexagon,\n}\n\n#[extendr]\nfn make_shape(shape: &str) -&gt; Shape {\n    match shape {\n        \"triangle\" =&gt; Shape::Triangle,\n        \"rectangle\" =&gt; Shape::Rectangle,\n        \"pentagon\" =&gt; Shape::Pentagon,\n        \"hexagon\" =&gt; Shape::Hexagon,\n        &_ =&gt; unimplemented!()\n    }\n}\nerror[E0277]: the trait bound `Shape: ToVectorValue` is not satisfied\n  --&gt; src/lib.rs:19:1\n   |\n19 | #[extendr]\n   | ^^^^^^^^^^ the trait `ToVectorValue` is not implemented for `Shape`, which is required by `extendr_api::Robj: From&lt;Shape&gt;`\n   |\nHowever, if an impl block is added to the Shape enum, it can be returned to R.\n\n#[derive(Debug)]\nenum Shape {\n    Triangle,\n    Rectangle,\n    Pentagon,\n    Hexagon,\n}\n\n#[extendr]\nimpl Shape {\n    fn new(x: &str) -&gt; Self {\n        match x {\n            \"triangle\" =&gt; Self::Triangle,\n            \"rectangle\" =&gt; Self::Rectangle,\n            \"pentagon\" =&gt; Self::Pentagon,\n            \"hexagon\" =&gt; Self::Hexagon,\n            &_ =&gt; unimplemented!(),\n        }\n    }\n\n    fn n_coords(&self) -&gt; usize {\n        match &self {\n            Shape::Triangle =&gt; 3,\n            Shape::Rectangle =&gt; 4,\n            Shape::Pentagon =&gt; 4,\n            Shape::Hexagon =&gt; 5,\n        }\n    }\n}\n\nIn this example two new methods are added to the Shape enum. The first new() is like the make_shape() function that was shown earlier: it takes a &str and returns an enum variant. Now that the enum has an impl block with #[extendr] attribute macro, it can be exported to R by inclusion in the extendr_module! {} macro.\nextendr_module! {\n    mod hellorust;\n    impl Shape;\n}\nDoing so creates an environment in your package called Shape. The environment contains all of the methods that are available to you.\n\n\n\n\n\n\nTip\n\n\n\nThere are use cases where you may not want to expose any methods but do want to make it possible to return a struct or an enum to the R. You can do this by adding an empty impl block with the #[extendr] attribute macro.\n\n\nIf you run as.list(Shape) you will see that there are two functions in the environment which enable you to call the methods defined in the impl block. You might think that this feel like an R6 object and you’d be right because an R6 object essentially is an environment!\n\nas.list(Shape)\n#&gt; $n_coords\n#&gt; function () \n#&gt; .Call(\"wrap__Shape__n_coords\", self, PACKAGE = \"librextendr1.dylib\")\n#&gt; \n#&gt; $new\n#&gt; function (x) \n#&gt; .Call(\"wrap__Shape__new\", x, PACKAGE = \"librextendr1.dylib\")\n\nCalling the new() method instantiates a new enum variant.\n\ntri &lt;- Shape$new(\"triangle\")\ntri\n#&gt; &lt;pointer: 0x122f29b40&gt;\n#&gt; attr(,\"class\")\n#&gt; [1] \"Shape\"\n\nThe newly made tri object is an external pointer to the Shape enum in Rust. This pointer has the same methods as the Shape environment—though they cannot be seen in the same way. For example you can run the n_coords() method on the newly created object.\n\ntri$n_coords()\n#&gt; [1] 3\n\n\n\n\n\n\n\nTip\n\n\n\nTo make the methods visible to the Shape class you can define a .DollarNames method which will allow you to preview the methods and attributes when using the $ syntax. This is very handy to define when making an impl a core part of your package.\n\n.DollarNames.Shape = function(env, pattern = \"\") {\n  ls(Shape, pattern = pattern)\n}\n\n\n\n\nimpl ownership\nAdding the #[extendr] macro to an impl allows the struct or enum to be made available to R as an external pointer. Once you create an external pointer, that is then owned by R. So you can only get references to it or mutable references. If you need an owned version of the type, then you will need to clone it.",
    "crumbs": [
      "Type Mapping",
      "The extendr Macro"
    ]
  },
  {
    "objectID": "user-guide/type-mapping/extendr-macro.html#accessing-exported-impls-from-rust",
    "href": "user-guide/type-mapping/extendr-macro.html#accessing-exported-impls-from-rust",
    "title": "The extendr Macro",
    "section": "Accessing exported impls from Rust",
    "text": "Accessing exported impls from Rust\nInvariably, if you have made an impl available to R via the #[extendr] macro, you may want to define functions that take the impl as a function argument.\nDue to R owning the impl’s external pointer, these functions cannot take an owned version of the impl as an input. For example trying to define a function that subtracts an integer from the n_coords() output like below returns a compiler error.\n#[extendr]\nfn subtract_coord(x: Shape, n: i32) -&gt; i32 {\n    (x.n_coords() as i32) - n\n}\nthe trait bound `Shape: extendr_api::FromRobj&lt;'_&gt;` is not satisfied\n  --&gt; src/lib.rs:53:22\n   |\n   | fn subtract_coord(x: Shape, n: i32) -&gt; i32 {\n   |                      ^^^^^ the trait `extendr_api::FromRobj&lt;'_&gt;` is not implemented for `Shape`\n   |\nhelp: consider borrowing here\n   |\n   | fn subtract_coord(x: &Shape, n: i32) -&gt; i32 {\n   |                      +\n   | fn subtract_coord(x: &mut Shape, n: i32) -&gt; i32 {\n   |                      ++++\nAs most often, the compiler’s suggestion is a good one. Use &Shape to use a reference.",
    "crumbs": [
      "Type Mapping",
      "The extendr Macro"
    ]
  },
  {
    "objectID": "user-guide/type-mapping/extendr-macro.html#externalptr-returning-arbitrary-rust-types",
    "href": "user-guide/type-mapping/extendr-macro.html#externalptr-returning-arbitrary-rust-types",
    "title": "The extendr Macro",
    "section": "ExternalPtr: returning arbitrary Rust types",
    "text": "ExternalPtr: returning arbitrary Rust types\nIn the event that you need to return a Rust type to R that doesn’t have a compatible impl or is a type that you don’t own, you can use ExternalPtr&lt;T&gt;. The ExternalPtr struct allows any item to be captured as a pointer and returned to R.\nHere, for example, an ExternalPtr&lt;Shape&gt; is returned from the shape_ptr() function.\n\n\n\n\n\n\nTip\n\n\n\nAnything that is wrapped in ExternalPtr&lt;T&gt; must implement the Debug trait.\n\n\n\n#[derive(Debug)]\nenum Shape {\n    Triangle,\n    Rectangle,\n    Pentagon,\n    Hexagon,\n}\n\n#[extendr]\nfn shape_ptr(shape: &str) -&gt; ExternalPtr&lt;Shape&gt; {\n    let variant = match shape {\n        \"triangle\" =&gt; Shape::Triangle,\n        \"rectangle\" =&gt; Shape::Rectangle,\n        \"pentagon\" =&gt; Shape::Pentagon,\n        \"hexagon\" =&gt; Shape::Hexagon,\n        &_ =&gt; unimplemented!(),\n    };\n\n    ExternalPtr::new(variant)\n}\n\nUsing an external pointer, however, is far more limiting than the impl block. For example, you cannot access any of its methods.\n\ntri_ptr &lt;- shape_ptr(\"triangle\")\ntri_ptr$n_coords()\n#&gt; Error in tri_ptr$n_coords: object of type 'externalptr' is not subsettable\n\nTo use an ExternalPtr&lt;T&gt;, you have to go through a bit of extra work for it.\n#[extendr]\nfn n_coords_ptr(x: Robj) -&gt; i32 {\n    let shape = TryInto::&lt;ExternalPtr&lt;Shape&gt;&gt;::try_into(x); \n    \n    match shape {\n        Ok(shp) =&gt; shp.n_coords() as i32,\n        Err(_) =&gt; 0\n    }\n}\nThis function definition takes an Robj and from it, tries to create an ExternalPtr&lt;Shape&gt;. Then, if the conversion did not error, it returns the number of coordinates as an i32 (R’s version of an integer) and if there was an error converting, it returns 0.\n\ntri_ptr &lt;- shape_ptr(\"triangle\")\n\nn_coords_ptr(tri_ptr)\n#&gt; [1] 3\n\nn_coords_ptr(list())\n#&gt; [1] 0\n\nFor a good example of using ExternalPtr&lt;T&gt; within an R package, refer to the b64 R package.",
    "crumbs": [
      "Type Mapping",
      "The extendr Macro"
    ]
  },
  {
    "objectID": "user-guide/webr.html",
    "href": "user-guide/webr.html",
    "title": "Building for WebR",
    "section": "",
    "text": "As of the writing, extendr supports building for WebR!",
    "crumbs": [
      "WebR"
    ]
  },
  {
    "objectID": "user-guide/webr.html#update-build-process",
    "href": "user-guide/webr.html#update-build-process",
    "title": "Building for WebR",
    "section": "Update build process",
    "text": "Update build process\nTo build for WebR, you need to ensure that your R package has the appropriate build scripts and configuration. To do so ensure you have the latest development version of rextendr installed.\n# update rextendr \npak::pak(\"extendr/rextendr\")\nCompilation for WebR is handled through the tools/config.R and Makevars.in files in your R packages.\nTo udpate these files run\nrextendr::use_extendr()\nDo not overwrite any important files like lib.rs or Cargo.toml. Allow it to overwrite:\n\nMakevars{.win}.in\ntools/config.R\nconfigure{.win}\nentrypoint.c",
    "crumbs": [
      "WebR"
    ]
  },
  {
    "objectID": "user-guide/webr.html#update-cargo.toml",
    "href": "user-guide/webr.html#update-cargo.toml",
    "title": "Building for WebR",
    "section": "Update Cargo.toml",
    "text": "Update Cargo.toml\nIn order to compile on WebR, the Cargo.toml file must ensure that lto = true for the release profile. Add the following to your Cargo.toml file:\n[profile.release]\nlto = true",
    "crumbs": [
      "WebR"
    ]
  },
  {
    "objectID": "user-guide/webr.html#using-extendr-webr-packages",
    "href": "user-guide/webr.html#using-extendr-webr-packages",
    "title": "Building for WebR",
    "section": "Using extendr WebR packages",
    "text": "Using extendr WebR packages\nTo use an extendr package with WebR, we recommend using r-universe. R-universe automatically builds binaries of your package for WebR, Mac, Windows, and Linux.",
    "crumbs": [
      "WebR"
    ]
  },
  {
    "objectID": "user-guide/cran-msrv.html",
    "href": "user-guide/cran-msrv.html",
    "title": "CRAN’s Rust versions",
    "section": "",
    "text": "The build machines of CRAN do not have coordinated versions of Rust. The minimum Rust version of CRAN can dictate the crates and features extendr-powered packages can use (if you plan on distributing on CRAN).\nThe below table reports CRAN versions per check flavor based on the check results of the extendr package {fio}.\nCode\nlibrary(rvest)\n\ncheck_links &lt;- \"https://cran.r-project.org/web/checks/check_results_fio.html\" |&gt; \n  read_html() |&gt; \n  html_node(\".container\") |&gt; \n  html_nodes(\"a\") |&gt; \n  html_attr(\"href\") \n\ncheck_links &lt;- unique(check_links[grepl(\"^https://\", check_links)])\n\ninstall_logs &lt;- gsub(\n  \"00check.html\",\n  \"00install.html\",\n  check_links\n)\n\nextract_semver &lt;- function(ver) {\n  if (grepl(\"\\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\", ver)) {\n    sub(\".*?(\\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?).*\", \"\\\\1\", ver)\n  } else {\n    NA\n  }\n}\n\nversions &lt;- lapply(install_logs, function(.log) {\n  lns &lt;- readLines(.log)\n  rust_version &lt;- extract_semver(lns[grepl(\"^Using rustc\", lns)])\n  cargo_version &lt;- extract_semver(lns[grepl(\"^Using cargo\", lns)])\n  data.frame(rustc = rust_version, cargo = cargo_version)\n})\n\n\n# get all of the flavors\nflavor &lt;- dirname(\n  gsub(\"https://www.r-project.org/nosvn/r.check/\", \"\", tolower(install_logs))\n)\n\nres &lt;- cbind(\n  \"Check flavor\" = flavor,\n  do.call(rbind.data.frame, versions)\n) |&gt; \n  dplyr::mutate(rustc = numeric_version(rustc), cargo = numeric_version(cargo)) |&gt; \n  dplyr::arrange(rustc)",
    "crumbs": [
      "CRAN's MSRV"
    ]
  },
  {
    "objectID": "user-guide/cran-msrv.html#crans-msrv-is-1.81.0",
    "href": "user-guide/cran-msrv.html#crans-msrv-is-1.81.0",
    "title": "CRAN’s Rust versions",
    "section": "CRAN’s MSRV is 1.81.0",
    "text": "CRAN’s MSRV is 1.81.0\n\n\n\n \n  \n    Check flavor \n    rustc \n    cargo \n  \n \n\n  \n    r-devel-windows-x86_64 \n    1.81.0 \n    1.81.0 \n  \n  \n    r-release-windows-x86_64 \n    1.81.0 \n    1.81.0 \n  \n  \n    r-oldrel-windows-x86_64 \n    1.81.0 \n    1.81.0 \n  \n  \n    r-release-macos-arm64 \n    1.84.1 \n    1.84.1 \n  \n  \n    r-release-macos-x86_64 \n    1.84.1 \n    1.84.1 \n  \n  \n    r-oldrel-macos-arm64 \n    1.84.1 \n    1.84.1 \n  \n  \n    r-oldrel-macos-x86_64 \n    1.84.1 \n    1.84.1 \n  \n  \n    r-oldrel-macos-arm64 \n    1.84.1 \n    1.84.1 \n  \n  \n    r-oldrel-macos-x86_64 \n    1.84.1 \n    1.84.1 \n  \n  \n    r-devel-linux-x86_64-debian-clang \n    1.85.0 \n    1.85.0 \n  \n  \n    r-devel-linux-x86_64-debian-gcc \n    1.85.0 \n    1.85.0 \n  \n  \n    r-patched-linux-x86_64 \n    1.85.0 \n    1.85.0 \n  \n  \n    r-release-linux-x86_64 \n    1.85.0 \n    1.85.0 \n  \n  \n    r-devel-linux-x86_64-fedora-clang \n    1.87.0 \n    1.87.0 \n  \n  \n    r-devel-linux-x86_64-fedora-gcc \n    1.87.0 \n    1.87.0",
    "crumbs": [
      "CRAN's MSRV"
    ]
  },
  {
    "objectID": "user-guide/complete-example.html",
    "href": "user-guide/complete-example.html",
    "title": "A Complete Example",
    "section": "",
    "text": "The Rust crate ecosystem is rich with very small and very powerful utility libraries. One of the most downloaded crates is heck. It provides traits and structs to perform some of the most common case conversions.\nIn this tutorial we’ll create a 0 dependency R package to provide the common case conversions. The resultant R package will be more performant but less flexible than the {snakecase} R package.\nThis tutorial covers:",
    "crumbs": [
      "A Complete Example"
    ]
  },
  {
    "objectID": "user-guide/complete-example.html#getting-started",
    "href": "user-guide/complete-example.html#getting-started",
    "title": "A Complete Example",
    "section": "Getting started",
    "text": "Getting started\nCreate a new R package:\nusethis::create_package(\"heck\")\nWhen the new R package has opened up, add extendr.\nrextendr::use_extendr(crate_name = \"rheck\", lib_name = \"rheck\")\n\n\n\n\n\n\nNote\n\n\n\nWhen adding the extendr dependency, make sure that the crate_name and lib_name arguments are not heck. In order to add the heck crate as a dependency, the crate itself cannot be called heck because it creates a recursive dependency. Doing this allows us to name the R package {heck}, but the internal Rust crate is called rheck.\n\n\nNext, heck is needed as a dependency. From your terminal, navigate to src/rust and run cargo add heck. With this, you have everything you need to get started.",
    "crumbs": [
      "A Complete Example"
    ]
  },
  {
    "objectID": "user-guide/complete-example.html#snek-case-conversion",
    "href": "user-guide/complete-example.html#snek-case-conversion",
    "title": "A Complete Example",
    "section": "snek case conversion",
    "text": "snek case conversion\n\nuse heck::ToSnekCase;\n\nLet’s start by creating a simple function to take a single string, and convert it to snake case. First, the trait ToSnekCase needs to be imported so that the method to_snek_case() is available to &str.\n\nuse heck::ToSnekCase;\n\n#[extendr]\nfn to_snek_case(x: &str) -&gt; String {\n    x.to_snek_case()\n}\n\nSimple enough, right? Let’s give it a shot. To make it accessible from your R session, it needs to be included in your extendr_module! {} macro.\nextendr_module! {\n    mod heck;\n    fn to_snek_case;\n}\nFrom your R session, run rextendr::document() followed by devtools::load_all() to make the function available. We’ll skip these step from now on, but be sure to remember it!\n\nto_snek_case(\"MakeMe-Snake case\")\n#&gt; [1] \"make_me_snake_case\"\n\nRarely is it useful to run a function on just a scalar character value. Rust, though, works with scalars by default and adding vectorization is another step.\n\nto_snek_case(c(\"DontStep\", \"on-Snek\"))\n#&gt; Error in to_snek_case(c(\"DontStep\", \"on-Snek\")): Expected Scalar, got Strings\n\nProviding a character vector causes an error. So how do you go about vectorizing?",
    "crumbs": [
      "A Complete Example"
    ]
  },
  {
    "objectID": "user-guide/complete-example.html#vectorizing-snek-case-conversion",
    "href": "user-guide/complete-example.html#vectorizing-snek-case-conversion",
    "title": "A Complete Example",
    "section": "vectorizing snek case conversion",
    "text": "vectorizing snek case conversion\nTo vectorize this function, you need to be apply the conversion to each element in a character vector. The extendr wrapper struct for a character vector is called Strings. To take in a character vector and also return one, the function signature should look like this:\n#[extendr]\nfn to_snek_case(x: Strings) -&gt; Strings {\n}\nThis says there is an argument x which must be a character vector and this function must also -&gt; return the Strings (a character vector).\nTo iterate through this you can use the .into_iter() method on the character vector.\n#[extendr]\nfn to_snek_case(x: Strings) -&gt; Strings {\n    x\n        .into_iter()\n        // the rest of the function\n}\nIterators have a method called .map() (yes, just like purrr::map()). It lets you apply a closure (an anonymous function) to each element of the iterator. In this case, each element is an Rstr. The Rstr has a method .as_str() which will return a string slice &str. You can take this slice and pass it on to .to_snek_case(). After having mapped over each element, the results are .collect()ed into another Strings.\n\n#[extendr]\nfn to_snek_case(x: Strings) -&gt; Strings {\n    x\n        .into_iter()\n        .map(|xi| {\n            xi.as_str().to_snek_case()\n        })\n        .collect::&lt;Strings&gt;()\n}\n\nThis new version of the function can be used in a vectorized manner:\n\nto_snek_case(c(\"DontStep\", \"on-Snek\"))\n#&gt; [1] \"dont_step\" \"on_snek\"\n\nBut can it handle a missing value out of the box?\n\nto_snek_case(c(\"DontStep\", NA_character_, \"on-Snek\"))\n#&gt; [1] \"dont_step\" \"na\"        \"on_snek\"\n\nWell, sort of. The as_str() method when used on a missing value will return \"NA\" which is not in a user’s best interest.",
    "crumbs": [
      "A Complete Example"
    ]
  },
  {
    "objectID": "user-guide/complete-example.html#handling-missing-values",
    "href": "user-guide/complete-example.html#handling-missing-values",
    "title": "A Complete Example",
    "section": "handling missing values",
    "text": "handling missing values\nInstead of returning \"na\", it would be better to return an actual missing value. Those can be created each scalar’s na() method e.g. Rstr::na().\nYou can modify the .map() statement to check if an NA is present, and, if so, return an NA value. To perform this check, use the is_na() method which returns a bool which is either true or false. The result can be matched. When it is missing, the match arm returns the NA scalar value. When it is not missing, the Rstr is converted to snek case. However, since the true arm is an Rstr the other false arm must also be an Rstr. To accomplish this use the Rstr::from() method.\n\n#[extendr]\nfn to_snek_case(x: Strings) -&gt; Strings {\n    x.into_iter()\n        .map(|xi| match xi.is_na() {\n            true =&gt; Rstr::na(),\n            false =&gt; Rstr::from(xi.as_str().to_snek_case()),\n        })\n        .collect::&lt;Strings&gt;()\n}\n\nThis function can now handle missing values!\n\nto_snek_case(c(\"DontStep\", NA_character_, \"on-Snek\"))\n#&gt; [1] \"dont_step\" NA          \"on_snek\"",
    "crumbs": [
      "A Complete Example"
    ]
  },
  {
    "objectID": "user-guide/complete-example.html#automating-other-methods-with-a-macro",
    "href": "user-guide/complete-example.html#automating-other-methods-with-a-macro",
    "title": "A Complete Example",
    "section": "automating other methods with a macro!",
    "text": "automating other methods with a macro!\nThere are traits for the other case conversions such as ToKebabCase, ToPascalCase, ToShoutyKebabCase and others. The each have a similar method name: .to_kebab_case(), to_pascal_case(), .to_shouty_kebab_case(). You can either choose to copy the above and change the method call multiple times, or use a macro as a form of code generation.\nA macro allows you to generate code in a short hand manner. This macro take an identifier which has a placeholder called $fn_name: $fn_name:ident.\nmacro_rules! make_heck_fn {\n    ($fn_name:ident) =&gt; {\n        #[extendr]\n        /// @export\n        fn $fn_name(x: Strings) -&gt; Strings {\n            x.into_iter()\n                .map(|xi| match xi.is_na() {\n                    true =&gt; Rstr::na(),\n                    false =&gt; Rstr::from(xi.as_str().$fn_name()),\n                })\n                .collect::&lt;Strings&gt;()\n        }\n    };\n}\nThe $fn_name placeholder is put as the function name definition which is the same as the method name. To use this macro to generate the rest of the functions the other traits need to be imported.\n\nuse heck::{\n    ToKebabCase, ToShoutyKebabCase,\n    ToSnekCase, ToShoutySnakeCase,\n    ToPascalCase, ToUpperCamelCase,\n    ToTrainCase, ToTitleCase,\n};\n\nWith the traits in scope, the macro can be invoked to generate the other functions.\nmake_heck_fn!(to_snek_case);\nmake_heck_fn!(to_shouty_snake_case);\nmake_heck_fn!(to_kebab_case);\nmake_heck_fn!(to_shouty_kebab_case);\nmake_heck_fn!(to_pascal_case);\nmake_heck_fn!(to_upper_camel_case);\nmake_heck_fn!(to_train_case);\nmake_heck_fn!(to_title_case);\nNote that each of these functions should be added to the extendr_module! {} macro in order for them to be available from R.\nTest it out with the to_shouty_kebab_case() function!\n\nto_shouty_kebab_case(\"lorem:IpsumDolor__sit^amet\")\n#&gt; [1] \"LOREM-IPSUM-DOLOR-SIT-AMET\"\n\nAnd with that, you’ve created an R package that provides case conversion using heck and with very little code!",
    "crumbs": [
      "A Complete Example"
    ]
  },
  {
    "objectID": "user-guide/complete-example.html#bench-marking-with-snakecase",
    "href": "user-guide/complete-example.html#bench-marking-with-snakecase",
    "title": "A Complete Example",
    "section": "bench marking with {snakecase}",
    "text": "bench marking with {snakecase}\nTo illustrate the performance gains from using a vectorized Rust funciton, a bench::mark() is created between to_snek_case() and snakecase::to_snake_case().\nThe bench mark will use 5000 randomly generated lorem ipsum sentences.\n\nx &lt;- unlist(lorem::ipsum(5000, 1, 25))\n\nhead(x)\n#&gt; [1] \"Sit risus justo euismod luctus habitant vestibulum montes sodales nunc congue porttitor penatibus vivamus egestas malesuada malesuada eleifend dui malesuada maecenas ullamcorper mattis conubia hendrerit nibh.\"   \n#&gt; [2] \"Amet habitant diam sem ad viverra faucibus leo nascetur facilisis potenti taciti dapibus maecenas senectus primis nisl urna quis eu interdum quam praesent cubilia viverra aptent.\"                                 \n#&gt; [3] \"Elit luctus facilisis sociosqu nulla pretium accumsan senectus odio sociis per praesent augue augue mollis etiam nostra ut lacinia sollicitudin viverra blandit laoreet justo iaculis ac aenean in molestie.\"       \n#&gt; [4] \"Elit metus vehicula ante magna aptent ad tortor quis vestibulum a urna mus blandit nisi ligula lacus suspendisse sociosqu ullamcorper tristique duis erat sociosqu magnis vivamus mauris habitasse magnis.\"         \n#&gt; [5] \"Elit pellentesque at interdum neque ut ut himenaeos curabitur libero imperdiet pellentesque natoque et justo senectus fames dictumst vulputate risus iaculis nullam tristique libero convallis metus nisi urna non.\"\n#&gt; [6] \"Sit odio fames posuere pellentesque auctor pellentesque aliquam scelerisque aptent egestas posuere sociis varius sapien enim dapibus lobortis egestas sem hendrerit aptent pellentesque consequat.\"\n\nbench::mark(\n  rust = to_snek_case(x),\n  snakecase = snakecase::to_snake_case(x)\n)\n#&gt; # A tibble: 2 × 6\n#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 rust         16.6ms     18ms     55.6     1.17MB     0   \n#&gt; 2 snakecase   267.8ms    270ms      3.70   12.29MB     5.55\n\n\n\n\n\n\n\nNote\n\n\n\nThe memory usage for rust-based functions is likely quite understated. This is because memory allocated outside of R cannot be tracked.\nSee bench::mark documentation for more.",
    "crumbs": [
      "A Complete Example"
    ]
  },
  {
    "objectID": "user-guide/complete-example.html#the-whole-thing",
    "href": "user-guide/complete-example.html#the-whole-thing",
    "title": "A Complete Example",
    "section": "The whole thing",
    "text": "The whole thing\nIn just 42 lines of code (empty lines included), you can create a very performant R package!\nuse extendr_api::prelude::*;\n\nuse heck::{\n    ToKebabCase, ToPascalCase, ToShoutyKebabCase, ToShoutySnakeCase, ToSnekCase, ToTitleCase,\n    ToTrainCase, ToUpperCamelCase,\n};\n\nmacro_rules! make_heck_fn {\n    ($fn_name:ident) =&gt; {\n        #[extendr]\n        /// @export\n        fn $fn_name(x: Strings) -&gt; Strings {\n            x.into_iter()\n                .map(|xi| match xi.is_na() {\n                    true =&gt; Rstr::na(),\n                    false =&gt; Rstr::from(xi.as_str().$fn_name()),\n                })\n                .collect::&lt;Strings&gt;()\n        }\n    };\n}\n\nmake_heck_fn!(to_snek_case);\nmake_heck_fn!(to_shouty_snake_case);\nmake_heck_fn!(to_kebab_case);\nmake_heck_fn!(to_shouty_kebab_case);\nmake_heck_fn!(to_pascal_case);\nmake_heck_fn!(to_upper_camel_case);\nmake_heck_fn!(to_train_case);\nmake_heck_fn!(to_title_case);\n\nextendr_module! {\n    mod heck;\n    fn to_snek_case;\n    fn to_shouty_snake_case;\n    fn to_kebab_case;\n    fn to_shouty_kebab_case;\n    fn to_pascal_case;\n    fn to_upper_camel_case;\n    fn to_title_case;\n    fn to_train_case;\n}",
    "crumbs": [
      "A Complete Example"
    ]
  },
  {
    "objectID": "user-guide/faq.html",
    "href": "user-guide/faq.html",
    "title": "Frequently Asked Questions",
    "section": "",
    "text": "Below are the answers to some of the more frequently asked questions in the extendr community.",
    "crumbs": [
      "FAQ"
    ]
  },
  {
    "objectID": "user-guide/faq.html#how-do-i-rename-my-package",
    "href": "user-guide/faq.html#how-do-i-rename-my-package",
    "title": "Frequently Asked Questions",
    "section": "How do I rename my package?",
    "text": "How do I rename my package?\nWhen you change the name of your package in the DESCRIPTION file or Cargo.toml file, you will likely notice that your package fails to build.\n\nProblem\nThe package name is used in the building and linking steps. The package is expecting the old name, not the new one.\n\n\nSolution\nRun rextendr::use_extendr() to regenerate the Makevars.in, Makevars.win.in, entrypoint.c, and Cargo.toml files.\n\n\n\n\n\n\nCautionCargo.toml\n\n\n\nuse_extendr() will overwrite your existing Cargo.toml file. Please copy or backup your dependencies or any other changes beforehand.",
    "crumbs": [
      "FAQ"
    ]
  },
  {
    "objectID": "user-guide/faq.html#what-is-the-msrv-of-extendr",
    "href": "user-guide/faq.html#what-is-the-msrv-of-extendr",
    "title": "Frequently Asked Questions",
    "section": "What is the MSRV of extendr?",
    "text": "What is the MSRV of extendr?\nThe MSRV of extendr as of August, 2025 is 1.65. However, we do plan on raising this for better FFI support and unwinding capabilities in the future. It can be expected for the MSRV to be raised to 1.76 in the near future.",
    "crumbs": [
      "FAQ"
    ]
  },
  {
    "objectID": "user-guide/r-pkgs/package-setup.html",
    "href": "user-guide/r-pkgs/package-setup.html",
    "title": "Package Setup",
    "section": "",
    "text": "Once you have Rust and {rextendr} installed, you can begin creating Rust-powered R packages.\nThe first step to using extendr is to create an R package. It is recommend to create a new package using the package {usethis}.\nusethis::create_package(\"hellorust\")\nIf you are in the RStudio IDE, a new R project will be opened up for you with the file structure of a new R package.\n.\n├── DESCRIPTION\n├── NAMESPACE\n├── R\n└── hellorust.Rproj\nNow that you have a new R package, you can add extendr to it.\nrextendr::use_extendr()\nThis will add an extendr package template to the R packge. We will go through the package structure in more depth shortly.\n.\n├── DESCRIPTION\n├── NAMESPACE\n├── R\n│   └── extendr-wrappers.R\n├── hellorust.Rproj\n└── src\n    ├── Makevars\n    ├── Makevars.ucrt\n    ├── Makevars.win\n    ├── entrypoint.c\n    ├── hellorust-win.def\n    └── rust\n        ├── Cargo.toml\n        └── src\n            └── lib.rs\nInside of the file src/rust/src/lib.rs is a hello world function.\n/// Return string `\"Hello world!\"` to R.\n/// @export\n#[extendr]\nfn hello_world() -&gt; &'static str {\n    \"Hello world!\"\n}\n\n\n\n\n\n\nTip\n\n\n\nNote that roxygen2 can be used with Rust documentation comments /// instead of //.\n\n\nThe function is made available to R via the macro extendr_module!.\n// Macro to generate exports.\n// This ensures exported functions are registered with R.\n// See corresponding C code in `entrypoint.c`.\nextendr_module! {\n    mod hellorust;\n    fn hello_world;\n}\nUse the function rextendr::document() to automatically create R function wrappers to call the Rust function. This will recompile the Rust library.\nrextendr::document()\n#&gt;  rextendr::document()\n#&gt; ✔ Saving changes in the open files.\n#&gt; ℹ Generating extendr wrapper functions for package: hellorust.\n#&gt; ℹ Re-compiling hellorust (debug build)\n#&gt; .... truncated ....\n#&gt; ─  DONE (hellorust)\n#&gt; ✔ Writing 'R/extendr-wrappers.R'\n#&gt; ℹ Updating hellorust documentation\n#&gt; Writing NAMESPACE\n#&gt; ℹ Loading hellorust\n#&gt; Writing NAMESPACE\n#&gt; Writing hellorust-package.Rd\n#&gt; Writing hello_world.Rd\nThe file R/extendr-wrappers.R was updated and now contains\n#' Return string `\"Hello world!\"` to R.\n#' @export\nhello_world &lt;- function() .Call(wrap__hello_world)\nRun devtools::load_all() to make the function available to your session.\ndevtools::load_all()\n#&gt; ℹ Loading hellorust\nThe package hellorust has been loaded and now you can run hello_world()\nhello_world()\n#&gt; \"Hello world!\"",
    "crumbs": [
      "R Packages",
      "Package Setup"
    ]
  },
  {
    "objectID": "intro-rust/structs.html",
    "href": "intro-rust/structs.html",
    "title": "Defining Struct(ure)s",
    "section": "",
    "text": "TipObjective\n\n\n\nCreate new struct types and destructure them. Additionally, add behavior through derive-macros.\n\n\nYou can define a type as being a collection of other types by using the struct keyword.\nstruct Person {\n    name: String,\n    age: i32\n}\nstructs are named using PascalCase, as opposed to fns which are named using snake_case convention. Structs are constructed using a “literal” syntax. Where we write the name of the struct followed by curlys and the fields like so:\nlet me = Person { name: \"Josiah\".to_string(), age: 29 };\nBy default, new structs do not get any special behavior. Meaning they cannot be printed using println!():\nstruct Person {\n    name: String,\n    age: i32\n}\n\nfn main() {\n    let me = Person { name: \"Josiah\".to_string(), age: 29 };\n    println!(\"{me:?}\");\n}\nerror[E0277]: `Person` doesn't implement `Debug`\n --&gt; src/main.rs:8:15\n  |\n8 |     println!(\"{me:?}\");\n  |               ^^^^^^ `Person` cannot be formatted using `{:?}`\n  |\n  = help: the trait `Debug` is not implemented for `Person`\n  = note: add `#[derive(Debug)]` to `Person` or manually `impl Debug for Person`\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `Person` with `#[derive(Debug)]`\n  |\n1 + #[derive(Debug)]\n2 | struct Person {\n\n\nRust contains a special type called a trait. They’re akin to S3 generics. They are a a collection of methods that can be implemented by foreign types.\nIn this case, Debug is a trait that allows for debug printing using println!(). Our new type does not implement this by default. However, we can derive this behavior because everything inside of the struct does.\nTo derive behavior we use the #[derive()] attribute.\n#[derive(Debug, Clone)]\nstruct Person {\n    name: String,\n    age: i32\n}\nThe Debug trait allows debug printing of the type Person via dbg!() or println!(\"{p:?}).\nfn main() {\n    let me = Person { name: \"Josiah\".to_string(), age: 29 };\n    println!(\"{me:?}\");\n}\nPerson { name: \"Josiah\", age: 29 }\n\n\n\nFields of a struct can be accessed directly, or by reference. Field can be accessed using var.field_name.\nIf a field is accessed and moved, the struct cannot be moved. The same rules of borrowing apply to a struct. You can borrow a field as much as you want but you can only move it once. Otherwise, the entire struct cannot be used.\nfn main() {\n    let me = Person { name: \"Josiah\".to_string(), age: 29 };\n    let name = me.name;\n    println!(\"{me:?}\");\n}\nerror[E0382]: borrow of partially moved value: `me`\n  --&gt; src/main.rs:10:15\n   |\n9  |     let name = me.name;\n   |                ------- value partially moved here\n10 |     println!(\"{me:?}\");\n   |               ^^^^^^ value borrowed here after partial move\n\n\n\nIt is possible to destructure a struct during assignment creating many variables at one time.\nTo destructure during assignment you use the syntax let StructName { field, field } = variable;\nfn main() {\n    let me = Person { name: \"Josiah\".to_string(), age: 29 };\n    let Person { name, age } = me;\n    println!(\"{name} is {age} years old\");\n}\n\n\n\n\nDefine a struct called Point which has two fields x, and y that are f64\nDerive Debug and Clone\nIn main() create a new Point struct\nDebug print the new point\nDestructure the point into x and y\n\n\n\nView solution\n\n#[derive(Debug, Clone)]\nstruct Point {\n    x: f64,\n    y: f64\n}\n\nfn main() {\n    let point = Point { x: 3.0, y: 0.14 };\n    println!(\"The point is {:?}\");\n    let Point { x, y } = point;\n}",
    "crumbs": [
      "Defining Struct(ure)s"
    ]
  },
  {
    "objectID": "intro-rust/structs.html#deriving-behavior",
    "href": "intro-rust/structs.html#deriving-behavior",
    "title": "Defining Struct(ure)s",
    "section": "",
    "text": "Rust contains a special type called a trait. They’re akin to S3 generics. They are a a collection of methods that can be implemented by foreign types.\nIn this case, Debug is a trait that allows for debug printing using println!(). Our new type does not implement this by default. However, we can derive this behavior because everything inside of the struct does.\nTo derive behavior we use the #[derive()] attribute.\n#[derive(Debug, Clone)]\nstruct Person {\n    name: String,\n    age: i32\n}\nThe Debug trait allows debug printing of the type Person via dbg!() or println!(\"{p:?}).\nfn main() {\n    let me = Person { name: \"Josiah\".to_string(), age: 29 };\n    println!(\"{me:?}\");\n}\nPerson { name: \"Josiah\", age: 29 }",
    "crumbs": [
      "Defining Struct(ure)s"
    ]
  },
  {
    "objectID": "intro-rust/structs.html#accessing-fields",
    "href": "intro-rust/structs.html#accessing-fields",
    "title": "Defining Struct(ure)s",
    "section": "",
    "text": "Fields of a struct can be accessed directly, or by reference. Field can be accessed using var.field_name.\nIf a field is accessed and moved, the struct cannot be moved. The same rules of borrowing apply to a struct. You can borrow a field as much as you want but you can only move it once. Otherwise, the entire struct cannot be used.\nfn main() {\n    let me = Person { name: \"Josiah\".to_string(), age: 29 };\n    let name = me.name;\n    println!(\"{me:?}\");\n}\nerror[E0382]: borrow of partially moved value: `me`\n  --&gt; src/main.rs:10:15\n   |\n9  |     let name = me.name;\n   |                ------- value partially moved here\n10 |     println!(\"{me:?}\");\n   |               ^^^^^^ value borrowed here after partial move",
    "crumbs": [
      "Defining Struct(ure)s"
    ]
  },
  {
    "objectID": "intro-rust/structs.html#destructuring",
    "href": "intro-rust/structs.html#destructuring",
    "title": "Defining Struct(ure)s",
    "section": "",
    "text": "It is possible to destructure a struct during assignment creating many variables at one time.\nTo destructure during assignment you use the syntax let StructName { field, field } = variable;\nfn main() {\n    let me = Person { name: \"Josiah\".to_string(), age: 29 };\n    let Person { name, age } = me;\n    println!(\"{name} is {age} years old\");\n}",
    "crumbs": [
      "Defining Struct(ure)s"
    ]
  },
  {
    "objectID": "intro-rust/structs.html#exercise",
    "href": "intro-rust/structs.html#exercise",
    "title": "Defining Struct(ure)s",
    "section": "",
    "text": "Define a struct called Point which has two fields x, and y that are f64\nDerive Debug and Clone\nIn main() create a new Point struct\nDebug print the new point\nDestructure the point into x and y\n\n\n\nView solution\n\n#[derive(Debug, Clone)]\nstruct Point {\n    x: f64,\n    y: f64\n}\n\nfn main() {\n    let point = Point { x: 3.0, y: 0.14 };\n    println!(\"The point is {:?}\");\n    let Point { x, y } = point;\n}",
    "crumbs": [
      "Defining Struct(ure)s"
    ]
  },
  {
    "objectID": "intro-rust/struct-methods.html",
    "href": "intro-rust/struct-methods.html",
    "title": "Struct Methods",
    "section": "",
    "text": "TipObjectives\n\n\n\nLearn how to implement methods for stucts. Be able to create associated functions and understand the difference between Self, &self, and &mut self\n\n\n\n\nTypically methods are used on instantiations of a variable such as:\nlet me = Person { name: \"Josiah\".to_string(), age: 29 };\nlet birth_year = me.year_of_birth();\nSometimes it makes sense to use an associated function. These are functions that are called from the type itself e.g. Type::function(). They’re typically used for constructors. For example\nlet me = Person::new(\"Josiah\".to_string(), 29);\nThey’re created using an impl block.\n\n\n\nimpl is short for implement. We can implement methods for structs using the following syntax:\nimpl TypeName {\n    fn method() {\n        todo!()\n    }\n}\nAssociated functions are methods that do not reference the type itself. To create a new() constructor function that returns the type we can set the return type to Self:\nimpl Person {\n    fn new(name: String, age: i32) -&gt; Self {\n        Person { name, age }\n    }\n}\nThis gives us the ability to use Person::new()\n\n\n\nHowever, it often makes sense to call methods from an instantiation itself.\nWe can do this by setting the first argument to &self which provides a reference to the struct the method is called on.\nimpl Person {\n    fn greet(&self) {\n        println!(\"Hello, my name is {} and I am {} years old.\", self.name, self.age);\n    }\n}\nUsing a &self reference means you cannot move the inner fields, only borrow them.\nWe can also have arguments that refer to other instantiations of the same type via &Self or Self. For example to compare ages of people:\nimpl Person {\n    fn is_older_than(&self, other_person: &Self) -&gt; bool {\n        self.age &gt; other_person.age\n    }\n}\n\n\n\nOften it makes sense to modify the fields of a struct. This is when a mutable reference is handy via &mut self.\nFor example we can implement methods to rename() and celebrate_birthday():\nimpl Person {\n    fn rename(&mut self, new_name: &str) {\n        self.name = new_name.to_string();\n    }\n\n    fn celebrate_birthday(&mut self) {\n        self.age += 1;\n    }\n}\n\n\n\n\n\n\n\n\n\n\nImplement a Point::new() associated function\n\nUsing arguments x: f64 and y: f64\nIt should return Self\n\nDefine a method euclidean_distance() which calculates the distance between itself and another Point\n\nUse arguments &self and destination: &Self\nReturn f64\nDistance is calculated as \\(\\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\\)\nUse .powi(2) to square a value and x.sqrt() to get the square root\n\nIn main.rs create two Point structs and calculate the distance between them.\n\n\n\nView solution\n\nimpl Point {\n    fn new(x: f64, y: f64) -&gt; Self {\n        Self { x, y }\n    }\n\n    fn euclidean_distance(&self, destination: &Self) -&gt; f64 {\n        let x_diff = (self.x - destination.x).powi(2);\n        let y_diff = (self.y - destination.y).powi(2);\n\n        (x_diff + y_diff).sqrt()\n    }\n}\n\nfn main() {\n    let a = Point::new(0.0, 5.0);\n    let b = Point::new(-10.0, 1.5);\n    let distance = a.euclidean_distance(&b);\n    println!(\"Distance between a and b is {distance}\");\n}\n\n\n\n\nEuclidean distance is useful only on a rectangle. What about on a sphere? Haversine distance is used to calculate the distance on a sphere. The Haversine formula computes the distance between two points on a sphere given their longitudes and latitudes.\nIt is defined by the following (messy) equation:\n\\[a = \\sin^2\\left(\\frac{\\Delta\\phi}{2}\\right) + \\cos\\phi_1 \\cdot \\cos\\phi_2 \\cdot \\sin^2\\left(\\frac{\\Delta\\lambda}{2}\\right)\\]\n\\[c = 2 \\cdot \\text{atan2}(\\sqrt{a}, \\sqrt{1-a})\\]\n\\[d = R \\cdot c\\]\nWhere:\n\n\\(\\phi\\) represents latitude (in radians) (use .to_radians())\n\\(\\lambda\\) represents longitude (in radians) (use .to_radians())\n\\(R\\) is the Earth’s radius (you can use 6_371_008_7714f64 meters as a mean radius)\n\\(\\Delta\\phi\\) is the difference in latitude between the two points (\\(\\phi_2 - \\phi_1\\))\n\\(\\Delta\\lambda\\) is the difference in longitude between the two points (\\(\\lambda_2 - \\lambda_1\\))\n\\(\\text{atan2}(y, x)\\) is the arctangent of \\(y/x\\), using the signs of both arguments to determine the correct quadrant.\n\nHints for Implementation:\n\nRemember to convert your latitude and longitude values from degrees to radians using the .to_radians() method on f64.\nThe c part of the formula, \\(2 \\cdot \\text{atan2}(\\sqrt{a}, \\sqrt{1-a})\\), can also be implemented using 2 * a.sqrt().asin() in Rust, which is a common simplification when a is within the valid domain for asin.\n\n\n\nView solution\n\nimpl Point {\n    fn haversine_distance(&self, destination: &Self) -&gt; f64 {\n        let radius = 6_371_008.7714; // Earth's mean radius in meters\n        let theta1 = self.y.to_radians(); // Latitude of point 1\n        let theta2 = destination.y.to_radians(); // Latitude of point 2\n        let delta_theta = (destination.y - self.y).to_radians(); // Delta Latitude\n        let delta_lambda = (destination.x - self.x).to_radians(); // Delta Longitude\n\n        let a = (delta_theta / 2f64).sin().powi(2)\n            + theta1.cos() * theta2.cos() * (delta_lambda / 2f64).sin().powi(2);\n\n        2f64 * a.sqrt().asin() * radius\n    }\n}",
    "crumbs": [
      "Struct Methods"
    ]
  },
  {
    "objectID": "intro-rust/struct-methods.html#associated-functions",
    "href": "intro-rust/struct-methods.html#associated-functions",
    "title": "Struct Methods",
    "section": "",
    "text": "Typically methods are used on instantiations of a variable such as:\nlet me = Person { name: \"Josiah\".to_string(), age: 29 };\nlet birth_year = me.year_of_birth();\nSometimes it makes sense to use an associated function. These are functions that are called from the type itself e.g. Type::function(). They’re typically used for constructors. For example\nlet me = Person::new(\"Josiah\".to_string(), 29);\nThey’re created using an impl block.",
    "crumbs": [
      "Struct Methods"
    ]
  },
  {
    "objectID": "intro-rust/struct-methods.html#implement-methods",
    "href": "intro-rust/struct-methods.html#implement-methods",
    "title": "Struct Methods",
    "section": "",
    "text": "impl is short for implement. We can implement methods for structs using the following syntax:\nimpl TypeName {\n    fn method() {\n        todo!()\n    }\n}\nAssociated functions are methods that do not reference the type itself. To create a new() constructor function that returns the type we can set the return type to Self:\nimpl Person {\n    fn new(name: String, age: i32) -&gt; Self {\n        Person { name, age }\n    }\n}\nThis gives us the ability to use Person::new()",
    "crumbs": [
      "Struct Methods"
    ]
  },
  {
    "objectID": "intro-rust/struct-methods.html#self-references",
    "href": "intro-rust/struct-methods.html#self-references",
    "title": "Struct Methods",
    "section": "",
    "text": "However, it often makes sense to call methods from an instantiation itself.\nWe can do this by setting the first argument to &self which provides a reference to the struct the method is called on.\nimpl Person {\n    fn greet(&self) {\n        println!(\"Hello, my name is {} and I am {} years old.\", self.name, self.age);\n    }\n}\nUsing a &self reference means you cannot move the inner fields, only borrow them.\nWe can also have arguments that refer to other instantiations of the same type via &Self or Self. For example to compare ages of people:\nimpl Person {\n    fn is_older_than(&self, other_person: &Self) -&gt; bool {\n        self.age &gt; other_person.age\n    }\n}",
    "crumbs": [
      "Struct Methods"
    ]
  },
  {
    "objectID": "intro-rust/struct-methods.html#mutable-self",
    "href": "intro-rust/struct-methods.html#mutable-self",
    "title": "Struct Methods",
    "section": "",
    "text": "Often it makes sense to modify the fields of a struct. This is when a mutable reference is handy via &mut self.\nFor example we can implement methods to rename() and celebrate_birthday():\nimpl Person {\n    fn rename(&mut self, new_name: &str) {\n        self.name = new_name.to_string();\n    }\n\n    fn celebrate_birthday(&mut self) {\n        self.age += 1;\n    }\n}",
    "crumbs": [
      "Struct Methods"
    ]
  },
  {
    "objectID": "intro-rust/struct-methods.html#exercise",
    "href": "intro-rust/struct-methods.html#exercise",
    "title": "Struct Methods",
    "section": "",
    "text": "Implement a Point::new() associated function\n\nUsing arguments x: f64 and y: f64\nIt should return Self\n\nDefine a method euclidean_distance() which calculates the distance between itself and another Point\n\nUse arguments &self and destination: &Self\nReturn f64\nDistance is calculated as \\(\\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\\)\nUse .powi(2) to square a value and x.sqrt() to get the square root\n\nIn main.rs create two Point structs and calculate the distance between them.\n\n\n\nView solution\n\nimpl Point {\n    fn new(x: f64, y: f64) -&gt; Self {\n        Self { x, y }\n    }\n\n    fn euclidean_distance(&self, destination: &Self) -&gt; f64 {\n        let x_diff = (self.x - destination.x).powi(2);\n        let y_diff = (self.y - destination.y).powi(2);\n\n        (x_diff + y_diff).sqrt()\n    }\n}\n\nfn main() {\n    let a = Point::new(0.0, 5.0);\n    let b = Point::new(-10.0, 1.5);\n    let distance = a.euclidean_distance(&b);\n    println!(\"Distance between a and b is {distance}\");\n}",
    "crumbs": [
      "Struct Methods"
    ]
  },
  {
    "objectID": "intro-rust/struct-methods.html#bonus-exercise-2",
    "href": "intro-rust/struct-methods.html#bonus-exercise-2",
    "title": "Struct Methods",
    "section": "",
    "text": "Euclidean distance is useful only on a rectangle. What about on a sphere? Haversine distance is used to calculate the distance on a sphere. The Haversine formula computes the distance between two points on a sphere given their longitudes and latitudes.\nIt is defined by the following (messy) equation:\n\\[a = \\sin^2\\left(\\frac{\\Delta\\phi}{2}\\right) + \\cos\\phi_1 \\cdot \\cos\\phi_2 \\cdot \\sin^2\\left(\\frac{\\Delta\\lambda}{2}\\right)\\]\n\\[c = 2 \\cdot \\text{atan2}(\\sqrt{a}, \\sqrt{1-a})\\]\n\\[d = R \\cdot c\\]\nWhere:\n\n\\(\\phi\\) represents latitude (in radians) (use .to_radians())\n\\(\\lambda\\) represents longitude (in radians) (use .to_radians())\n\\(R\\) is the Earth’s radius (you can use 6_371_008_7714f64 meters as a mean radius)\n\\(\\Delta\\phi\\) is the difference in latitude between the two points (\\(\\phi_2 - \\phi_1\\))\n\\(\\Delta\\lambda\\) is the difference in longitude between the two points (\\(\\lambda_2 - \\lambda_1\\))\n\\(\\text{atan2}(y, x)\\) is the arctangent of \\(y/x\\), using the signs of both arguments to determine the correct quadrant.\n\nHints for Implementation:\n\nRemember to convert your latitude and longitude values from degrees to radians using the .to_radians() method on f64.\nThe c part of the formula, \\(2 \\cdot \\text{atan2}(\\sqrt{a}, \\sqrt{1-a})\\), can also be implemented using 2 * a.sqrt().asin() in Rust, which is a common simplification when a is within the valid domain for asin.\n\n\n\nView solution\n\nimpl Point {\n    fn haversine_distance(&self, destination: &Self) -&gt; f64 {\n        let radius = 6_371_008.7714; // Earth's mean radius in meters\n        let theta1 = self.y.to_radians(); // Latitude of point 1\n        let theta2 = destination.y.to_radians(); // Latitude of point 2\n        let delta_theta = (destination.y - self.y).to_radians(); // Delta Latitude\n        let delta_lambda = (destination.x - self.x).to_radians(); // Delta Longitude\n\n        let a = (delta_theta / 2f64).sin().powi(2)\n            + theta1.cos() * theta2.cos() * (delta_lambda / 2f64).sin().powi(2);\n\n        2f64 * a.sqrt().asin() * radius\n    }\n}",
    "crumbs": [
      "Struct Methods"
    ]
  },
  {
    "objectID": "intro-rust/why-rust.html",
    "href": "intro-rust/why-rust.html",
    "title": "Why Rust?",
    "section": "",
    "text": "TipObjective\n\n\n\nProvide motivation for why learning Rust is a use of our time. Discuss what Rust is and how it is unique compared to other compiled langauges.\n🧠 Think of Rust as “C for people who like error messages that actually help.”",
    "crumbs": [
      "Why Rust?"
    ]
  },
  {
    "objectID": "intro-rust/why-rust.html#reasoning",
    "href": "intro-rust/why-rust.html#reasoning",
    "title": "Why Rust?",
    "section": "Reasoning",
    "text": "Reasoning\nRust is a programming language that’s fast, safe, and surprisingly friendly to use. Rust turns your code into a standalone program that runs directly on your computer. This makes it much faster and more efficient, similar to languages like C or C++. But where those languages can be hard to use and easy to break, Rust was built to be safer and more helpful.\nRust is especially good at preventing bugs related to memory. There’s no garbage collector in Rust so it is quite memory efficient. Moreover, Rust is designed with the developer in mind. The rust compiler provides error messages that rival—or maybe even surpass—the quality of tidyverse error messaging.",
    "crumbs": [
      "Why Rust?"
    ]
  },
  {
    "objectID": "intro-rust/why-rust.html#tldr",
    "href": "intro-rust/why-rust.html#tldr",
    "title": "Why Rust?",
    "section": "TL;DR",
    "text": "TL;DR\n\nR is interpreted. Code runs line by line.\nR (and Python) are built on C.\nC is compiled — it builds a binary that runs directly on your machine.\nRust is also compiled, like C, C++, Go, Java, and Fortran.\nThese languages are “close to the metal” — fast, efficient, and powerful.\nRust matches C++ in speed, but with some key advantages:\n\nMemory safety without a garbage collector (unlike Go), thanks to the borrow checker.\nA great developer experience:\n\nHelpful, friendly compiler errors (Tidyverse-level DX).\nModern tooling (cargo, rustdoc, rustfmt, rust-analyzer, etc.).\n\n\nRust is easy to get started with and rewards best practices.\n\nWe won’t go deep into memory safety or concurrency today\n\nRust uses errors as data, unlike R and C++, Rust does not support exceptions",
    "crumbs": [
      "Why Rust?"
    ]
  },
  {
    "objectID": "intro-rust/enums.html",
    "href": "intro-rust/enums.html",
    "title": "Enum(eration)s",
    "section": "",
    "text": "TipObjective\n\n\n\nUnderstand what enums are and when you may want to use one.\n\n\nOftentimes a variable can only take on a small number of values. This is when an enumeration (enum) would be useful.\nenums are values that can only take on a select few variants. They are defined using the enum keyword.\n\n\nWe use enums all the time in R and almost exclusively as function arguments.\n\n\nThe tidyverse design style guide has a great section on enums. See enumerate options.\nargs(cor)\nfunction(\n  x, y = NULL, use = \"everything\",\n  method = c(\"pearson\", \"kendall\", \"spearman\") # 👈🏼 enum!\n)\n\n\nI’ve written about this in more detail in my blog post Enums in R: towards type safe R\n\n\nFor example, it may make sense to create an enum that specifies a possible shape.\nenum Shape {\n    Triangle,\n    Rectangle,\n    Pentagon,\n    Hexagon,\n}\n\n\n\n\nThe Shape enum can take on only one of those 4 variants. An enum is created using the format EnumName::Variant.\nHow do we actually determine behavior based on a variant? This is done using pattern matching.\nThe keyword match lets us perform an action based on an enum’s variant. It works by listing each variant and the behavior to that happens when that variant is matched.\nThe pattern match format uses the syntax Enum::Variant =&gt; action. When using match each variant much be enumerated:\n\n\n=&gt; is often referred to as “fat arrow.” But if you say “chompky” I’ll also get it.\nmatch my_shape {\n    Shape::Triangle =&gt; todo!(),\n    Shape::Rectangle =&gt; todo!(),\n    Shape::Pentagon =&gt; todo!(),\n    Shape::Hexagon =&gt; todo!(),\n}\n\n\n\n\n\n\nTip\n\n\n\ntodo!() is a placeholder that can be used to make the compiler happy\n\n\n\n\nFor example we may want to print the number of verticies of a shape:\nlet my_shape = Shape::Triangle;\n\nmatch my_shape {\n    Shape::Triangle =&gt; println!(\"A triangle has 3 vertices\"),\n    Shape::Rectangle =&gt; println!(\"A rectangle has 4 vertices\"),\n    Shape::Pentagon =&gt; println!(\"A pentagon has 5 vertices\"),\n    Shape::Hexagon =&gt; println!(\"A hexagon has 6 vertices\"),\n}\n\n\n\n\nSometimes we want to customize behavior on only a subset of variants. We can use a catch all in the match statement _ =&gt; use the underscore to signify “everything else”.\nmatch my_shape {\n    Shape::Hexagon =&gt; println!(\"Hexagons are the bestagons\"),\n    _ =&gt; println!(\"Every other polygon is mid\"),\n}\n\n\n\nEnums can have methods too just like a struct using impl keyword\nimpl Shape {\n    fn is_bestagon(&self) -&gt; bool {\n        match self {\n            Self::Hexagon =&gt; true,\n            _ =&gt; false\n        }\n    }\n}\n\n\n\n\nCreate an enum called Measure with two variants Euclidean and Haversine\nCreate a method called ndim() which returns 2 for Euclidean and 3 for Haversine\n\n\n\nView solution\n\nenum Measure {\n    Euclidean,\n    Haversine,\n}\n\nimpl Measure {\n    fn ndim(&self) -&gt; i32 {\n        match self {\n            Self::Euclidean =&gt; 2,\n            Self::Haversine =&gt; 3\n        }\n    }\n}\n\n\n\n\n\nCreate a new method distance() for Point struct that returns an f64\n\nArguments: &self, destination: &Self, measure: &Measure\n\nWhen measure is Euclidean use the euclidean_distance() method\nWhen the variant is Haversine use the haversine_distance() method\n\nThe haversine method is defined as:\n\n\nCode for haversine_distance()\n\nimpl Point {\n    fn haversine_distance(&self, destination: &Self) -&gt; f64 {\n        let radius = 6_371_008.7714; // Earth's mean radius in meters\n        let theta1 = self.y.to_radians(); // Latitude of point 1\n        let theta2 = destination.y.to_radians(); // Latitude of point 2\n        let delta_theta = (destination.y - self.y).to_radians(); // Delta Latitude\n        let delta_lambda = (destination.x - self.x).to_radians(); // Delta Longitude\n\n        let a = (delta_theta / 2f64).sin().powi(2)\n            + theta1.cos() * theta2.cos() * (delta_lambda / 2f64).sin().powi(2);\n\n        2f64 * a.sqrt().asin() * radius\n    }\n}\n\n\n\nView solution\n\n\nimpl Point {\n    // Demonstrates using pattern matching an enum\n    fn distance(&self, destination: &Self, measure: &Measure) -&gt; f64 {\n        match measure {\n            Measure::Euclidean =&gt; self.euclidean_distance(destination),\n            Measure::Haversine =&gt; self.haversine_distance(destination),\n        }\n    }\n}",
    "crumbs": [
      "Enum(eration)s"
    ]
  },
  {
    "objectID": "intro-rust/enums.html#enums-in-r",
    "href": "intro-rust/enums.html#enums-in-r",
    "title": "Enum(eration)s",
    "section": "",
    "text": "We use enums all the time in R and almost exclusively as function arguments.\n\n\nThe tidyverse design style guide has a great section on enums. See enumerate options.\nargs(cor)\nfunction(\n  x, y = NULL, use = \"everything\",\n  method = c(\"pearson\", \"kendall\", \"spearman\") # 👈🏼 enum!\n)\n\n\nI’ve written about this in more detail in my blog post Enums in R: towards type safe R\n\n\nFor example, it may make sense to create an enum that specifies a possible shape.\nenum Shape {\n    Triangle,\n    Rectangle,\n    Pentagon,\n    Hexagon,\n}",
    "crumbs": [
      "Enum(eration)s"
    ]
  },
  {
    "objectID": "intro-rust/enums.html#variant-specific-behavior",
    "href": "intro-rust/enums.html#variant-specific-behavior",
    "title": "Enum(eration)s",
    "section": "",
    "text": "The Shape enum can take on only one of those 4 variants. An enum is created using the format EnumName::Variant.\nHow do we actually determine behavior based on a variant? This is done using pattern matching.\nThe keyword match lets us perform an action based on an enum’s variant. It works by listing each variant and the behavior to that happens when that variant is matched.\nThe pattern match format uses the syntax Enum::Variant =&gt; action. When using match each variant much be enumerated:\n\n\n=&gt; is often referred to as “fat arrow.” But if you say “chompky” I’ll also get it.\nmatch my_shape {\n    Shape::Triangle =&gt; todo!(),\n    Shape::Rectangle =&gt; todo!(),\n    Shape::Pentagon =&gt; todo!(),\n    Shape::Hexagon =&gt; todo!(),\n}\n\n\n\n\n\n\nTip\n\n\n\ntodo!() is a placeholder that can be used to make the compiler happy\n\n\n\n\nFor example we may want to print the number of verticies of a shape:\nlet my_shape = Shape::Triangle;\n\nmatch my_shape {\n    Shape::Triangle =&gt; println!(\"A triangle has 3 vertices\"),\n    Shape::Rectangle =&gt; println!(\"A rectangle has 4 vertices\"),\n    Shape::Pentagon =&gt; println!(\"A pentagon has 5 vertices\"),\n    Shape::Hexagon =&gt; println!(\"A hexagon has 6 vertices\"),\n}",
    "crumbs": [
      "Enum(eration)s"
    ]
  },
  {
    "objectID": "intro-rust/enums.html#wildcard-matching",
    "href": "intro-rust/enums.html#wildcard-matching",
    "title": "Enum(eration)s",
    "section": "",
    "text": "Sometimes we want to customize behavior on only a subset of variants. We can use a catch all in the match statement _ =&gt; use the underscore to signify “everything else”.\nmatch my_shape {\n    Shape::Hexagon =&gt; println!(\"Hexagons are the bestagons\"),\n    _ =&gt; println!(\"Every other polygon is mid\"),\n}",
    "crumbs": [
      "Enum(eration)s"
    ]
  },
  {
    "objectID": "intro-rust/enums.html#enums-can-impl-too",
    "href": "intro-rust/enums.html#enums-can-impl-too",
    "title": "Enum(eration)s",
    "section": "",
    "text": "Enums can have methods too just like a struct using impl keyword\nimpl Shape {\n    fn is_bestagon(&self) -&gt; bool {\n        match self {\n            Self::Hexagon =&gt; true,\n            _ =&gt; false\n        }\n    }\n}",
    "crumbs": [
      "Enum(eration)s"
    ]
  },
  {
    "objectID": "intro-rust/enums.html#exercise-1",
    "href": "intro-rust/enums.html#exercise-1",
    "title": "Enum(eration)s",
    "section": "",
    "text": "Create an enum called Measure with two variants Euclidean and Haversine\nCreate a method called ndim() which returns 2 for Euclidean and 3 for Haversine\n\n\n\nView solution\n\nenum Measure {\n    Euclidean,\n    Haversine,\n}\n\nimpl Measure {\n    fn ndim(&self) -&gt; i32 {\n        match self {\n            Self::Euclidean =&gt; 2,\n            Self::Haversine =&gt; 3\n        }\n    }\n}",
    "crumbs": [
      "Enum(eration)s"
    ]
  },
  {
    "objectID": "intro-rust/enums.html#exercise-2",
    "href": "intro-rust/enums.html#exercise-2",
    "title": "Enum(eration)s",
    "section": "",
    "text": "Create a new method distance() for Point struct that returns an f64\n\nArguments: &self, destination: &Self, measure: &Measure\n\nWhen measure is Euclidean use the euclidean_distance() method\nWhen the variant is Haversine use the haversine_distance() method\n\nThe haversine method is defined as:\n\n\nCode for haversine_distance()\n\nimpl Point {\n    fn haversine_distance(&self, destination: &Self) -&gt; f64 {\n        let radius = 6_371_008.7714; // Earth's mean radius in meters\n        let theta1 = self.y.to_radians(); // Latitude of point 1\n        let theta2 = destination.y.to_radians(); // Latitude of point 2\n        let delta_theta = (destination.y - self.y).to_radians(); // Delta Latitude\n        let delta_lambda = (destination.x - self.x).to_radians(); // Delta Longitude\n\n        let a = (delta_theta / 2f64).sin().powi(2)\n            + theta1.cos() * theta2.cos() * (delta_lambda / 2f64).sin().powi(2);\n\n        2f64 * a.sqrt().asin() * radius\n    }\n}\n\n\n\nView solution\n\n\nimpl Point {\n    // Demonstrates using pattern matching an enum\n    fn distance(&self, destination: &Self, measure: &Measure) -&gt; f64 {\n        match measure {\n            Measure::Euclidean =&gt; self.euclidean_distance(destination),\n            Measure::Haversine =&gt; self.haversine_distance(destination),\n        }\n    }\n}",
    "crumbs": [
      "Enum(eration)s"
    ]
  },
  {
    "objectID": "intro-rust/options.html",
    "href": "intro-rust/options.html",
    "title": "Some() or None?",
    "section": "",
    "text": "TipObjective\n\n\n\nUnderstand how missingness is handled in Rust with Option&lt;T&gt;. - Understand how to handle missingness - Use Option&lt;T&gt; in an applied case\n\n\nRust doesn’t have the concept of a NULL type. Null values are quite dangerous and have their own category of errors and security issues.\nRust makes it impossible to have a null value by formalizing the concept of missingness through the Option&lt;&gt;\n\n\nAn Option is a special enum that has two possible values:\nenum Option {\n    Some(T),\n    None\n}\nWhen a value is missing, the option’s variant is None. When the option contains some value, the value is contained inside of the Some(T) variant.\n\n\n\nSince Option&lt;T&gt; are “just” an enum, we can match on the variants to access the values.\n// create an Option&lt;Measure&gt; that contains a value\nlet measure = Some(Measure::Euclidean);\n\nmatch measure {\n    Some(v) =&gt; println!(\"The measure is not missing!\"),\n    None =&gt; println!(\"Oh no! The measure is missing\"),\n}\nWe put a placeholder value inside of Some(v) to create a binding to the inner value. It’s like a function argument, it can be called whatever you want it to be.\n\n\n\nSometimes dealing with options is a headache, particularly when we’re in the early stages of developing.\nWe can use .unwrap() or .expect() to grab the inner value of an option without matching.\nThis is dangerous!! because we are ignoring the possibility of a None. Unwrapping on a None leads to a panic. Panics cause your program to abort.\nthread 'main' panicked at src/main.rs:4:41:\ncalled `Option::unwrap()` on a `None` value\n\n\n\n\nModify the distance() method to take an Option&lt;&Measure&gt;\nWhen None use euclidean distance, otherwise use the provided distance measure\n\n\n\nThe exercise does not involve .unwrap() because it’s a bad habbit. Let’s try and form good habbits from the outset if possible.\n\n\nView solution\n\nimpl Point {\n    fn distance(&self, destination: &Self, measure: Option&lt;&Measure&gt;) -&gt; f64 {\n        match measure {\n            Some(m) =&gt; match m {\n                Measure::Euclidean =&gt; self.euclidean_distance(destination),\n                Measure::Haversine =&gt; self.haversine_distance(destination),\n            },\n            None =&gt; self.euclidean_distance(destination),\n        }\n    }\n}",
    "crumbs": [
      "`Some()` or `None`?"
    ]
  },
  {
    "objectID": "intro-rust/options.html#option",
    "href": "intro-rust/options.html#option",
    "title": "Some() or None?",
    "section": "",
    "text": "An Option is a special enum that has two possible values:\nenum Option {\n    Some(T),\n    None\n}\nWhen a value is missing, the option’s variant is None. When the option contains some value, the value is contained inside of the Some(T) variant.",
    "crumbs": [
      "`Some()` or `None`?"
    ]
  },
  {
    "objectID": "intro-rust/options.html#accessing-some-value",
    "href": "intro-rust/options.html#accessing-some-value",
    "title": "Some() or None?",
    "section": "",
    "text": "Since Option&lt;T&gt; are “just” an enum, we can match on the variants to access the values.\n// create an Option&lt;Measure&gt; that contains a value\nlet measure = Some(Measure::Euclidean);\n\nmatch measure {\n    Some(v) =&gt; println!(\"The measure is not missing!\"),\n    None =&gt; println!(\"Oh no! The measure is missing\"),\n}\nWe put a placeholder value inside of Some(v) to create a binding to the inner value. It’s like a function argument, it can be called whatever you want it to be.",
    "crumbs": [
      "`Some()` or `None`?"
    ]
  },
  {
    "objectID": "intro-rust/options.html#danger-.unwrap-.expect",
    "href": "intro-rust/options.html#danger-.unwrap-.expect",
    "title": "Some() or None?",
    "section": "",
    "text": "Sometimes dealing with options is a headache, particularly when we’re in the early stages of developing.\nWe can use .unwrap() or .expect() to grab the inner value of an option without matching.\nThis is dangerous!! because we are ignoring the possibility of a None. Unwrapping on a None leads to a panic. Panics cause your program to abort.\nthread 'main' panicked at src/main.rs:4:41:\ncalled `Option::unwrap()` on a `None` value",
    "crumbs": [
      "`Some()` or `None`?"
    ]
  },
  {
    "objectID": "intro-rust/options.html#exercise",
    "href": "intro-rust/options.html#exercise",
    "title": "Some() or None?",
    "section": "",
    "text": "Modify the distance() method to take an Option&lt;&Measure&gt;\nWhen None use euclidean distance, otherwise use the provided distance measure\n\n\n\nThe exercise does not involve .unwrap() because it’s a bad habbit. Let’s try and form good habbits from the outset if possible.\n\n\nView solution\n\nimpl Point {\n    fn distance(&self, destination: &Self, measure: Option&lt;&Measure&gt;) -&gt; f64 {\n        match measure {\n            Some(m) =&gt; match m {\n                Measure::Euclidean =&gt; self.euclidean_distance(destination),\n                Measure::Haversine =&gt; self.haversine_distance(destination),\n            },\n            None =&gt; self.euclidean_distance(destination),\n        }\n    }\n}",
    "crumbs": [
      "`Some()` or `None`?"
    ]
  },
  {
    "objectID": "intro-rust/iterators.html",
    "href": "intro-rust/iterators.html",
    "title": "Iterators",
    "section": "",
    "text": "TipObjective\n\n\n\n\nUnderstand what an iterator is and how to create one.\nLearn the difference between .iter() and .into_iter().\nUse basic iterator methods like .sum(), .min(), .max(), and .enumerate().\n\n\n\nSo far we have been using a for loop to iterate through our items. However, it is not the only way to iterate. Instead, we can use iterators. Iterators often are simpler and easier to use—particularly when modifying each element in a Vec&lt;T&gt;.\nIterators can be created from basic collections like vectors or arrays as well as more advanced types such as HashMaps. They produce a sequence of items that can be accessed (or modified) one at a time.\n\n\nWhen we use a for loop with a collection, we are consuming (moving) the underlying vector. Under the hood, using a for loop actually creates an iterator by calling the .into_iter() method.\nfor xi in x is identical to calling for xi in x.into_iter() for example:\nfn main() {\n    let nums = vec![3, 6, 9];\n\n    for n in nums.into_iter() {\n        println!(\"Value: {n}\");\n    }\n\n    // nums has been moved ❌\n    // println!(\"nums: {:?}\", nums);\n}\nRemember: .into_iter() consumes the original value.\nAlternatively, the .iter() method can be called which borrows the collection and produces an iterator where each item is a refernce.\nfn main() {\n    let nums = vec![3, 6, 9];\n\n    for n in nums.iter() {\n        println!(\"Reference to value: {}\", n);\n    }\n    // nums is still usable ✅\n    println!(\"nums: {:?}\", nums);\n}\n\n\n\nOnce you have an iterator, there are a number of methods that can be used. Some of the helpful ones are:\n\n.sum() — Add all the values together.\n.min() — Find the smallest value.\n.max() — Find the largest value.\n.enumerate() — Pairs each value with its index.\n\n\n\nThe .min() and .max() methods cannot reliably return the min/max of a Vec&lt;f64&gt; because of floating point weirdness. Instead they return Option&lt;&gt; which we will discuss later. Just know that they exist.\nThe sum() method would’ve been nice earlier, huh 😉. The .sum() method needs to have a type specified when using it. So we can specify the type when assigning the variable such as:\nfn main() {\n    let nums = vec![2, 4, 8];\n    let total: i32 = nums.iter().sum();\n    println!(\"Sum is: {}\", total);\n}\n\n\n\nOften it is quite nice to have the index associated with each item in an iterator. To do so, we can use .enumerate() after calling either .iter() or .into_iter(). This modifies each element to be a tuple with (i, xi).\n\n\n\n\n\n\nNote\n\n\n\nThe .enumerate() method returns the type usize which is a special type of unsigned integer. You can cast them to integers or floats using i as i32, for example.\n\n\nRust is 0 indexed so the first value of the enumeration is going to be 0.\nFor example:\nfn is_even(x: i32) -&gt; bool {\n    x % 2 == 0\n}\n\nfn main() {\n    let x = vec![2, 4, 8];\n\n    for (i, xi) in x.iter().enumerate() {\n        if is_even(i as i32) {\n            println!(\"i is even with value {xi}\");\n        }\n    }\n}\n\n\n\n\nModify the mean() function to calculate the mean using .iter()\nCreate a vector of 5 or more f64 values\nCalculate the mean and print the result\n\n\n\n\n\nView solution\n\nfn mean(x: &[f64]) -&gt; f64 {\n    let total: f64 = x.iter().sum();\n    total / x.len() as f64\n}\n\nfn main() {\n    let nums = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n    println!(\"Mean is: {}\", mean(&nums));\n}\n\n\n\n\n\n\nPrint the index and value for each item in a vector for only even values\n\n\n\n\n\nView solution\n\nfn main() {\n    let nums = vec![1, 2, 3, 4, 5, 6];\n\n    for (i, n) in nums.iter().enumerate() {\n        if n % 2 == 0 {\n            println!(\"Index {i}: {n} is even\");\n        }\n    }\n}",
    "crumbs": [
      "Iterators"
    ]
  },
  {
    "objectID": "intro-rust/iterators.html#consuming-vs.-borrowing",
    "href": "intro-rust/iterators.html#consuming-vs.-borrowing",
    "title": "Iterators",
    "section": "",
    "text": "When we use a for loop with a collection, we are consuming (moving) the underlying vector. Under the hood, using a for loop actually creates an iterator by calling the .into_iter() method.\nfor xi in x is identical to calling for xi in x.into_iter() for example:\nfn main() {\n    let nums = vec![3, 6, 9];\n\n    for n in nums.into_iter() {\n        println!(\"Value: {n}\");\n    }\n\n    // nums has been moved ❌\n    // println!(\"nums: {:?}\", nums);\n}\nRemember: .into_iter() consumes the original value.\nAlternatively, the .iter() method can be called which borrows the collection and produces an iterator where each item is a refernce.\nfn main() {\n    let nums = vec![3, 6, 9];\n\n    for n in nums.iter() {\n        println!(\"Reference to value: {}\", n);\n    }\n    // nums is still usable ✅\n    println!(\"nums: {:?}\", nums);\n}",
    "crumbs": [
      "Iterators"
    ]
  },
  {
    "objectID": "intro-rust/iterators.html#basic-iterator-methods",
    "href": "intro-rust/iterators.html#basic-iterator-methods",
    "title": "Iterators",
    "section": "",
    "text": "Once you have an iterator, there are a number of methods that can be used. Some of the helpful ones are:\n\n.sum() — Add all the values together.\n.min() — Find the smallest value.\n.max() — Find the largest value.\n.enumerate() — Pairs each value with its index.\n\n\n\nThe .min() and .max() methods cannot reliably return the min/max of a Vec&lt;f64&gt; because of floating point weirdness. Instead they return Option&lt;&gt; which we will discuss later. Just know that they exist.\nThe sum() method would’ve been nice earlier, huh 😉. The .sum() method needs to have a type specified when using it. So we can specify the type when assigning the variable such as:\nfn main() {\n    let nums = vec![2, 4, 8];\n    let total: i32 = nums.iter().sum();\n    println!(\"Sum is: {}\", total);\n}",
    "crumbs": [
      "Iterators"
    ]
  },
  {
    "objectID": "intro-rust/iterators.html#enumerated-iterators",
    "href": "intro-rust/iterators.html#enumerated-iterators",
    "title": "Iterators",
    "section": "",
    "text": "Often it is quite nice to have the index associated with each item in an iterator. To do so, we can use .enumerate() after calling either .iter() or .into_iter(). This modifies each element to be a tuple with (i, xi).\n\n\n\n\n\n\nNote\n\n\n\nThe .enumerate() method returns the type usize which is a special type of unsigned integer. You can cast them to integers or floats using i as i32, for example.\n\n\nRust is 0 indexed so the first value of the enumeration is going to be 0.\nFor example:\nfn is_even(x: i32) -&gt; bool {\n    x % 2 == 0\n}\n\nfn main() {\n    let x = vec![2, 4, 8];\n\n    for (i, xi) in x.iter().enumerate() {\n        if is_even(i as i32) {\n            println!(\"i is even with value {xi}\");\n        }\n    }\n}",
    "crumbs": [
      "Iterators"
    ]
  },
  {
    "objectID": "intro-rust/iterators.html#exercise-1",
    "href": "intro-rust/iterators.html#exercise-1",
    "title": "Iterators",
    "section": "",
    "text": "Modify the mean() function to calculate the mean using .iter()\nCreate a vector of 5 or more f64 values\nCalculate the mean and print the result\n\n\n\n\n\nView solution\n\nfn mean(x: &[f64]) -&gt; f64 {\n    let total: f64 = x.iter().sum();\n    total / x.len() as f64\n}\n\nfn main() {\n    let nums = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n    println!(\"Mean is: {}\", mean(&nums));\n}",
    "crumbs": [
      "Iterators"
    ]
  },
  {
    "objectID": "intro-rust/iterators.html#exercise-2",
    "href": "intro-rust/iterators.html#exercise-2",
    "title": "Iterators",
    "section": "",
    "text": "Print the index and value for each item in a vector for only even values\n\n\n\n\n\nView solution\n\nfn main() {\n    let nums = vec![1, 2, 3, 4, 5, 6];\n\n    for (i, n) in nums.iter().enumerate() {\n        if n % 2 == 0 {\n            println!(\"Index {i}: {n} is even\");\n        }\n    }\n}",
    "crumbs": [
      "Iterators"
    ]
  },
  {
    "objectID": "intro-rust/for-loops.html",
    "href": "intro-rust/for-loops.html",
    "title": "for-loops",
    "section": "",
    "text": "TipObjective\n\n\n\nBe able to iterate over a collection of values. Apply logic inside of the for loop.\n\n\n\n\nIn Rust, for loops are the easiest way to go over each item in a vector or array.\nfor value in collection {\n    // do something with value\n}\nWhen we iterate through a collection, each item takes on the value of the name you provide before in. For example for x in my_vec creates a binding to x at each iteration.\nfn main() {\n    let nums = vec![1, 2, 3];\n    for n in nums {\n        println!(\"n is: {}\", n);\n    }\n}\n\n\n\nR has some of the most flexible and unique scoping rules. Rust isn’t as kind. The rules are essentially:\n\nValues outside of the for loop are accessible inside of it.\nValues created inside of the for loop cannot be accessed outside of it.\n\n\n\n\n\n\n\n\n\nTipThis does compile\n\n\n\nfn main() {\n    let greeting = \"Hi\";\n    let names = vec![\"Alice\", \"Bob\"];\n\n    for name in names {\n        println!(\"{greeting}, {name}!\");\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\nImportantThis does not compile!\n\n\n\nfn main() {\n    let numbers = vec![1, 2, 3];\n\n    for n in numbers {\n        let doubled = n * 2;\n        println!(\"{n} doubled is {doubled}\");\n    }\n\n    // ❌ `doubled` doesn't exist here\n    // println!(\"Last doubled: {}\", doubled);\n}\n\n\n\n\n\n\nUsing a vector of integers, write a loop that prints:\n\n“Fizz” if divisible by 3\n“Buzz” if divisible by 5\n“FizzBuzz” if divisible by both\nThe number otherwise\n\nUse this vector: vec![1, 2, 3, 4, 5, 15]\n\n\n\n\nView hint\n\nfn main() {\n    let nums = vec![1, 2, 3, 4, 5, 15];\n\n    for n in nums {\n       // add fizz-buzz logic here referring to `n`\n    }\n}\n\n\n\nView solution\n\nfn main() {\n    let nums = vec![1, 2, 3, 4, 5, 15];\n\n    for n in nums {\n        if n % 15 == 0 {\n            println!(\"FizzBuzz\");\n        } else if n % 3 == 0 {\n            println!(\"Fizz\");\n        } else if n % 5 == 0 {\n            println!(\"Buzz\");\n        } else {\n            println!(\"{}\", n);\n        }\n    }\n}",
    "crumbs": [
      "`for`-loops"
    ]
  },
  {
    "objectID": "intro-rust/for-loops.html#for-loop-syntax",
    "href": "intro-rust/for-loops.html#for-loop-syntax",
    "title": "for-loops",
    "section": "",
    "text": "In Rust, for loops are the easiest way to go over each item in a vector or array.\nfor value in collection {\n    // do something with value\n}\nWhen we iterate through a collection, each item takes on the value of the name you provide before in. For example for x in my_vec creates a binding to x at each iteration.\nfn main() {\n    let nums = vec![1, 2, 3];\n    for n in nums {\n        println!(\"n is: {}\", n);\n    }\n}",
    "crumbs": [
      "`for`-loops"
    ]
  },
  {
    "objectID": "intro-rust/for-loops.html#scope",
    "href": "intro-rust/for-loops.html#scope",
    "title": "for-loops",
    "section": "",
    "text": "R has some of the most flexible and unique scoping rules. Rust isn’t as kind. The rules are essentially:\n\nValues outside of the for loop are accessible inside of it.\nValues created inside of the for loop cannot be accessed outside of it.\n\n\n\n\n\n\n\n\n\nTipThis does compile\n\n\n\nfn main() {\n    let greeting = \"Hi\";\n    let names = vec![\"Alice\", \"Bob\"];\n\n    for name in names {\n        println!(\"{greeting}, {name}!\");\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\nImportantThis does not compile!\n\n\n\nfn main() {\n    let numbers = vec![1, 2, 3];\n\n    for n in numbers {\n        let doubled = n * 2;\n        println!(\"{n} doubled is {doubled}\");\n    }\n\n    // ❌ `doubled` doesn't exist here\n    // println!(\"Last doubled: {}\", doubled);\n}",
    "crumbs": [
      "`for`-loops"
    ]
  },
  {
    "objectID": "intro-rust/for-loops.html#exercise",
    "href": "intro-rust/for-loops.html#exercise",
    "title": "for-loops",
    "section": "",
    "text": "Using a vector of integers, write a loop that prints:\n\n“Fizz” if divisible by 3\n“Buzz” if divisible by 5\n“FizzBuzz” if divisible by both\nThe number otherwise\n\nUse this vector: vec![1, 2, 3, 4, 5, 15]\n\n\n\n\nView hint\n\nfn main() {\n    let nums = vec![1, 2, 3, 4, 5, 15];\n\n    for n in nums {\n       // add fizz-buzz logic here referring to `n`\n    }\n}\n\n\n\nView solution\n\nfn main() {\n    let nums = vec![1, 2, 3, 4, 5, 15];\n\n    for n in nums {\n        if n % 15 == 0 {\n            println!(\"FizzBuzz\");\n        } else if n % 3 == 0 {\n            println!(\"Fizz\");\n        } else if n % 5 == 0 {\n            println!(\"Buzz\");\n        } else {\n            println!(\"{}\", n);\n        }\n    }\n}",
    "crumbs": [
      "`for`-loops"
    ]
  },
  {
    "objectID": "intro-rust/index.html",
    "href": "intro-rust/index.html",
    "title": "Rust for R Developers",
    "section": "",
    "text": "You want to build Rust powered R packages but don’t know where to start?",
    "crumbs": [
      "Rust for R Developers"
    ]
  },
  {
    "objectID": "intro-rust/index.html#what-is-this",
    "href": "intro-rust/index.html#what-is-this",
    "title": "Rust for R Developers",
    "section": "What is this?",
    "text": "What is this?\nThis is an opinionated and streamlined introduction to Rust to get you building fast ⚡️, and vectorized R functions within a few hours.",
    "crumbs": [
      "Rust for R Developers"
    ]
  },
  {
    "objectID": "intro-rust/index.html#who-is-it-for",
    "href": "intro-rust/index.html#who-is-it-for",
    "title": "Rust for R Developers",
    "section": "Who is it for?",
    "text": "Who is it for?\nWe get it. Learning Rust can be daunting and frankly, much of the “Intro to Rust” material out there isn’t immediately applicable to R or data science.\nThis introduction is designed for intermediate R developers.",
    "crumbs": [
      "Rust for R Developers"
    ]
  },
  {
    "objectID": "intro-rust/index.html#prerequisites",
    "href": "intro-rust/index.html#prerequisites",
    "title": "Rust for R Developers",
    "section": "Prerequisites",
    "text": "Prerequisites\nIt is recommended that you be familiar with fundamental computing concepts such as:\n\nData types such as floats, integers, and booleans\nIteration such as for / while loops, purrr::map() style iterators, and the apply() family of functions\nControl Flow\nWriting functions\n\n\nResources\n\nRead Advanced R Chapter 3\nRead Hands-On Programming with R, R for Data Science Chapter 26\nRead Advanced R Chapter 4\nRead R for Data Science Chapter 25, Advanced R Chapter 6",
    "crumbs": [
      "Rust for R Developers"
    ]
  },
  {
    "objectID": "intro-rust/collections.html",
    "href": "intro-rust/collections.html",
    "title": "Arrays and Vectors",
    "section": "",
    "text": "TipObjective\n\n\n\nLearn how to store multiple values of the same type in arrays and vectors. Understand the difference between arrays and vectors.\n\n\n\n\nArrays in Rust are fixed in size and hold values of the same type. Since the size is known ahead of time, it makes them fast but inflexible.\nfn main() {\n    let arr = [10, 20, 30, 40];\n    println!(\"Array: {:?}\", arr);\n}\n\n\n\n\n\n\nNote\n\n\n\nThe {:?} syntax is used for a Debug representation of a variable. Using {} is used for Displaying data.\nMore often than not, using {:?} will be your best option.\n\n\n\nArrays use square brackets: [1, 2, 3]\nTheir size is known at compile time.\nYou can’t add or remove elements.\nMostly used when performance is critical and size is known.\n\nThe type of an array is specified as [type; length], e.g.\nlet arr: [i32; 4] = [10, 20, 30, 40];\n\n\n\nVectors are like growable arrays. They are much more common in everyday Rust code. To create a vector with known values, use the vec![] macro. Like an array, they must all be the same type.\nfn main() {\n    let v = vec![1, 2, 3, 4, 5];\n    println!(\"Vector: {:?}\", v);\n}\nThe type of a vector is specified using Vec&lt;T&gt; where T is shorthand for any type.\nAn empty vector can be created using Vec::new() or vec![]. If creating an empty vector, the type must be inferred or made explicit. Vectors also have methods. Two handy ones are .len() for length, and .is_empty() (equivalent of .len() == 0)\n\n\n\n\n\n\nImportantCannot compile\n\n\n\nfn main() {\n    let x = Vec::new();\n    println!(\"x is empty: {}\", x.is_empty());\n}\n\n\nThis cannot compile because the type of x is not known. Rust can infer the type if the vector is used elsewhere where the type is known. To make it compile we must specify the type.\nfn main() {\n    let x: Vec&lt;f64&gt; = Vec::new();\n    println!(\"x is empty: {}\", x.is_empty());\n}\n\n\n\n\nCreate an array of 4 integers and print it.\nCreate a vector with 5 numbers and print it using {:?}.\nCompare the length of the array and the vector.\nBonus: create an empty i32 vector.\n\n\n\n\n\nView solution\n\nfn main() {\n    let arr = [1, 2, 3, 4];\n    println!(\"Array: {:?}\", arr);\n\n    let v = vec![10, 20, 30, 40, 50];\n    println!(\"Vector: {:?}\", v);\n\n    // Bonus:\n    let v = vec![42_i32; 0];\n}",
    "crumbs": [
      "Arrays and Vectors"
    ]
  },
  {
    "objectID": "intro-rust/collections.html#arrays",
    "href": "intro-rust/collections.html#arrays",
    "title": "Arrays and Vectors",
    "section": "",
    "text": "Arrays in Rust are fixed in size and hold values of the same type. Since the size is known ahead of time, it makes them fast but inflexible.\nfn main() {\n    let arr = [10, 20, 30, 40];\n    println!(\"Array: {:?}\", arr);\n}\n\n\n\n\n\n\nNote\n\n\n\nThe {:?} syntax is used for a Debug representation of a variable. Using {} is used for Displaying data.\nMore often than not, using {:?} will be your best option.\n\n\n\nArrays use square brackets: [1, 2, 3]\nTheir size is known at compile time.\nYou can’t add or remove elements.\nMostly used when performance is critical and size is known.\n\nThe type of an array is specified as [type; length], e.g.\nlet arr: [i32; 4] = [10, 20, 30, 40];",
    "crumbs": [
      "Arrays and Vectors"
    ]
  },
  {
    "objectID": "intro-rust/collections.html#vectors",
    "href": "intro-rust/collections.html#vectors",
    "title": "Arrays and Vectors",
    "section": "",
    "text": "Vectors are like growable arrays. They are much more common in everyday Rust code. To create a vector with known values, use the vec![] macro. Like an array, they must all be the same type.\nfn main() {\n    let v = vec![1, 2, 3, 4, 5];\n    println!(\"Vector: {:?}\", v);\n}\nThe type of a vector is specified using Vec&lt;T&gt; where T is shorthand for any type.\nAn empty vector can be created using Vec::new() or vec![]. If creating an empty vector, the type must be inferred or made explicit. Vectors also have methods. Two handy ones are .len() for length, and .is_empty() (equivalent of .len() == 0)\n\n\n\n\n\n\nImportantCannot compile\n\n\n\nfn main() {\n    let x = Vec::new();\n    println!(\"x is empty: {}\", x.is_empty());\n}\n\n\nThis cannot compile because the type of x is not known. Rust can infer the type if the vector is used elsewhere where the type is known. To make it compile we must specify the type.\nfn main() {\n    let x: Vec&lt;f64&gt; = Vec::new();\n    println!(\"x is empty: {}\", x.is_empty());\n}",
    "crumbs": [
      "Arrays and Vectors"
    ]
  },
  {
    "objectID": "intro-rust/collections.html#exercise",
    "href": "intro-rust/collections.html#exercise",
    "title": "Arrays and Vectors",
    "section": "",
    "text": "Create an array of 4 integers and print it.\nCreate a vector with 5 numbers and print it using {:?}.\nCompare the length of the array and the vector.\nBonus: create an empty i32 vector.\n\n\n\n\n\nView solution\n\nfn main() {\n    let arr = [1, 2, 3, 4];\n    println!(\"Array: {:?}\", arr);\n\n    let v = vec![10, 20, 30, 40, 50];\n    println!(\"Vector: {:?}\", v);\n\n    // Bonus:\n    let v = vec![42_i32; 0];\n}",
    "crumbs": [
      "Arrays and Vectors"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "extendr - extending R with Rust 🦀",
    "section": "",
    "text": "Build blazingly fast R packages 📦 with ease. The extendr ecosystem is developer-friendly and CRAN-ready. extendr let’s you write ergonomic and idomatic Rust without having to worry about R’s internals (much 😅)."
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "extendr - extending R with Rust 🦀",
    "section": "Getting Started",
    "text": "Getting Started\n\nDon’t have Rust installed yet? Start here.\nFamiliar with Rust and want to get your hands dirty? Follow along with a complete example."
  },
  {
    "objectID": "index.html#the-ecosystem",
    "href": "index.html#the-ecosystem",
    "title": "extendr - extending R with Rust 🦀",
    "section": "The ecosystem",
    "text": "The ecosystem\nRust crates 🦀 :\n\nextendr-api—ergonomic, opinionated, and safe interface between R and Rust\nextendr-engine—embed and use R in Rust\nextendr-ffi—hand-crafted bindings to R’s C-API\n\nR packages 📦 :\n\n{rextendr}—A {usethis}-like package that scaffolds extendr-powered R packages"
  },
  {
    "objectID": "index.html#quickstart",
    "href": "index.html#quickstart",
    "title": "extendr - extending R with Rust 🦀",
    "section": "Quickstart",
    "text": "Quickstart\nWe recommend using the development version of {rextendr} from GitHub.\n# Install from CRAN\ninstall.packages(\"rextendr\")\n\n# Development version\nremotes::install_github(\"extendr/rextendr\")\n\n# create a new R package\nusethis::create_package(\"helloextendr\")\n\n# Use extendr\nrextendr::use_extendr()\n\n# Document and build the package\nrextendr::document()\n\n# run hello_world()\nhello_world()\n#&gt; [1] \"Hello, world!\"\n\nExample: calling structs from R\nuse extendr_api::prelude::*;\n\n#[extendr]\n#[derive(Debug)]\nstruct Person {\n    pub name: String,\n}\n\n#[extendr]\nimpl Person {\n    fn new() -&gt; Self {\n        Self { name: \"\".to_string() }\n    }\n\n    fn set_name(&mut self, name: &str) {\n        self.name = name.to_string();\n    }\n\n    fn name(&self) -&gt; &str {\n        self.name.as_str()\n    }\n}\n\n#[extendr]\nfn my_function() { }\n\n// Macro to generate exports\nextendr_module! {\n    mod classes;\n    impl Person;\n    fn my_function;\n}\nThe #[extendr] attribute causes the compiler to generate wrapper and registration functions for R which are called when the package is loaded, thus allowing one to access Rust functions and structures in an R session:\n# call function\nmy_function()\n\n# create Person object\np &lt;- Person$new()\np$set_name(\"foo\")\np$name()   # \"foo\" is returned\nThis, of course, is just the tip of the iceberg, for there are many ways to use extendr in R:\n\nIn an interactive R session one may use rextendr::rust_function and friends to quickly prototype Rust code.\nIn an R package context, one may use rextendr::use_extendr() to setup a Rust powered R-package. See also the vignette on R-packages.\nIt is also possible to inline Rust code in Quarto documents, see vignette on extendr knitr-engine."
  },
  {
    "objectID": "CONTRIBUTING.html",
    "href": "CONTRIBUTING.html",
    "title": "Contributing",
    "section": "",
    "text": "We welcome contributions to the extendr project. Contributions come in many forms. Please carefully read and follow these guidelines. This will help us make the contribution process easy and effective for everyone involved. It also communicates that you agree to respect the time of the developers managing and developing this project.\n\n\n\nCode of Conduct\nGetting Started\n\nIssues\nPull Requests\n\nGetting Help\nAuthorship\nAttribution\n\n\n\n\nWe take our open source community seriously and hold ourselves and other contributors to high standards of communication. By participating and contributing to this project, you agree to uphold our Code of Conduct.\n\n\n\nContributions can be made via Issues and Pull Requests (PRs). A few general guidelines cover both:\n\nPlease search for existing Issues and PRs before creating your own.\nWe work hard to makes sure issues are handled in a timely manner but, depending on the problem and maintainer availability, it could take a while to investigate the problem. A friendly ping in the comment thread can help draw attention if an issue has not received any attention for a while. Please keep in mind that all contributors to this project are volunteers and may have other commitments they need to attend to.\n\n\n\nIssues should be used to report problems with the library, request a new feature, or to discuss potential changes before a PR is created. Please do not use Issues to request user support.\nWhenever possible, please provide a minimal reproducible example (reprex) to any bug report that you are filing. The more minimal your example, the more likely that somebody else can figure out what the problem is, so please remove any code that isn’t relevant to the problem you are reporting.\nPlease keep issues focused on one particular problem. Don’t feel shy about opening multiple issues if you’re encountering more than one problem.\nIf you find an Issue that addresses the problem you’re having, please add your own reproduction information to the existing issue rather than creating a new one. Adding a reaction can also help be indicating to our maintainers that a particular problem is affecting more than just the reporter.\n\n\n\nPRs are always welcome and can be a quick way to get your fix or improvement slated for the next release. However, please always open an Issue before submitting a PR.\nIn general, PRs should:\n\nAddress a single concern in the least number of changed lines as possible.\nOnly fix/add the functionality in question OR address wide-spread whitespace/style issues, not both.\nAdd unit or integration tests for fixed or changed functionality.\nInclude documentation.\nIndicate which Issue they address by using the words Closes #&lt;issue number&gt; or Fixes #&lt;issue number&gt; in the body of the PR and/or the git commit message. (See the GitHub Documentation for details about linking PRs to Issues and automatically closing Issues when merging PRs.)\n\nIn general, we follow the GitHub flow development model:\n\nFork the repository to your own Github account\nClone the project to your machine\nCreate a branch locally with a succinct but descriptive name\nCommit changes to the branch\nPush changes to your fork\nOpen a PR in our repository and follow the PR template so that we can efficiently review the changes.\n\n\n\n\n\nPlease join us on our Discord server for general conversations and questions that don’t belong into a GitHub issue.\n\n\n\nContributors who have made multiple, sustained, and/or non-trivial contributions to the project may be added to the author list. New author names will always be added at the end of the list, so that author order reflects chronological order of joining the project. All authorship decisions are at the discretion of the current maintainers of the project.\n\n\n\nThis document was adapted from the General Contributing Guidelines of the auth0 project."
  },
  {
    "objectID": "CONTRIBUTING.html#quicklinks",
    "href": "CONTRIBUTING.html#quicklinks",
    "title": "Contributing",
    "section": "",
    "text": "Code of Conduct\nGetting Started\n\nIssues\nPull Requests\n\nGetting Help\nAuthorship\nAttribution"
  },
  {
    "objectID": "CONTRIBUTING.html#code-of-conduct",
    "href": "CONTRIBUTING.html#code-of-conduct",
    "title": "Contributing",
    "section": "",
    "text": "We take our open source community seriously and hold ourselves and other contributors to high standards of communication. By participating and contributing to this project, you agree to uphold our Code of Conduct."
  },
  {
    "objectID": "CONTRIBUTING.html#getting-started",
    "href": "CONTRIBUTING.html#getting-started",
    "title": "Contributing",
    "section": "",
    "text": "Contributions can be made via Issues and Pull Requests (PRs). A few general guidelines cover both:\n\nPlease search for existing Issues and PRs before creating your own.\nWe work hard to makes sure issues are handled in a timely manner but, depending on the problem and maintainer availability, it could take a while to investigate the problem. A friendly ping in the comment thread can help draw attention if an issue has not received any attention for a while. Please keep in mind that all contributors to this project are volunteers and may have other commitments they need to attend to.\n\n\n\nIssues should be used to report problems with the library, request a new feature, or to discuss potential changes before a PR is created. Please do not use Issues to request user support.\nWhenever possible, please provide a minimal reproducible example (reprex) to any bug report that you are filing. The more minimal your example, the more likely that somebody else can figure out what the problem is, so please remove any code that isn’t relevant to the problem you are reporting.\nPlease keep issues focused on one particular problem. Don’t feel shy about opening multiple issues if you’re encountering more than one problem.\nIf you find an Issue that addresses the problem you’re having, please add your own reproduction information to the existing issue rather than creating a new one. Adding a reaction can also help be indicating to our maintainers that a particular problem is affecting more than just the reporter.\n\n\n\nPRs are always welcome and can be a quick way to get your fix or improvement slated for the next release. However, please always open an Issue before submitting a PR.\nIn general, PRs should:\n\nAddress a single concern in the least number of changed lines as possible.\nOnly fix/add the functionality in question OR address wide-spread whitespace/style issues, not both.\nAdd unit or integration tests for fixed or changed functionality.\nInclude documentation.\nIndicate which Issue they address by using the words Closes #&lt;issue number&gt; or Fixes #&lt;issue number&gt; in the body of the PR and/or the git commit message. (See the GitHub Documentation for details about linking PRs to Issues and automatically closing Issues when merging PRs.)\n\nIn general, we follow the GitHub flow development model:\n\nFork the repository to your own Github account\nClone the project to your machine\nCreate a branch locally with a succinct but descriptive name\nCommit changes to the branch\nPush changes to your fork\nOpen a PR in our repository and follow the PR template so that we can efficiently review the changes."
  },
  {
    "objectID": "CONTRIBUTING.html#getting-help",
    "href": "CONTRIBUTING.html#getting-help",
    "title": "Contributing",
    "section": "",
    "text": "Please join us on our Discord server for general conversations and questions that don’t belong into a GitHub issue."
  },
  {
    "objectID": "CONTRIBUTING.html#authorship",
    "href": "CONTRIBUTING.html#authorship",
    "title": "Contributing",
    "section": "",
    "text": "Contributors who have made multiple, sustained, and/or non-trivial contributions to the project may be added to the author list. New author names will always be added at the end of the list, so that author order reflects chronological order of joining the project. All authorship decisions are at the discretion of the current maintainers of the project."
  },
  {
    "objectID": "CONTRIBUTING.html#attribution",
    "href": "CONTRIBUTING.html#attribution",
    "title": "Contributing",
    "section": "",
    "text": "This document was adapted from the General Contributing Guidelines of the auth0 project."
  },
  {
    "objectID": "intro-rust/hello-world.html",
    "href": "intro-rust/hello-world.html",
    "title": "Hello, World!",
    "section": "",
    "text": "TipObjective\n\n\n\nLearn how to create a new Rust crate and understand its file structure. You will know how to use cargo run and the println!() macro.\n\n\nRust uses a tool called cargo for building, checking, and managing dependencies. This is installed for you when you used rustup to install Rust.\nTo create a new Rust crate, use cargo new name-of-crate. This creates a new directory called name-of-crate. Be sure to cd into that directory.\n\n\ncd is short for change directory. We use this to…yup…change the directory from the terminal.\n\n\nTwo types of crates: binary, library.\n\n\nThis first workshop we will work only with a binary crate. We will create a library in the second half of the day.\nBinary crates are standalone applications like command line tools, or things that run once—simiar to a script that you run with Rscript main.R\n\n\n\nA new crate looks like this:\nintro-to-rust/\n├── Cargo.toml      # Metadata & dependencies (like DESCRIPTION)\n├── Cargo.lock      # Dependency versions (like renv.lock)\n└── src/\n    └── main.rs     # Entry point — like main.R\n\n\n\nWhen you create a new rust binary the file src/main.rs is prepopulated with:\n\n\n\n\n\n\nTipsrc/main.rs\n\n\n\nThe main() function defines what is executed when your binary is run.\nfn main() {\n    println!(\"Hello, world!\");\n}\n\n\nThere are a few things going on in here:\n\nFunctions are declared using the fn keyword\nThe main() function is the entrypoint of the program (and required)\nBlocks of code are delimted using curly braces (like R & C)\nStatements end with ;\nprintln!() is a macro (notice the !) which is used to print to stdout\n\n\n\nWhen a program writes to the console it does so through file connections called standard output (stdout) and standard error (stderr).\nWhen we print a message with print() or message() in R, we print to stdout. When we make a warning or error using stop() or warning() in R, that is writing to stderr.\n\n\n\n\n\n\nImportant\n\n\n\nVariables can only be defined inside of the main() function.\n\n\n\n\n\n\nMacros have a !, like println!().\nThink of it like print() in R, but explicit.\nIt supports format strings:\n\n\n\n\n\nlet name = \"Josiah\";\nprintln!(\"Hello, {}!\", name);\n\n\n\nlet name = \"Josiah\";\nprintln!(\"Hello, {name}!\");\n\n\n\n\n\n\n\nIn your terminal, create a new rust crate called intro-to-rust\nOpen the new Rust crate’s folder in Positron\nRun the hello world program using cargo run\nCreate a variable called name inside of the main() function with your name\nPrint Hello, {name}! using println!()\nTo run it navigate to your terminal and then enter cargo run.\n\n\n\n\n\nView solution\n\nIn src/main.rs\nfn main() {\n    let name = \"Josiah\";\n    println!(\"Hello, {name}!\");\n}",
    "crumbs": [
      "Hello, World!"
    ]
  },
  {
    "objectID": "intro-rust/hello-world.html#crate-anatomy",
    "href": "intro-rust/hello-world.html#crate-anatomy",
    "title": "Hello, World!",
    "section": "",
    "text": "Two types of crates: binary, library.\n\n\nThis first workshop we will work only with a binary crate. We will create a library in the second half of the day.\nBinary crates are standalone applications like command line tools, or things that run once—simiar to a script that you run with Rscript main.R",
    "crumbs": [
      "Hello, World!"
    ]
  },
  {
    "objectID": "intro-rust/hello-world.html#crate-anatomy-1",
    "href": "intro-rust/hello-world.html#crate-anatomy-1",
    "title": "Hello, World!",
    "section": "",
    "text": "A new crate looks like this:\nintro-to-rust/\n├── Cargo.toml      # Metadata & dependencies (like DESCRIPTION)\n├── Cargo.lock      # Dependency versions (like renv.lock)\n└── src/\n    └── main.rs     # Entry point — like main.R",
    "crumbs": [
      "Hello, World!"
    ]
  },
  {
    "objectID": "intro-rust/hello-world.html#main.rs",
    "href": "intro-rust/hello-world.html#main.rs",
    "title": "Hello, World!",
    "section": "",
    "text": "When you create a new rust binary the file src/main.rs is prepopulated with:\n\n\n\n\n\n\nTipsrc/main.rs\n\n\n\nThe main() function defines what is executed when your binary is run.\nfn main() {\n    println!(\"Hello, world!\");\n}\n\n\nThere are a few things going on in here:\n\nFunctions are declared using the fn keyword\nThe main() function is the entrypoint of the program (and required)\nBlocks of code are delimted using curly braces (like R & C)\nStatements end with ;\nprintln!() is a macro (notice the !) which is used to print to stdout\n\n\n\nWhen a program writes to the console it does so through file connections called standard output (stdout) and standard error (stderr).\nWhen we print a message with print() or message() in R, we print to stdout. When we make a warning or error using stop() or warning() in R, that is writing to stderr.\n\n\n\n\n\n\nImportant\n\n\n\nVariables can only be defined inside of the main() function.",
    "crumbs": [
      "Hello, World!"
    ]
  },
  {
    "objectID": "intro-rust/hello-world.html#println",
    "href": "intro-rust/hello-world.html#println",
    "title": "Hello, World!",
    "section": "",
    "text": "Macros have a !, like println!().\nThink of it like print() in R, but explicit.\nIt supports format strings:\n\n\n\n\n\nlet name = \"Josiah\";\nprintln!(\"Hello, {}!\", name);\n\n\n\nlet name = \"Josiah\";\nprintln!(\"Hello, {name}!\");",
    "crumbs": [
      "Hello, World!"
    ]
  },
  {
    "objectID": "intro-rust/hello-world.html#exercise",
    "href": "intro-rust/hello-world.html#exercise",
    "title": "Hello, World!",
    "section": "",
    "text": "In your terminal, create a new rust crate called intro-to-rust\nOpen the new Rust crate’s folder in Positron\nRun the hello world program using cargo run\nCreate a variable called name inside of the main() function with your name\nPrint Hello, {name}! using println!()\nTo run it navigate to your terminal and then enter cargo run.\n\n\n\n\n\nView solution\n\nIn src/main.rs\nfn main() {\n    let name = \"Josiah\";\n    println!(\"Hello, {name}!\");\n}",
    "crumbs": [
      "Hello, World!"
    ]
  },
  {
    "objectID": "intro-rust/mutability.html",
    "href": "intro-rust/mutability.html",
    "title": "Mutability",
    "section": "",
    "text": "Tip\n\n\n\nUnderstand the difference between immutable and mutable variables.\n\n\nIn R everything is immutable (except environments). Immutable objects cannot be altered.\n\n\nInstead, when they are modified, they are copied. This is called copy-on-write (often referred to as cow semantics).\nIn Rust, variables are immutable by default. This means once a value is assigned to a variable, it cannot be changed. To make a variable mutable, you must explicitly use the mut keyword.\nlet mut x = 5;\nx = 6; // ✅ works because x is mutable\n\nUse mut when you need to change a variable after it is created.\nYou do not re-bind the variable with let when changing its value.\nThis helps catch bugs early by making data changes explicit.\n\nBy requiring mut, the compiler ensures that accidental mutations are caught at compile time.\n\n\nRevisiting our loop from earlier:\nfn main() {\n    // create a vector\n    let numbers = vec![1, 2, 3];\n    // create a mutable value\n    let mut doubled = 0;\n\n    // iterate through numbers to update doubled\n    for n in numbers {\n        doubled = n * 2;\n        println!(\"{} doubled is {}\", n, doubled);\n    }\n\n    // ✅ compiles because `doubled` was declared\n    // _outside_ of the inner loop scope\n    println!(\"Last doubled: {}\", doubled);\n}\n\n\n\n\nCreate a vector of 5 or more f64 values (Vec&lt;f64&gt;)\nUse a for loop to calculate the sum of the vector\nCalculate the mean from the sum of the vector and the length of the vector\nPrint the result\n\n\n\n\n\n\n\nTip\n\n\n\nYou can use += shorthand to add and assign all at the same time. For example x += 10 is equivalent to x = x + 10.\n\n\n\n\n\n\nView solution\n\nfn main() {\n    let x = vec![1.0, 2.0, 3.0, 4.0];\n\n    let n = x.len() as f64;\n    let mut total = 0.0;\n\n    for xi in x {\n        total += xi;\n    }\n\n    println!(\"The mean is: {}\", total / n);\n}",
    "crumbs": [
      "Mutability"
    ]
  },
  {
    "objectID": "intro-rust/mutability.html#example",
    "href": "intro-rust/mutability.html#example",
    "title": "Mutability",
    "section": "",
    "text": "Revisiting our loop from earlier:\nfn main() {\n    // create a vector\n    let numbers = vec![1, 2, 3];\n    // create a mutable value\n    let mut doubled = 0;\n\n    // iterate through numbers to update doubled\n    for n in numbers {\n        doubled = n * 2;\n        println!(\"{} doubled is {}\", n, doubled);\n    }\n\n    // ✅ compiles because `doubled` was declared\n    // _outside_ of the inner loop scope\n    println!(\"Last doubled: {}\", doubled);\n}",
    "crumbs": [
      "Mutability"
    ]
  },
  {
    "objectID": "intro-rust/mutability.html#exercise",
    "href": "intro-rust/mutability.html#exercise",
    "title": "Mutability",
    "section": "",
    "text": "Create a vector of 5 or more f64 values (Vec&lt;f64&gt;)\nUse a for loop to calculate the sum of the vector\nCalculate the mean from the sum of the vector and the length of the vector\nPrint the result\n\n\n\n\n\n\n\nTip\n\n\n\nYou can use += shorthand to add and assign all at the same time. For example x += 10 is equivalent to x = x + 10.\n\n\n\n\n\n\nView solution\n\nfn main() {\n    let x = vec![1.0, 2.0, 3.0, 4.0];\n\n    let n = x.len() as f64;\n    let mut total = 0.0;\n\n    for xi in x {\n        total += xi;\n    }\n\n    println!(\"The mean is: {}\", total / n);\n}",
    "crumbs": [
      "Mutability"
    ]
  },
  {
    "objectID": "intro-rust/parallelize.html",
    "href": "intro-rust/parallelize.html",
    "title": "Parallelizing",
    "section": "",
    "text": "Parallelizing\nTODO: before this we do combining iterators with .zip() and then go over destructuring into tuples there\n\nthis is a stretch exercise\nBrief intro to rayon\npar_iter()\ninto_par_iter()\nwith_min_len()\nObjective is to calculate the pairwise distances between two vectors of points super fast\nwe want to use .zip() to combine the two vectors\nthis would require using rand to create a vector of random numbers"
  },
  {
    "objectID": "intro-rust/iter-map.html",
    "href": "intro-rust/iter-map.html",
    "title": "Mapping over Iterators",
    "section": "",
    "text": "TipObjective\n\n\n\n\nUnderstand how to transform iterator values using .map()\nLearn how to use closures (anonymous functions) in Rust\nCollect iterator results back into a collection using .collect()\nUse turbofish 🐠💨 syntax for type annotations when needed\n\n\n\nOften we want to transform the values in a vector. To do this in Rust, we can use the .map() method. .map() lets us apply an operation on each element of the iterator.\nIn R, we often use the purrr::map() function or the apply() family of functions to do this.\n\n\nWe apply .map() to an iterator. For example, to square each element in a vector we can write:\n// providing explicit type annotation in one\n// value so the compiler knows its f64 and not f32\nlet x = vec![5.9_f64, 6.8, 4.5, 7.3, 6.2];\n\nx.iter().map(|xi| xi.powi(2))\nUsing .map() returns another iterator. We can chain operations over iterators by using multiple .map() statements.\n\n\n\nIn the above example we used a closure to modify each element of the iterator. Closures are Rust’s version of an anonymous function.\nA closure takes the structure |arg| expression. They can also be multiple lines by wrapping the expression in a braces:\nx\n    .iter()\n    .map(|xi| {\n        let squared = xi.powi(2);\n        xi.sqrt()\n    })\nSince iterators only contain one item, the closure only has one argument. However, you can use destructuring in the closure. For example if using .enumerate() we want to access i we can do so:\nx\n    .iter()\n    .enumerate()\n    .map(|(i, xi)| {\n        // do stuff here\n    })\n\n\n\nIn R when we use map() the results are always returned as a vector. In Rust, we have to explcitly collect the iterator into our own type using .collect().\nTypically iterators are collected into a Vec&lt;T&gt;. Rust cant always infer the type that you want to collect into so we must tell the compiler what type we want.\nWe can do this during assignment:\nlet x_squared: Vec&lt;f64&gt; = x.iter().map(|xi| xi.powi(2)).collect();\n\n\n\nAlternatively, we can use “turbofish” syntax. We can specify the type directly in the .collect() function. .collect() is a generic method. And in the words of the Rust standard library documentation (emphasis mine)\n\n“Because collect() is so general, it can cause problems with type inference. As such, collect() is one of the few times you’ll see the syntax affectionately known as the ‘turbofish’: ::&lt;&gt;. This helps the inference algorithm understand specifically which collection you’re trying to collect into.”\n\nTurbofish takes the structure of .collect::&lt;TYPE&gt;().\n\n\n\n\n\n\nfn main() {\n    let nums = vec![1, 2, 3];\n\n    // Add 1 to each element\n    let incremented: Vec&lt;_&gt; = nums.iter()\n        .map(|x| x + 1)\n        .collect();\n\n    println!(\"{:?}\", incremented);\n}\n\n\n\nfn main() {\n    let nums = vec![1, 2, 3];\n\n    // Add 1 to each element\n    let incremented = nums.iter()\n        .map(|x| x + 1)\n        .collect::&lt;Vec&lt;_&gt;&gt;();\n\n    println!(\"{:?}\", incremented);\n}\n\n\n\nTurbofish is a bit more awkward at first, but it is more flexible and doesn’t require modification whenever the inner type changes.\n\n\n\n\nCalculate the variance of a slice of f64 values.\n\\[\n\\text{variance} = \\frac{\\sum_{i=1}^n (x_i - \\bar{x})^2}{n - 1}\n\\]\n\nCreate a function variance() that:\n\nUses .map() to calculate squared differences from the mean\nUses .sum() to add them up\nDivides by n - 1\n\n\n\n\n\n\n\n\nTip\n\n\n\n\nUse .powi(2) to square values.\nUse your previously defined mean() function inside variance().\n\n\n\n\n\nView hint\n\nfn variance(x: &[f64]) -&gt; f64 {\n    let n = x.len() as f64;\n    let avg = mean(x);\n    let sq_diffs: f64 = x\n        .iter()\n        .map(|xi| ___ )  // squared difference here\n        .__();           // sum method here\n\n    sq_diffs / (n - 1.0)\n}\n\n\n\n\n\nView solution\n\nfn variance(x: &[f64]) -&gt; f64 {\n    let n = x.len() as f64;\n    let avg = mean(x);\n    let sq_diffs: f64 = x\n        .iter()\n        .map(|xi| (xi - avg).powi(2))\n        .sum();\n    sq_diffs / (n - 1.0)\n}\n\nfn main() {\n    let x = vec![2.0, 4.0, 4.0, 4.0, 5.0, 5.0, 7.0, 9.0];\n    println!(\"Variance is: {:.2}\", variance(&x));\n}\n\n\n\n\n\nCreate a function standardize() to perform z-score standardization on a vector of f64.\n\\[\nz_i = \\frac{x_i - \\mu}{\\sigma}\n\\]\n\nUse .iter() and .map() to calculate mean and variance.\nUse .into_iter(), .map(), and .collect() to build the standardized vector.\nReturn a new Vec&lt;f64&gt; of standardized values.\n\n\n\n\n\nView solution\n\nfn standardize(x: &[f64]) -&gt; Vec&lt;f64&gt; {\n    let avg = mean(x);\n    let std_dev = variance(x).sqrt();\n    x.iter().map(|xi| (xi - avg) / std_dev).collect()\n}\n\nfn main() {\n    let x = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n    let standardized = standardize(x);\n    println!(\"Standardized: {:?}\", standardized);\n}",
    "crumbs": [
      "Mapping over Iterators"
    ]
  },
  {
    "objectID": "intro-rust/iter-map.html#using-.map",
    "href": "intro-rust/iter-map.html#using-.map",
    "title": "Mapping over Iterators",
    "section": "",
    "text": "We apply .map() to an iterator. For example, to square each element in a vector we can write:\n// providing explicit type annotation in one\n// value so the compiler knows its f64 and not f32\nlet x = vec![5.9_f64, 6.8, 4.5, 7.3, 6.2];\n\nx.iter().map(|xi| xi.powi(2))\nUsing .map() returns another iterator. We can chain operations over iterators by using multiple .map() statements.",
    "crumbs": [
      "Mapping over Iterators"
    ]
  },
  {
    "objectID": "intro-rust/iter-map.html#closures",
    "href": "intro-rust/iter-map.html#closures",
    "title": "Mapping over Iterators",
    "section": "",
    "text": "In the above example we used a closure to modify each element of the iterator. Closures are Rust’s version of an anonymous function.\nA closure takes the structure |arg| expression. They can also be multiple lines by wrapping the expression in a braces:\nx\n    .iter()\n    .map(|xi| {\n        let squared = xi.powi(2);\n        xi.sqrt()\n    })\nSince iterators only contain one item, the closure only has one argument. However, you can use destructuring in the closure. For example if using .enumerate() we want to access i we can do so:\nx\n    .iter()\n    .enumerate()\n    .map(|(i, xi)| {\n        // do stuff here\n    })",
    "crumbs": [
      "Mapping over Iterators"
    ]
  },
  {
    "objectID": "intro-rust/iter-map.html#collecting-results",
    "href": "intro-rust/iter-map.html#collecting-results",
    "title": "Mapping over Iterators",
    "section": "",
    "text": "In R when we use map() the results are always returned as a vector. In Rust, we have to explcitly collect the iterator into our own type using .collect().\nTypically iterators are collected into a Vec&lt;T&gt;. Rust cant always infer the type that you want to collect into so we must tell the compiler what type we want.\nWe can do this during assignment:\nlet x_squared: Vec&lt;f64&gt; = x.iter().map(|xi| xi.powi(2)).collect();",
    "crumbs": [
      "Mapping over Iterators"
    ]
  },
  {
    "objectID": "intro-rust/iter-map.html#turbofish",
    "href": "intro-rust/iter-map.html#turbofish",
    "title": "Mapping over Iterators",
    "section": "",
    "text": "Alternatively, we can use “turbofish” syntax. We can specify the type directly in the .collect() function. .collect() is a generic method. And in the words of the Rust standard library documentation (emphasis mine)\n\n“Because collect() is so general, it can cause problems with type inference. As such, collect() is one of the few times you’ll see the syntax affectionately known as the ‘turbofish’: ::&lt;&gt;. This helps the inference algorithm understand specifically which collection you’re trying to collect into.”\n\nTurbofish takes the structure of .collect::&lt;TYPE&gt;().\n\n\n\n\n\n\nfn main() {\n    let nums = vec![1, 2, 3];\n\n    // Add 1 to each element\n    let incremented: Vec&lt;_&gt; = nums.iter()\n        .map(|x| x + 1)\n        .collect();\n\n    println!(\"{:?}\", incremented);\n}\n\n\n\nfn main() {\n    let nums = vec![1, 2, 3];\n\n    // Add 1 to each element\n    let incremented = nums.iter()\n        .map(|x| x + 1)\n        .collect::&lt;Vec&lt;_&gt;&gt;();\n\n    println!(\"{:?}\", incremented);\n}\n\n\n\nTurbofish is a bit more awkward at first, but it is more flexible and doesn’t require modification whenever the inner type changes.",
    "crumbs": [
      "Mapping over Iterators"
    ]
  },
  {
    "objectID": "intro-rust/iter-map.html#exercise-1",
    "href": "intro-rust/iter-map.html#exercise-1",
    "title": "Mapping over Iterators",
    "section": "",
    "text": "Calculate the variance of a slice of f64 values.\n\\[\n\\text{variance} = \\frac{\\sum_{i=1}^n (x_i - \\bar{x})^2}{n - 1}\n\\]\n\nCreate a function variance() that:\n\nUses .map() to calculate squared differences from the mean\nUses .sum() to add them up\nDivides by n - 1\n\n\n\n\n\n\n\n\nTip\n\n\n\n\nUse .powi(2) to square values.\nUse your previously defined mean() function inside variance().\n\n\n\n\n\nView hint\n\nfn variance(x: &[f64]) -&gt; f64 {\n    let n = x.len() as f64;\n    let avg = mean(x);\n    let sq_diffs: f64 = x\n        .iter()\n        .map(|xi| ___ )  // squared difference here\n        .__();           // sum method here\n\n    sq_diffs / (n - 1.0)\n}\n\n\n\n\n\nView solution\n\nfn variance(x: &[f64]) -&gt; f64 {\n    let n = x.len() as f64;\n    let avg = mean(x);\n    let sq_diffs: f64 = x\n        .iter()\n        .map(|xi| (xi - avg).powi(2))\n        .sum();\n    sq_diffs / (n - 1.0)\n}\n\nfn main() {\n    let x = vec![2.0, 4.0, 4.0, 4.0, 5.0, 5.0, 7.0, 9.0];\n    println!(\"Variance is: {:.2}\", variance(&x));\n}",
    "crumbs": [
      "Mapping over Iterators"
    ]
  },
  {
    "objectID": "intro-rust/iter-map.html#exercise-2",
    "href": "intro-rust/iter-map.html#exercise-2",
    "title": "Mapping over Iterators",
    "section": "",
    "text": "Create a function standardize() to perform z-score standardization on a vector of f64.\n\\[\nz_i = \\frac{x_i - \\mu}{\\sigma}\n\\]\n\nUse .iter() and .map() to calculate mean and variance.\nUse .into_iter(), .map(), and .collect() to build the standardized vector.\nReturn a new Vec&lt;f64&gt; of standardized values.\n\n\n\n\n\nView solution\n\nfn standardize(x: &[f64]) -&gt; Vec&lt;f64&gt; {\n    let avg = mean(x);\n    let std_dev = variance(x).sqrt();\n    x.iter().map(|xi| (xi - avg) / std_dev).collect()\n}\n\nfn main() {\n    let x = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n    let standardized = standardize(x);\n    println!(\"Standardized: {:?}\", standardized);\n}",
    "crumbs": [
      "Mapping over Iterators"
    ]
  },
  {
    "objectID": "intro-rust/is-odd.html",
    "href": "intro-rust/is-odd.html",
    "title": "Functions",
    "section": "",
    "text": "Tip\n\n\n\nLearn how to define and use your own functions in Rust.\n\n\nWe’ve already been modifying the main() function this whole time. We can create and use additional functions too.\nIn R, functions are yet another type of object that we create using &lt;- function(). In Rust, they are declared using fn keyword. Just like everything else in Rust, arguments are typed. Arguments take the structure of arg: type.\nMuch like R, the last object in a function body is return automatically. You do not need to use the return keyword unless you are performing an early return.\n\nfn name_of_function(arg1: ArgType) -&gt; ReturnType {\n    // function body\n    my_return_object\n}\n\n\nIdentifying if a number is odd or even isn’t always so easy!\n\n\n\nis-odd npm\n\n\nFirst define a function called is_even() that takes an i32 (integer) and returns a bool.\n\n\nIt may not be entirely obvious, but functions can be declared outside of the main() function.\nfn is_even(x: i32) -&gt; bool {\n    x % 2 == 0\n}\nWe can use our already defined function inside of another:\nfn is_odd(x: i32) -&gt; bool {\n    !is_even(x)\n}\n\n\n\nCreate a function called mean() that calculates the mean of a Vec&lt;f64&gt;.\n\nIn main(), create a vector x with 5 or more f64 values.\nCall mean(x) and print the result.\n\n\n\n\n\n\n\nNote\n\n\n\nUse x.len() to get the length and as f64 to convert it to a float.\n\n\n\n\n\n\nView solution\n\nfn mean(x: Vec&lt;f64&gt;) -&gt; f64 {\n    let mut total = 0.0;\n    let n = x.len();\n    for xi in x {\n        total += xi;\n    }\n    total / n as f64\n}\n\nfn main() {\n    let x = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n    let result = mean(x);\n    println!(\"Mean is: {}\", result);\n}",
    "crumbs": [
      "Functions"
    ]
  },
  {
    "objectID": "intro-rust/is-odd.html#example",
    "href": "intro-rust/is-odd.html#example",
    "title": "Functions",
    "section": "",
    "text": "Identifying if a number is odd or even isn’t always so easy!\n\n\n\nis-odd npm\n\n\nFirst define a function called is_even() that takes an i32 (integer) and returns a bool.\n\n\nIt may not be entirely obvious, but functions can be declared outside of the main() function.\nfn is_even(x: i32) -&gt; bool {\n    x % 2 == 0\n}\nWe can use our already defined function inside of another:\nfn is_odd(x: i32) -&gt; bool {\n    !is_even(x)\n}",
    "crumbs": [
      "Functions"
    ]
  },
  {
    "objectID": "intro-rust/is-odd.html#exercise",
    "href": "intro-rust/is-odd.html#exercise",
    "title": "Functions",
    "section": "",
    "text": "Create a function called mean() that calculates the mean of a Vec&lt;f64&gt;.\n\nIn main(), create a vector x with 5 or more f64 values.\nCall mean(x) and print the result.\n\n\n\n\n\n\n\nNote\n\n\n\nUse x.len() to get the length and as f64 to convert it to a float.\n\n\n\n\n\n\nView solution\n\nfn mean(x: Vec&lt;f64&gt;) -&gt; f64 {\n    let mut total = 0.0;\n    let n = x.len();\n    for xi in x {\n        total += xi;\n    }\n    total / n as f64\n}\n\nfn main() {\n    let x = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n    let result = mean(x);\n    println!(\"Mean is: {}\", result);\n}",
    "crumbs": [
      "Functions"
    ]
  },
  {
    "objectID": "intro-rust/references-slices.html",
    "href": "intro-rust/references-slices.html",
    "title": "Ownership",
    "section": "",
    "text": "TipObjective\n\n\n\nUnderstand the how Rust ensures memory safety through the borrow checker and be able to avoid issues by borrowing, using a slice, or cloning.\n\n\nRust is notorious for its borrow checker. The borrow check is Rust’s secret sauce which helps ensure memory safety. At compile time, Rust looks through all of your code to enforce ownership. The key is that\n\n\n\nIf a variable has been used it has been moved. There are a number of ways to reuse variables.\n\n\nA move occurs whenever a variable is used by a function or a method.\nfn main() {\n    let x = vec![1.0, 2.0, 3.0];\n    let y = x; // ⬅️ ownership moved\n    println!(\"{:?}\", x); // ❌ error: value used after move\n}\nSince x was moved (used) by assigning it to y, the original value cannot be used.\n\n\n\nThe simplest but least efficient way to reuse a variable is to clone it. This is what R does.\n\n\n\n\n\n\nTip\n\n\n\nRemember: when in doubt, clone it out!\n\n\nAlmost everything in Rust can be cloned by using the .clone() method.\n\n\n\n\n\n\nImportantCannot compile\n\n\n\nlet x  = v![0.0, 3.14, 10.1, 44.8];\n\nlet avg1 = mean(x); // ⬅️ x moved here!\nlet avg2 = mean(x); // ❌ compiler error\n\n\nIf we first clone x before using mean() we can use x again.\nlet x  = v![0.0, 3.14, 10.1, 44.8];\n\nlet avg1 = mean(x.clone()); // ⬅️ x cloned here!\nlet avg2 = mean(x); // ✅ compiler happy\n\n\n\nWhile variables may only be used once, they can be borrowed infinitely (until they go out of scope). A variable can be used by reference when the & symbol is placed in front of it—e.g. arg: &Vec&lt;f64&gt;.\nfn main() {\n    let x = vec![1.0, 2.0, 3.0];\n    let avg = mean(&x); // 👈 borrowing `x`\n    println!(\"x is still usable: {:?}\", x);\n}\nIf you borrow a variable you cannot mutate it or move it.\n\n\n\nSlices are a special type of borrowing. Slices are a reference to contiguous section of the same type. They’re recognized by the syntax &[T].\nSlices always have a known length (accessed via .len()) and can be used from more than one type.\n\n\nBoth an array [f64; N] and a Vec&lt;f64&gt; can be turned into a &[f64]\nlet x = [0.0, 20.0, 742.3];\nlet y = vec![1.0, 2.0, 3.0];\n\nlet avg_x = mean(&x)\nlet avg_y = mean(&y);\nSlices are more flexible and more light-weight than borrowing a full vector and should be preferred whenever possible.\nIn general: slice &gt; reference &gt; owned\n\n\n\n\n\n\nCalculate the mean of the same Vec&lt;f64&gt; twice\nPrint the vector at the end\n\n\n\nView solution\n\nfn mean(x: Vec&lt;f64&gt;) -&gt; f64 {\n    let mut total = 0.0;\n    for xi in x {\n        total += xi;\n    }\n    total / x.len() as f64\n}\n\nfn main() {\n    let x = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n    let result = mean(x.clone());\n    let result2 = mean(x.clone())\n    println!(\"The vector is still {:?}\", x);\n}\n\n\n\n\n\nRewrite the mean() function to accept a reference to a Vec&lt;f64&gt; instead of taking ownership\nThen call it with a borrowed vector.\n\n\n\nView solution\n\nfn mean(x: &Vec&lt;f64&gt;) -&gt; f64 {\n    let mut total = 0.0;\n    for xi in x {\n        total += xi;\n    }\n    total / x.len() as f64\n}\n\nfn main() {\n    let x = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n    let result = mean(&x);\n    println!(\"The mean of x is {result}\");\n}\n\n\n\n\n\nRewrite mean() to accept a slice (&[f64]) instead of a Vec&lt;f64&gt; reference.\nCreate an array of f64 values called y\nCalculate the mean on both x and y\nPrint both averages\n\n\n\nView solution\n\nfn mean(x: &[f64]) -&gt; f64 {\n    let mut total = 0.0;\n    for xi in x {\n        total += xi;\n    }\n    total / x.len() as f64\n}\n\nfn main() {\n    let x = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n    let y = [0.0, 9.5, 3.3, 11.78, 3.14159];\n    println!(\"The mean of x is {}.\\nThe mean of y is {}\", mean(&x), mean(&y));\n}",
    "crumbs": [
      "Ownership"
    ]
  },
  {
    "objectID": "intro-rust/references-slices.html#moves",
    "href": "intro-rust/references-slices.html#moves",
    "title": "Ownership",
    "section": "",
    "text": "A move occurs whenever a variable is used by a function or a method.\nfn main() {\n    let x = vec![1.0, 2.0, 3.0];\n    let y = x; // ⬅️ ownership moved\n    println!(\"{:?}\", x); // ❌ error: value used after move\n}\nSince x was moved (used) by assigning it to y, the original value cannot be used.",
    "crumbs": [
      "Ownership"
    ]
  },
  {
    "objectID": "intro-rust/references-slices.html#cloning",
    "href": "intro-rust/references-slices.html#cloning",
    "title": "Ownership",
    "section": "",
    "text": "The simplest but least efficient way to reuse a variable is to clone it. This is what R does.\n\n\n\n\n\n\nTip\n\n\n\nRemember: when in doubt, clone it out!\n\n\nAlmost everything in Rust can be cloned by using the .clone() method.\n\n\n\n\n\n\nImportantCannot compile\n\n\n\nlet x  = v![0.0, 3.14, 10.1, 44.8];\n\nlet avg1 = mean(x); // ⬅️ x moved here!\nlet avg2 = mean(x); // ❌ compiler error\n\n\nIf we first clone x before using mean() we can use x again.\nlet x  = v![0.0, 3.14, 10.1, 44.8];\n\nlet avg1 = mean(x.clone()); // ⬅️ x cloned here!\nlet avg2 = mean(x); // ✅ compiler happy",
    "crumbs": [
      "Ownership"
    ]
  },
  {
    "objectID": "intro-rust/references-slices.html#borrowing",
    "href": "intro-rust/references-slices.html#borrowing",
    "title": "Ownership",
    "section": "",
    "text": "While variables may only be used once, they can be borrowed infinitely (until they go out of scope). A variable can be used by reference when the & symbol is placed in front of it—e.g. arg: &Vec&lt;f64&gt;.\nfn main() {\n    let x = vec![1.0, 2.0, 3.0];\n    let avg = mean(&x); // 👈 borrowing `x`\n    println!(\"x is still usable: {:?}\", x);\n}\nIf you borrow a variable you cannot mutate it or move it.",
    "crumbs": [
      "Ownership"
    ]
  },
  {
    "objectID": "intro-rust/references-slices.html#slices",
    "href": "intro-rust/references-slices.html#slices",
    "title": "Ownership",
    "section": "",
    "text": "Slices are a special type of borrowing. Slices are a reference to contiguous section of the same type. They’re recognized by the syntax &[T].\nSlices always have a known length (accessed via .len()) and can be used from more than one type.\n\n\nBoth an array [f64; N] and a Vec&lt;f64&gt; can be turned into a &[f64]\nlet x = [0.0, 20.0, 742.3];\nlet y = vec![1.0, 2.0, 3.0];\n\nlet avg_x = mean(&x)\nlet avg_y = mean(&y);\nSlices are more flexible and more light-weight than borrowing a full vector and should be preferred whenever possible.\nIn general: slice &gt; reference &gt; owned",
    "crumbs": [
      "Ownership"
    ]
  },
  {
    "objectID": "intro-rust/references-slices.html#exercise-1",
    "href": "intro-rust/references-slices.html#exercise-1",
    "title": "Ownership",
    "section": "",
    "text": "Calculate the mean of the same Vec&lt;f64&gt; twice\nPrint the vector at the end\n\n\n\nView solution\n\nfn mean(x: Vec&lt;f64&gt;) -&gt; f64 {\n    let mut total = 0.0;\n    for xi in x {\n        total += xi;\n    }\n    total / x.len() as f64\n}\n\nfn main() {\n    let x = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n    let result = mean(x.clone());\n    let result2 = mean(x.clone())\n    println!(\"The vector is still {:?}\", x);\n}",
    "crumbs": [
      "Ownership"
    ]
  },
  {
    "objectID": "intro-rust/references-slices.html#exercise-2",
    "href": "intro-rust/references-slices.html#exercise-2",
    "title": "Ownership",
    "section": "",
    "text": "Rewrite the mean() function to accept a reference to a Vec&lt;f64&gt; instead of taking ownership\nThen call it with a borrowed vector.\n\n\n\nView solution\n\nfn mean(x: &Vec&lt;f64&gt;) -&gt; f64 {\n    let mut total = 0.0;\n    for xi in x {\n        total += xi;\n    }\n    total / x.len() as f64\n}\n\nfn main() {\n    let x = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n    let result = mean(&x);\n    println!(\"The mean of x is {result}\");\n}",
    "crumbs": [
      "Ownership"
    ]
  },
  {
    "objectID": "intro-rust/references-slices.html#exercise-3",
    "href": "intro-rust/references-slices.html#exercise-3",
    "title": "Ownership",
    "section": "",
    "text": "Rewrite mean() to accept a slice (&[f64]) instead of a Vec&lt;f64&gt; reference.\nCreate an array of f64 values called y\nCalculate the mean on both x and y\nPrint both averages\n\n\n\nView solution\n\nfn mean(x: &[f64]) -&gt; f64 {\n    let mut total = 0.0;\n    for xi in x {\n        total += xi;\n    }\n    total / x.len() as f64\n}\n\nfn main() {\n    let x = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n    let y = [0.0, 9.5, 3.3, 11.78, 3.14159];\n    println!(\"The mean of x is {}.\\nThe mean of y is {}\", mean(&x), mean(&y));\n}",
    "crumbs": [
      "Ownership"
    ]
  },
  {
    "objectID": "intro-rust/fizz-buzz.html",
    "href": "intro-rust/fizz-buzz.html",
    "title": "Control Flow",
    "section": "",
    "text": "TipObjective\n\n\n\nUnderstand control flow and numeric operators in Rust. You will create the FizzBuzz program using Rust!\n\n\n\n\n\n+ addition\n- subtraction\n/ division\n% remainder\n\n\n\n\nLogical operators are quite similar to R. The difference is that these operations are not vectorised. Furthermore, in Rust, a logical is called bool for booleans. bools can take on only two values: true or false.\n\n== check equality\n!= check inequality\n! negate a logical value\n&& logical AND comparison\n|| logical OR comparison\n\n\n\n\nRust uses if, else, and else if statements just like R. Where each branch is delimted by curly braces.\n\n\n\n\n\n\nWarning\n\n\n\nEach branch of the if statement must return the same type. For this portion of the workshop, be sure to terminate each statement with ; inside of the if statement so that nothing (unit type) is returned.\n\n\nif x == y {\n  // do something\n} else {\n  // do something else\n}\nThe key difference is that the use of parentheses is not necessary for the conditional statement.\n\n\n\nThis exercise you will create the famous FizzBuzz program.\nFor this, create a variable i. The rules are:\n\nwhen i is a multiple of 3, print Fizz\nwhen i is a multiple of 5, print Buzz\nwhen i is a multiple of both 3 and 5, print FizzBuzz\n\n\n\n\n\nView solution\n\nfn main() {\n    // let i = 15; // FizzBuzz\n    // let i = 3; // Fizz\n    // let i = 5; // Buzz\n    let i = 47; // Nothing\n    if (i % 3 == 0) && (i % 5 == 0) {\n        println!(\"FizzBuzz\");\n    } else if i % 3 == 0 {\n        println!(\"Fizz\");\n    } else if i % 5 == 0 {\n        println!(\"Buzz\");\n    }\n}",
    "crumbs": [
      "Control Flow"
    ]
  },
  {
    "objectID": "intro-rust/fizz-buzz.html#numeric-operators",
    "href": "intro-rust/fizz-buzz.html#numeric-operators",
    "title": "Control Flow",
    "section": "",
    "text": "+ addition\n- subtraction\n/ division\n% remainder",
    "crumbs": [
      "Control Flow"
    ]
  },
  {
    "objectID": "intro-rust/fizz-buzz.html#logical-operators",
    "href": "intro-rust/fizz-buzz.html#logical-operators",
    "title": "Control Flow",
    "section": "",
    "text": "Logical operators are quite similar to R. The difference is that these operations are not vectorised. Furthermore, in Rust, a logical is called bool for booleans. bools can take on only two values: true or false.\n\n== check equality\n!= check inequality\n! negate a logical value\n&& logical AND comparison\n|| logical OR comparison",
    "crumbs": [
      "Control Flow"
    ]
  },
  {
    "objectID": "intro-rust/fizz-buzz.html#control-flow-1",
    "href": "intro-rust/fizz-buzz.html#control-flow-1",
    "title": "Control Flow",
    "section": "",
    "text": "Rust uses if, else, and else if statements just like R. Where each branch is delimted by curly braces.\n\n\n\n\n\n\nWarning\n\n\n\nEach branch of the if statement must return the same type. For this portion of the workshop, be sure to terminate each statement with ; inside of the if statement so that nothing (unit type) is returned.\n\n\nif x == y {\n  // do something\n} else {\n  // do something else\n}\nThe key difference is that the use of parentheses is not necessary for the conditional statement.",
    "crumbs": [
      "Control Flow"
    ]
  },
  {
    "objectID": "intro-rust/fizz-buzz.html#exercise",
    "href": "intro-rust/fizz-buzz.html#exercise",
    "title": "Control Flow",
    "section": "",
    "text": "This exercise you will create the famous FizzBuzz program.\nFor this, create a variable i. The rules are:\n\nwhen i is a multiple of 3, print Fizz\nwhen i is a multiple of 5, print Buzz\nwhen i is a multiple of both 3 and 5, print FizzBuzz\n\n\n\n\n\nView solution\n\nfn main() {\n    // let i = 15; // FizzBuzz\n    // let i = 3; // Fizz\n    // let i = 5; // Buzz\n    let i = 47; // Nothing\n    if (i % 3 == 0) && (i % 5 == 0) {\n        println!(\"FizzBuzz\");\n    } else if i % 3 == 0 {\n        println!(\"Fizz\");\n    } else if i % 5 == 0 {\n        println!(\"Buzz\");\n    }\n}",
    "crumbs": [
      "Control Flow"
    ]
  },
  {
    "objectID": "intro-rust/types.html",
    "href": "intro-rust/types.html",
    "title": "Basic Types",
    "section": "",
    "text": "TipObjective\n\n\n\nFamiliarize yourself with basic types in Rust and when they may be used.\n\n\nIn R everything is a vector. A vector is a collection of values. There is no scalar type for a double/ character / integer / logical vector. Those are just length 1 vectors.\nIn Rust, however, scalars are the building blocks of everything. When a collection is needed those are made directly from scalars. You will often hear of these as primitives.\nToday we will only be using a handful of these primitives but it is important to understand what they are—in general.\n\n\nIntegers are either signed or unsigned.\nA signed integer can contain a negative value. Whereas an unsigned integer can contain only positive numbers.\n\nSigned Integers: i8, i16, i32, i64, i128\nUnsigned Integers: u8, u16, u32, u64, u128\n\n\n\n\n\n\n\nNote\n\n\n\nIn R, an integer vector is comprised of i32 values.\n\n\nThe letter prefix is the type of primitive. The following number indicates how many bits can be used to store the values. Unsigned integers can contain more possible values because they do not have to support negative numbers.\ni32::MAX // 2147483647\nu32::MAX // 4294967295\n\n\n\nIn many cases where we need to do math we will use a floating point number. Floating points are signed and allow for decimal values.\nThere are two types: f32 and f64.\n\n\n\n\n\n\nNote\n\n\n\nIn R, a double vector is comprised of f64 values.\n\n\n\n\n\nRust will infer a value’s type exceptionally well! However, we may want to specify the type manually as well. We can do this 2 primary ways:\n\nIn assignment using : for example let x: f64 = 10;\nOr by specifying the suffix e.g. 10f64 or 10_i32\n\n\n\n\n\n\n\nTip\n\n\n\nYou can use _ as a visual separator when specifying numbers in Rust. The following are all identical values:\nlet x: i32 = 1000;\nlet x = 1000i32;\nlet x = 1_000_i32;\n\n\n\n\n\nIn Rust, math expressions can only be performed between like-types. You cannot add 2.0 + 3_f64. To accomplish this we must cast to the same types.\nPrimitive types can be cast into one another using the as keyword. To add an f64 to an i32 we should ensure they’re the same type.\nfn add2(x: f64, y: i32) -&gt; f64 {\n   x + y as f64\n}\n\n\n\nIn Rust there is no concept of NULL. Instead there is the unit type which is represented as ().\n\n\nThe unit type is technically a tuple without any fields. If the internet is to be believed it is called “unit” becaue it can only have one value and is related to the “singleton” or unit set in set theory.\nFunctions that do not return anything technically return ().\n\n\n\nModify src/main.rs to add two or more incompatible types.\n\nDefine a variable x to be an f64 value\nDefine y to be an i32 value\nAdd them up and store them in the variable z\nUse println!() to print the value of z\n\n\n\n\n\nView solution\n\nfn main() {\n    let x = 3.14;\n    let y = 47_i32;\n    let z = x + y as f64;\n    println!(\" The value of z is {z}\");\n}",
    "crumbs": [
      "Basic Types"
    ]
  },
  {
    "objectID": "intro-rust/types.html#integers",
    "href": "intro-rust/types.html#integers",
    "title": "Basic Types",
    "section": "",
    "text": "Integers are either signed or unsigned.\nA signed integer can contain a negative value. Whereas an unsigned integer can contain only positive numbers.\n\nSigned Integers: i8, i16, i32, i64, i128\nUnsigned Integers: u8, u16, u32, u64, u128\n\n\n\n\n\n\n\nNote\n\n\n\nIn R, an integer vector is comprised of i32 values.\n\n\nThe letter prefix is the type of primitive. The following number indicates how many bits can be used to store the values. Unsigned integers can contain more possible values because they do not have to support negative numbers.\ni32::MAX // 2147483647\nu32::MAX // 4294967295",
    "crumbs": [
      "Basic Types"
    ]
  },
  {
    "objectID": "intro-rust/types.html#floating-point",
    "href": "intro-rust/types.html#floating-point",
    "title": "Basic Types",
    "section": "",
    "text": "In many cases where we need to do math we will use a floating point number. Floating points are signed and allow for decimal values.\nThere are two types: f32 and f64.\n\n\n\n\n\n\nNote\n\n\n\nIn R, a double vector is comprised of f64 values.",
    "crumbs": [
      "Basic Types"
    ]
  },
  {
    "objectID": "intro-rust/types.html#strong-typing",
    "href": "intro-rust/types.html#strong-typing",
    "title": "Basic Types",
    "section": "",
    "text": "Rust will infer a value’s type exceptionally well! However, we may want to specify the type manually as well. We can do this 2 primary ways:\n\nIn assignment using : for example let x: f64 = 10;\nOr by specifying the suffix e.g. 10f64 or 10_i32\n\n\n\n\n\n\n\nTip\n\n\n\nYou can use _ as a visual separator when specifying numbers in Rust. The following are all identical values:\nlet x: i32 = 1000;\nlet x = 1000i32;\nlet x = 1_000_i32;",
    "crumbs": [
      "Basic Types"
    ]
  },
  {
    "objectID": "intro-rust/types.html#type-casting",
    "href": "intro-rust/types.html#type-casting",
    "title": "Basic Types",
    "section": "",
    "text": "In Rust, math expressions can only be performed between like-types. You cannot add 2.0 + 3_f64. To accomplish this we must cast to the same types.\nPrimitive types can be cast into one another using the as keyword. To add an f64 to an i32 we should ensure they’re the same type.\nfn add2(x: f64, y: i32) -&gt; f64 {\n   x + y as f64\n}",
    "crumbs": [
      "Basic Types"
    ]
  },
  {
    "objectID": "intro-rust/types.html#unit-type",
    "href": "intro-rust/types.html#unit-type",
    "title": "Basic Types",
    "section": "",
    "text": "In Rust there is no concept of NULL. Instead there is the unit type which is represented as ().\n\n\nThe unit type is technically a tuple without any fields. If the internet is to be believed it is called “unit” becaue it can only have one value and is related to the “singleton” or unit set in set theory.\nFunctions that do not return anything technically return ().",
    "crumbs": [
      "Basic Types"
    ]
  },
  {
    "objectID": "intro-rust/types.html#exercise",
    "href": "intro-rust/types.html#exercise",
    "title": "Basic Types",
    "section": "",
    "text": "Modify src/main.rs to add two or more incompatible types.\n\nDefine a variable x to be an f64 value\nDefine y to be an i32 value\nAdd them up and store them in the variable z\nUse println!() to print the value of z\n\n\n\n\n\nView solution\n\nfn main() {\n    let x = 3.14;\n    let y = 47_i32;\n    let z = x + y as f64;\n    println!(\" The value of z is {z}\");\n}",
    "crumbs": [
      "Basic Types"
    ]
  },
  {
    "objectID": "intro-rust/mutable-vectors.html",
    "href": "intro-rust/mutable-vectors.html",
    "title": "Mutable Vectors",
    "section": "",
    "text": "TipObjective\n\n\n\nLearn how to create and modify vectors with mutable operations.\n\n\nIn Rust, vectors (Vec&lt;T&gt;) are growable arrays. To modify a vector after creating it, the vector itself must be declared as mut.\n\n\n\n\n\n\nNote\n\n\n\nYou will often see &lt;T&gt; in Rust code or documentation. T is a way of saying “of any type.” Seeing Vec&lt;T&gt; can be read as “a vector of any type” or “generic over type T.”\n\n\n\n\nYou can create an empty vector and let Rust infer the type based on usage:\nfn main() {\n    let mut names = Vec::new();\n    names.push(\"Alice\");\n    names.push(\"Bob\");\n    println!(\"{:?}\", names);\n}\n\nVec::new() creates an empty vector.\n.push() adds an element to the end of a vector.\n\n\n\n\nYou can remove all elements from a vector using .clear():\nfn main() {\n    let mut nums = vec![1, 2, 3];\n    nums.clear();\n    println!(\"{:?}\", nums); // prints []\n}\n\n\n\nUse .sort() to sort a vector. Important to note that not all types can be sorted.\nfn main() {\n    let mut x = vec![11, 3, 7, 10, 1];\n    println!(\"x before sorting: {x:?}\");\n    x.sort();\n    println!(\"x after sorting:  {x:?}\");\n}\nx before sorting: [11, 3, 7, 10, 1]\nx after sorting:  [1, 3, 7, 10, 11]\n\n\n\nUse .extend() to append one vector’s contents to another:\nfn main() {\n    let mut a = vec![1, 2];\n    let b = vec![3, 4];\n    // note that we don't assign.\n    // Instead, `a` is modified in place\n    a.extend(b);\n    println!(\"{:?}\", a); // prints [1, 2, 3, 4]\n}\n\n.extend() adds the contents of another vector.\nThe original vector must be mut.\nThe second vector is moved into the first.\nb can no longer be used.\n\n\n\n\n\nCreate an empty vector\nAppend the values 1.0, 2.0, and 3.0 using .push()\nClear the vector to make it empty\nLastly, extend it with another vector e.g. [4.0, 5.0]\nSort the vector\nPrint the final result.\n\n\n\n\n\nView solution\n\nfn main() {\n    let mut x = Vec::new();\n    x.push(1.0);\n    x.push(2.0);\n    x.push(3.0);\n    x.clear();\n    x.extend(vec![4.0, 5.0]);\n    println!(\"{:?}\", x);\n}",
    "crumbs": [
      "Mutable Vectors"
    ]
  },
  {
    "objectID": "intro-rust/mutable-vectors.html#exercise",
    "href": "intro-rust/mutable-vectors.html#exercise",
    "title": "Mutable Vectors",
    "section": "",
    "text": "Create an empty vector\nAppend the values 1.0, 2.0, and 3.0 using .push()\nClear the vector to make it empty\nLastly, extend it with another vector e.g. [4.0, 5.0]\nSort the vector\nPrint the final result.\n\n\n\n\n\nView solution\n\nfn main() {\n    let mut x = Vec::new();\n    x.push(1.0);\n    x.push(2.0);\n    x.push(3.0);\n    x.clear();\n    x.extend(vec![4.0, 5.0]);\n    println!(\"{:?}\", x);\n}",
    "crumbs": [
      "Mutable Vectors"
    ]
  },
  {
    "objectID": "blog/index.html",
    "href": "blog/index.html",
    "title": "extendr Blog",
    "section": "",
    "text": "h3o is now on CRAN‼️\n\n\n\nRelease\n\n\n\nR users now have access to a pure Rust implementation of Uber’s H3, a hexagonal geospatial grid and indexing system.\n\n\n\n\n\nSep 9, 2025\n\n\nBlake Vernon, Josiah Parry\n\n\n\n\n\n\n\n\n\n\n\n\nrextendr 0.4\n\n\n\nRelease\n\nUpdates\n\n\n\nA new version of rextendr has arrived.\n\n\n\n\n\nAug 26, 2025\n\n\nBlake Vernon\n\n\n\n\n\n\n\n\n\n\n\n\nMigration guide for extendr 0.7.0\n\n\n\nRelease\n\nUpdates\n\n\n\nA new version of extendr has arrived, so we explain how to address major changes.\n\n\n\n\n\nJun 30, 2024\n\n\nJosiah Parry\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "user-guide/r-pkgs/package-structure.html",
    "href": "user-guide/r-pkgs/package-structure.html",
    "title": "Project Structure",
    "section": "",
    "text": "A extendr-powered R package has a fairly unique structure. This section briefly outlines the structure of an extendr package and the important files.\nextendr works by creating a Rust library crate in src/rust that is defined by src/rust/Cargo.toml.\nNote the crate-type = [ 'staticlib' ]. When this library is compiled, it creates a static library which can then be called from R.",
    "crumbs": [
      "R Packages",
      "Project Structure"
    ]
  },
  {
    "objectID": "user-guide/r-pkgs/package-structure.html#controlling-exports-to-r-lib.rs",
    "href": "user-guide/r-pkgs/package-structure.html#controlling-exports-to-r-lib.rs",
    "title": "Project Structure",
    "section": "Controlling exports to R: lib.rs",
    "text": "Controlling exports to R: lib.rs\nThe lib.rs file determines what will be exposed to your R package. The extendr_module! macro in lib.rs controls what will have wrappers provided to your R package.\nextendr_module! {\n    mod hellorust;\n    fn hello_world;\n}\nThe mod hellorust is the name of the R package. Additional functions, impls, and modules can also be added to this macro.",
    "crumbs": [
      "R Packages",
      "Project Structure"
    ]
  },
  {
    "objectID": "user-guide/r-pkgs/package-structure.html#building-the-package-makevars",
    "href": "user-guide/r-pkgs/package-structure.html#building-the-package-makevars",
    "title": "Project Structure",
    "section": "Building the package: Makevars",
    "text": "Building the package: Makevars\nWhen creating an R package that uses compiled code, a file called Makevars is used.\n\n\n\n\n\n\nNote\n\n\n\nSee Using Makevars in Writing R Extensions for a thorough discussion.\n\n\nMakevars is used as a preprocessing step for compiling an R package. The files Makevars and Makevars.win compile the Rust library in src/rust, and link to the library.\n\n\n\n\n\n\nTip\n\n\n\nMakevars is used for *nix operating systems and Makevars.win is used for Windows.",
    "crumbs": [
      "R Packages",
      "Project Structure"
    ]
  },
  {
    "objectID": "user-guide/index.html",
    "href": "user-guide/index.html",
    "title": "User Guide",
    "section": "",
    "text": "This user guide serves two primary functions:\nGiven these goals, the guide is primarily geared towards R users and R developers who also have a decent grasp of Rust.",
    "crumbs": [
      "User Guide"
    ]
  },
  {
    "objectID": "user-guide/index.html#whats-in-this-guide",
    "href": "user-guide/index.html#whats-in-this-guide",
    "title": "User Guide",
    "section": "What’s in this guide?",
    "text": "What’s in this guide?\nWe’re working on that…",
    "crumbs": [
      "User Guide"
    ]
  },
  {
    "objectID": "user-guide/index.html#whats-not-in-this-guide",
    "href": "user-guide/index.html#whats-not-in-this-guide",
    "title": "User Guide",
    "section": "What’s not in this guide?",
    "text": "What’s not in this guide?\nThis book is not intended to be a comprehensive introduction to Rust. While do go over some of the basics, more often than not, concepts are introduced only to help explain extendr tools. That said, we do try to include copious references and links to additional resources that the reader can follow to learn more about specific topics. Of course, the biggest reference will be “The Book”.\nThis book is also not intended to be a comprehensive guide to R package development! There are, quite frankly, better resources for that, notably R Packages (2e). As with Rust specifics, we will strive to point you in the right direction to get more details and advice when you need it.",
    "crumbs": [
      "User Guide"
    ]
  },
  {
    "objectID": "user-guide/serde-integration.html",
    "href": "user-guide/serde-integration.html",
    "title": "serde integration",
    "section": "",
    "text": "One of the most widely used rust crates is the serialization and deserialization crate serde. It enables rust developers to write their custom structs to many different file formats such as json, toml, yaml, csv, and many more as well as read directly from them.\nextendr provides a serde feature that can convert R objects into structs and struct into R objects.\nFirst, modify your Cargo.toml to include the serde feature.\nCargo.toml\n\n#[dependenices]\nextender-api = { version = \"*\", features = [\"serde\"] }\nFor this example we will have a Point struct with two fields, x, and y. In your lib.rs include:\nlib.rs\n\nuse extendr_api::prelude::*;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Point {\n    x: f64,\n    y: f64\n}",
    "crumbs": [
      "`serde` integration"
    ]
  },
  {
    "objectID": "user-guide/serde-integration.html#deserializing-r-objects",
    "href": "user-guide/serde-integration.html#deserializing-r-objects",
    "title": "serde integration",
    "section": "Deserializing R objects",
    "text": "Deserializing R objects\nThis defines a Point struct. However, you may want to be able to use an R object to represent that point. To deserialize R objects into Rust, use extendr_api::deserializer::from_robj. For a basic example we can deserialize an Robj into the Point.\n\nuse extendr_api::deserializer::from_robj;\n\n#[extendr]\nfn point_from_r(x: Robj) {\n    let point = from_robj::&lt;Point&gt;(&x);\n    rprintln!(\"{point:?}\");\n}\n\nTo represent a struct, a named list has to be used. Each name must correspond with the field name of the struct. In this case these are x and y.\n\npoint &lt;- list(x = 3.0, y = 0.14)\npoint_from_r(list(x = 3.0, y = 0.14))\n#&gt; Ok(Point { x: 3.0, y: 0.14 })",
    "crumbs": [
      "`serde` integration"
    ]
  },
  {
    "objectID": "user-guide/serde-integration.html#serializing",
    "href": "user-guide/serde-integration.html#serializing",
    "title": "serde integration",
    "section": "Serializing",
    "text": "Serializing\nTo serialize R objects you must use extendr_api::serializer::to_robj this will take a serde-compatible struct and convert it into a corresponding R object.\n\nuse extendr_api::prelude::*;\nuse extendr_api::serializer::to_robj;\nuse extendr_api::deserializer::from_robj;\n#[extendr]\nfn round_trip(x: Robj) -&gt; Result&lt;Robj&gt; {\n    let point = from_robj::&lt;Point&gt;(&x)?;\n    to_robj(&point)\n}\n\nThis function will parse a list into a point and then return the Point as an R object as well doing a round trip deserialization and serialization process.\n\nround_trip(\n  list(x = 3.0, y = 0.14)\n)\n#&gt; $x\n#&gt; [1] 3\n#&gt; \n#&gt; $y\n#&gt; [1] 0.14\n\n\nVectors of structs\nYou may find your self wanting to deserialize many structs at once from vectors. For example, if you have a data.frame with 2 columns x and y you may want to deserialize this into a Vec&lt;Point&gt;. To your dismay you will find this not actually possible.\nFor example we can create a function replicate_point().\n\n#[extendr]\nfn replicate_point(x: Robj, n: i32) -&gt; Result&lt;Robj&gt; {\n    let point = from_robj::&lt;Point&gt;(&x)?;\n    let points = vec![point; n as usize];\n    to_robj(&points)\n}\n\nThis will create a Vec&lt;Point&gt; with the size of n. If you serialize this to R you will get a list of lists where each sub-list is a named-list with elements x and y. This is expected. And is quite like how you would expect something to be serialized into json or yaml for example.\n\nreplicate_point(list(x = 0.14, y = 10), 3L)\n#&gt; [[1]]\n#&gt; [[1]]$x\n#&gt; [1] 0.14\n#&gt; \n#&gt; [[1]]$y\n#&gt; [1] 10\n#&gt; \n#&gt; \n#&gt; [[2]]\n#&gt; [[2]]$x\n#&gt; [1] 0.14\n#&gt; \n#&gt; [[2]]$y\n#&gt; [1] 10\n#&gt; \n#&gt; \n#&gt; [[3]]\n#&gt; [[3]]$x\n#&gt; [1] 0.14\n#&gt; \n#&gt; [[3]]$y\n#&gt; [1] 10\n\nWhen providing a data.frame, a closer analogue would be a struct with vectors for their fields like a MultiPoint struct\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MultiPoint {\n    x: Vec&lt;f64&gt;,\n    y: Vec&lt;f64&gt;,\n}\n\nand for the sake of demonstration we can create a make_multipoint() function:\n\n#[extendr]\nfn make_multipoint(x: Robj) -&gt; Result&lt;()&gt; {\n    let mpoint = from_robj::&lt;MultiPoint&gt;(&x)?;\n    rprintln!(\"{mpoint:#?}\");\n    Ok(())\n}\n\nThis function can be used to parse a data.frame into a MultiPoint.\n\nmake_multipoint(\n  data.frame(x = 0:2, y = 9:7)\n)\n#&gt; MultiPoint {\n#&gt;     x: [\n#&gt;         0.0,\n#&gt;         1.0,\n#&gt;         2.0,\n#&gt;     ],\n#&gt;     y: [\n#&gt;         9.0,\n#&gt;         8.0,\n#&gt;         7.0,\n#&gt;     ],\n#&gt; }\n#&gt; NULL",
    "crumbs": [
      "`serde` integration"
    ]
  },
  {
    "objectID": "user-guide/serde-integration.html#using-tryfrom",
    "href": "user-guide/serde-integration.html#using-tryfrom",
    "title": "serde integration",
    "section": "Using TryFrom",
    "text": "Using TryFrom\nOne of the benefits and challenges of rust is that it requires us to be explicit. Adding another language into play makes it all the more confusing! In many cases there isn’t a 1:1 mapping from Rust to R as you have seen the Point and MultiPoint. One way to simplify this would be to use a TryFrom trait implementation. This is discussed in more detail in another part of the user guide.\nRather than use serde to do the conversion for you, you probably want a custom TryFrom trait implementation. Here we define an MPoint tuple struct and then implement TryFrom&lt;Robj&gt; for it.\n\npub struct MPoint(Vec&lt;Point&gt;);\n\nimpl TryFrom&lt;Robj&gt; for MPoint {\n    type Error = Error;\n    fn try_from(value: Robj) -&gt; std::result::Result&lt;Self, Self::Error&gt; {\n        let point_df = List::try_from(&value)?;\n        let x_vec = Doubles::try_from(point_df.dollar(\"x\")?)?;\n        let y_vec = Doubles::try_from(point_df.dollar(\"y\")?)?;\n        let inner = x_vec.into_iter().zip(y_vec.into_iter()).map(|(x, y)| {\n                    Point {\n                        x: x.inner(),\n                        y: y.inner()\n                    }\n                }).collect::&lt;Vec&lt;_&gt;&gt;();\n        Ok(MPoint(inner))\n    }\n}\n\nThis gives us the benefit of being able to pass the struct type directly into the function. Here we create a function centroid() to calculate the centroid of the MPoint struct directly. We use to_robj() to convert it back to an Robj.\n\n#[extendr]\nfn centroid(x: MPoint) -&gt; Result&lt;Robj&gt; {\n    let total = x.0.into_iter().fold((0.0, 0.0, 0.0), |mut acc, next| {\n        acc.0 += next.x;\n        acc.1 += next.y;\n        acc.2 += 1.0;\n        acc\n    });\n    let centroid = Point {\n        x: total.0 / total.2,\n        y: total.1 / total.2\n    };\n    to_robj(&centroid)\n}\n\nThis function can be used with a data.frame because we implemented the TryFrom trait.\n\ncentroid(\n  data.frame(x = rnorm(10), y = rnorm(10))\n)\n#&gt; $x\n#&gt; [1] -0.09167968\n#&gt; \n#&gt; $y\n#&gt; [1] -0.1613052",
    "crumbs": [
      "`serde` integration"
    ]
  },
  {
    "objectID": "user-guide/tokio.html",
    "href": "user-guide/tokio.html",
    "title": "Async with Tokio",
    "section": "",
    "text": "Many crates in the Rust ecosystem utilize an asynchronous runtime through the tokio crate. Tokio provides a multithreaded runtime and is used by popular libraries like reqwest, axum, DataFusion, sqlx, and many more.\nextendr doesn’t provide an async function interface because there is not a true async runtime for R let alone any C API infrastructure for it. But that does not mean we cannot harness the vast async ecosystem in Rust.",
    "crumbs": [
      "Async with Tokio"
    ]
  },
  {
    "objectID": "user-guide/tokio.html#add-tokio",
    "href": "user-guide/tokio.html#add-tokio",
    "title": "Async with Tokio",
    "section": "Add tokio",
    "text": "Add tokio\nTo utilize tokio with extendr we will need to bump the msrv of our package to 1.70 as that is the MSRV of tokio and we will be using a langauge feature called OnceLock that wasn’t stabilized until 1.70.\nrextendr::use_msrv(\"1.70\")\nrextendr::use_crate(\"tokio\", features = \"rt-multi-thread\")\nThe use_msrv() function will bump the MSRV specified in your package’s DESCRIPTION file. The use_crate() function will call cargo add on your behalf and add the crate to your Cargo.toml.",
    "crumbs": [
      "Async with Tokio"
    ]
  },
  {
    "objectID": "user-guide/tokio.html#creating-your-runtime",
    "href": "user-guide/tokio.html#creating-your-runtime",
    "title": "Async with Tokio",
    "section": "Creating your runtime",
    "text": "Creating your runtime\nYour R package should share one runtime across all function calls. This approach:\n\nCreates a global static variable using OnceLock&lt;&gt; (thread-safe, write-once)\nUses lazy initialization—runtime is created only when first needed\nReturns a reference to the same runtime on subsequent calls\n\n\n\n\n\n\n\nNoteFutures\n\n\n\nSee Futures and the Async Syntax section of The Book™.\n\n\nIn your lib.rs we define a static called TOKIO_RUNTIME which contains a Runtime.\nThe function get_rt() will create a new Runtime the first time it is called. Each subsequent call returns a reference to that created runtime.\nuse extendr_api::prelude::*;\nuse std::sync::OnceLock;\nuse tokio::runtime::{Builder, Runtime};\n\n// Initialize a shared tokio runtime for the package\nstatic TOKIO_RUNTIME: OnceLock&lt;Runtime&gt; = OnceLock::new();\n\n// Helper function to get a tokio runtime\nfn get_rt() -&gt; &'static Runtime {\n    TOKIO_RUNTIME.get_or_init(|| {\n        Builder::new_multi_thread()\n            .enable_all()\n            .build()\n            .expect(\"Failed to create tokio runtime\")\n    })\n}\nNow, in any function we want to use the tokio run time can first call get_rt() to get a reference to it.",
    "crumbs": [
      "Async with Tokio"
    ]
  },
  {
    "objectID": "user-guide/tokio.html#blocking-on-async-futures",
    "href": "user-guide/tokio.html#blocking-on-async-futures",
    "title": "Async with Tokio",
    "section": "Blocking on async futures",
    "text": "Blocking on async futures\nFor a motivating example we can use the async file reader from tokio using our new runtime.\n#[extendr]\nfn read_file_async(path: &str) -&gt; String {\n    // get the tokio runtime\n    let rt = get_rt();\n\n    // define a future, typically we would `.await`\n    let file_content_fut = tokio::fs::read_to_string(path);\n\n    // use `.block_on()` to await the future\n    rt.block_on(file_content_fut).expect(\"failed to read file\")\n}\nThe first step is to get the tokio runtime. Then we call the async function, which typically we would .await to get the result. Instead, we call .block_on() to execute the future and get the result.",
    "crumbs": [
      "Async with Tokio"
    ]
  },
  {
    "objectID": "user-guide/tokio.html#example-read-many-files-async",
    "href": "user-guide/tokio.html#example-read-many-files-async",
    "title": "Async with Tokio",
    "section": "Example: read many files async",
    "text": "Example: read many files async\nFor a more complete / complex example we can create a function that reads multiple files in parallel and awaits all of the futures asynchronously.\n#[extendr]\nfn read_files_async(paths: Vec&lt;String&gt;) -&gt; Strings {\n    // get the tokio runtime\n    let rt = get_rt();\n\n    // create a joinset to await multiple futures asynchronously\n    let mut set = tokio::task::JoinSet::new();\n\n    // spawn each future in the join set\n    for p in paths {\n        set.spawn(tokio::fs::read_to_string(p));\n    }\n\n    // wait for all futures to resolve\n    let all_file_bodies = rt.block_on(set.join_all());\n\n    // filter out any files that failed to read\n    // return the contents as a character vector\n    all_file_bodies\n        .into_iter()\n        .filter_map(|contents| contents.ok().map(Rstr::from))\n        .collect::&lt;Strings&gt;()\n}",
    "crumbs": [
      "Async with Tokio"
    ]
  },
  {
    "objectID": "user-guide/tokio.html#what-this-unlocks",
    "href": "user-guide/tokio.html#what-this-unlocks",
    "title": "Async with Tokio",
    "section": "What this unlocks",
    "text": "What this unlocks\nWith tokio working in extendr, we now have access to the entire async Rust ecosystem. This means we can build R packages using:\n\nDataFusion - high-performance SQL query engine\nDataFusion Comet - Spark accelerator\nlancedb - vector database for AI applications\nqdrant - vector search engine for next-gen AI\nburn - deep learning framework\nsail - unified batch and stream processing\n\nThe async ecosystem is massive and growing. Now R can be part of it.",
    "crumbs": [
      "Async with Tokio"
    ]
  },
  {
    "objectID": "user-guide/cran-publishing.html",
    "href": "user-guide/cran-publishing.html",
    "title": "Publishing to CRAN",
    "section": "",
    "text": "extendr-based packges are CRAN compatible out of the box! You only have to do one additional step—vendor your Rust dependencies.\nThat’s it!",
    "crumbs": [
      "Publishing to CRAN"
    ]
  },
  {
    "objectID": "user-guide/cran-publishing.html#cran-comments.md",
    "href": "user-guide/cran-publishing.html#cran-comments.md",
    "title": "Publishing to CRAN",
    "section": "cran-comments.md",
    "text": "cran-comments.md\nAs with most things in life, communication is key. We recommend communicating thoroughly in your cran-comments.md.\nIn some cases your R package’s .tar.gz can be quite large due to the vendor.tar.xz file. In your cran-comments.md make a note of the size. For example write:\n\n“Tarball is 4.7mb due to vendored rust depencies.”",
    "crumbs": [
      "Publishing to CRAN"
    ]
  },
  {
    "objectID": "user-guide/cran-publishing.html#msrv",
    "href": "user-guide/cran-publishing.html#msrv",
    "title": "Publishing to CRAN",
    "section": "MSRV",
    "text": "MSRV\nAs of this writing the MSRV of CRAN is 1.81. In order to publish to CRAN, this MSRV must be met.\nSee CRAN’s MSRV for a detailed list of Rust versions for each check flavor.",
    "crumbs": [
      "Publishing to CRAN"
    ]
  },
  {
    "objectID": "user-guide/cran-publishing.html#nightly-features",
    "href": "user-guide/cran-publishing.html#nightly-features",
    "title": "Publishing to CRAN",
    "section": "Nightly features",
    "text": "Nightly features\nCRAN does not support nightly features as of this writing. Any package you plan to publish on CRAN cannot use nightly features.",
    "crumbs": [
      "Publishing to CRAN"
    ]
  },
  {
    "objectID": "user-guide/cran-publishing.html#why-vendor",
    "href": "user-guide/cran-publishing.html#why-vendor",
    "title": "Publishing to CRAN",
    "section": "Why vendor?",
    "text": "Why vendor?\nOne of the reasons we love CRAN is that they take portability seriously. Because of this, an R package must contain everything it needs to build. This means that the Rust dependencies must not be downloaded as the package is installed.\nVendoring is the process of embedding the source code of our dependencies into our R package. vendor_pkgs() creates a vendor.tar.xz file which contains the compressed source of all the dependencies.",
    "crumbs": [
      "Publishing to CRAN"
    ]
  },
  {
    "objectID": "user-guide/type-mapping/scalars.html",
    "href": "user-guide/type-mapping/scalars.html",
    "title": "Scalar Type Mapping",
    "section": "",
    "text": "This tutorial demonstrates some of the basics of passing scalar data types back and forth between Rust and R. We’ll start with simple examples using explicit Rust types but then move on to showing their extendr alternatives. Why does extendr have its own data types? For a number of reasons, of course, but the most important reason is probably that Rust types do not allow for missing values, so no NA, NaN, NULL, or what have you. Fortunately, extendr types will handle missing values for you. For this reason, it is strongly recommended that you work with the extendr types whenever possible.",
    "crumbs": [
      "Type Mapping",
      "Scalar Type Mapping"
    ]
  },
  {
    "objectID": "user-guide/type-mapping/scalars.html#scalar-types",
    "href": "user-guide/type-mapping/scalars.html#scalar-types",
    "title": "Scalar Type Mapping",
    "section": "Scalar types",
    "text": "Scalar types\nA scalar type consists of a single value, and it can only consist of a single value, whether that value is a single character string, integer, or logical. As it happens, R doesn’t have a way of representing a scalar value. That’s because everything is a vector in R, and vectors can have any arbitrary length you want. So, the closest thing to a scalar you will ever encounter in R is a vector that just so happens to have a length of one. In Rust, however, scalars are the building blocks of everything, and they come in a bewildering variety, at least for the traditional R user. Consider, for example, integers. R has just one way to represent this type of numeric value. Rust, on the other hand, has twelve!\nThe table below shows the most common R “scalar” types, along with their Rust and extendr equivalents.\n\n\n\nR type\nextendr type\nRust type\n\n\n\n\ninteger(1)\nRint\ni32\n\n\ndouble(1)\nRfloat\nf64\n\n\nlogical(1)\nRbool\nbool\n\n\ncomplex(1)\nRcplx\nComplex&lt;f64&gt;\n\n\ncharacter(1)\nRstr\nString\n\n\n\nTo learn more about Rust types, see section 3.2 of The Book.",
    "crumbs": [
      "Type Mapping",
      "Scalar Type Mapping"
    ]
  },
  {
    "objectID": "user-guide/type-mapping/scalars.html#sharing-scalars",
    "href": "user-guide/type-mapping/scalars.html#sharing-scalars",
    "title": "Scalar Type Mapping",
    "section": "Sharing scalars",
    "text": "Sharing scalars\nTo see how scalars get passed back and forth between Rust and R, we’ll first explore Rust’s f64 value which is a 64-bit float. This is equivalent to R’s double(1). We’ll write a very simple Rust function that prints the value of the input and does not return anything.\n\n#[extendr]\nfn scalar_double(x: f64) { \n    rprintln!(\"The value of x is {x}\"); \n}\n\nThrough the magic of extendr, we can now call this function in R and pass it a single double value.\n\nscalar_double(4.2)\n#&gt; The value of x is 4.2\n\nThere are several things to note about this example. First, in Rust, x: f64 tells us that the type of x being passed to the function (fn) is a single double vector or “float” value. Second, rprintln!(\"{}\", x); is an extendr macro that makes it easier to print information from Rust to the console in R. R users will perhaps notice that the syntax is vaguely {glue}-like in that the value of x is inserted into the curly brackets. Finally, if you are not working inside of an extendr R package, you can create the scalar_double() function locally using rextendr::rust_function().\nrextendr::rust_function(\"\nfn scalar_double(x: f64) { \n    rprintln!(\"The value of x is {x}\"); \n}\n\")\nNow, what if, rather than printing the value of x to the R console, we wanted instead to return that value to R? To do that, we just need to let Rust know what type is being returned by our function. This is done with the -&gt; type notation. The extendr crate understands this notation and knows how to handle the scalar f64 type returned by the Rust function and pass it to R as double.\n\n#[extendr]\nfn return_scalar_double(x: f64) -&gt; f64 { \n    x \n}\n\n\nx &lt;- return_scalar_double(4.2)\n\ntypeof(x)\n#&gt; [1] \"double\"\n\nx + 1.0\n#&gt; [1] 5.2",
    "crumbs": [
      "Type Mapping",
      "Scalar Type Mapping"
    ]
  },
  {
    "objectID": "user-guide/type-mapping/scalars.html#missing-values",
    "href": "user-guide/type-mapping/scalars.html#missing-values",
    "title": "Scalar Type Mapping",
    "section": "Missing values",
    "text": "Missing values\nAs noted above, Rust does not allow a scalar type to have a missing value, so you cannot simply pass a missing value like NA to Rust and expect it to just work. Here is a demonstration of this issue using a simple function which adds 1.0 to x.\n\n#[extendr]\nfn plus_one(x: f64) -&gt; f64 { \n    x + 1.0 \n}\n\nYou will notice that this function expects x to be f64, not a missing value. Passing a missing value from R to this Rust function will, therefore, result in an error.\n\nplus_one(NA_real_)\n#&gt; Error in plus_one(NA_real_): Must not be NA.\n\nFortunately, the extendr types are NA-aware, so you can, for instance, use extendr’s Rfloat in place of f64 to handle missing values without error. Below, you will see that we have done this for the function plus_one().\n\n#[extendr]\nfn plus_one(x: Rfloat) -&gt; Rfloat { \n    x + 1.0 \n}\n\n\nplus_one(NA_real_)\n#&gt; [1] NA\n\nplus_one(4.2)\n#&gt; [1] 5.2",
    "crumbs": [
      "Type Mapping",
      "Scalar Type Mapping"
    ]
  },
  {
    "objectID": "user-guide/type-mapping/scalars.html#additional-examples",
    "href": "user-guide/type-mapping/scalars.html#additional-examples",
    "title": "Scalar Type Mapping",
    "section": "Additional examples",
    "text": "Additional examples\nHere are some additional examples showing how to pass scalars to Rust and return them to R using Rust scalar types.\n\n#[extendr]\nfn scalar_integer(x: i32) -&gt; i32 { x }\n\n#[extendr]\nfn scalar_logical(x: bool) -&gt; bool { x }\n\n\nscalar_integer(4L)\n#&gt; [1] 4\n\nscalar_logical(TRUE)\n#&gt; [1] TRUE\n\nAnd here are the same examples with extendr scalar types.\n\n#[extendr]\nfn scalar_integer(x: Rint) -&gt; Rint { x }\n\n#[extendr]\nfn scalar_logical(x: Rbool) -&gt; Rbool { x }\n\n\nscalar_integer(4L)\n#&gt; [1] 4\n\nscalar_logical(TRUE)\n#&gt; [1] TRUE\n\nDid you notice that we didn’t give an example with character strings? Yeah, well, there’s a good reason for that. You can find out what that is by heading over to the tutorial on Character Strings.",
    "crumbs": [
      "Type Mapping",
      "Scalar Type Mapping"
    ]
  },
  {
    "objectID": "user-guide/type-mapping/vectors.html",
    "href": "user-guide/type-mapping/vectors.html",
    "title": "Vector Type Mapping",
    "section": "",
    "text": "What happens if we try to pass more than one value to scalar_double()?\n\nscalar_double(c(4.2, 1.3, 2.5))\n#&gt; Error in scalar_double(c(4.2, 1.3, 2.5)): Expected Scalar, got Doubles\n\nIt errors because the function expects a scalar of the f64 type, not a vector of f64.\nIn this section, we show you how to pass Rust vectors between R and Rust.\n\n\n\n\n\n\nImportant\n\n\n\nWhile using a Rust vector is possible in some cases, it is strongly not recommended. Instead, extendr types should be used as they provide access directly to R objectes. Whereas using Rust vectors requires additional allocations.\n\n\nThe syntax is basically the same as with scalars, with just some minor changes. We’ll use doubles again to demonstrate this.\nFor reference, below are the type of Rust vectors that can be utilized with extendr.\n\n\n\nR type\nextendr type\nRust type\n\n\n\n\ninteger()\nIntegers\nVec&lt;i32&gt;\n\n\ndouble()\nDoubles\nVec&lt;f64&gt;\n\n\ncomplex()\nComplexes\nVec&lt;Complex&lt;f64&gt;&gt;\n\n\ncharacter()\nStrings\nVec&lt;String&gt;\n\n\nraw()\nRaw\n&[u8]\n\n\nlogical()\nLogicals\n\n\n\nlist()\nList\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nYou might have anticipated Vec&lt;bool&gt; to be a supported Rust vector type. This is not possible because in R, logical vectors do not contain only true and false like Rust’s bool type. They also can be an NA value which has no corresponding representation in Rust.\n\n\nBelow defines Rust function which takes in a vector of f64 values and prints them out.\n\n#[extendr]\nfn vector_double(x: Vec&lt;f64&gt;) {\n    rprintln!(\"The values of x are {x:?}\");\n}\n\nThat function can be called from R which prints the Debug format of the vector.\n\n\n\n\n\n\nTip\n\n\n\nRust’s vector do not implement the Display trait so the debug format (:?) is used.\n\n\n\nvector_double(c(4.2, 1.3, 2.5))\n#&gt; The values of x are [4.2, 1.3, 2.5]\n\nReturning values using Rust follows the same rules as R. You do not need to explicitly return a value as long as the last item in an expression is not followed by a ;.\n\n#[extendr]\nfn vector_double(x: Vec&lt;f64&gt;) -&gt; Vec&lt;f64&gt; { \n    x \n}\n\nCalling the function returns the input as a double vector\n\nx &lt;- vector_double(c(4.2, 1.3, 2.5))\ntypeof(x)\n#&gt; [1] \"double\"\nx + 1\n#&gt; [1] 5.2 2.3 3.5\n\n\n\nThese same principles can be extended to other supported vector types such as Vec&lt;i32&gt; and Vec&lt;String&gt;.\n\n#[extendr]\nfn vector_integer(x: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; { \n    x\n}\n\n#[extendr]\nfn vector_character(x: Vec&lt;String&gt;) -&gt; Vec&lt;String&gt; {\n    x \n}\n\n\nvector_integer(c(4L, 6L, 8L))\n#&gt; [1] 4 6 8\n\nvector_character(c(\"Hello world!\", \"Hello extendr!\", \"Hello R!\"))\n#&gt; [1] \"Hello world!\"   \"Hello extendr!\" \"Hello R!\"",
    "crumbs": [
      "Type Mapping",
      "Vector Type Mapping"
    ]
  },
  {
    "objectID": "user-guide/type-mapping/vectors.html#vector-type-mapping-with-rust-types",
    "href": "user-guide/type-mapping/vectors.html#vector-type-mapping-with-rust-types",
    "title": "Vector Type Mapping",
    "section": "",
    "text": "What happens if we try to pass more than one value to scalar_double()?\n\nscalar_double(c(4.2, 1.3, 2.5))\n#&gt; Error in scalar_double(c(4.2, 1.3, 2.5)): Expected Scalar, got Doubles\n\nIt errors because the function expects a scalar of the f64 type, not a vector of f64.\nIn this section, we show you how to pass Rust vectors between R and Rust.\n\n\n\n\n\n\nImportant\n\n\n\nWhile using a Rust vector is possible in some cases, it is strongly not recommended. Instead, extendr types should be used as they provide access directly to R objectes. Whereas using Rust vectors requires additional allocations.\n\n\nThe syntax is basically the same as with scalars, with just some minor changes. We’ll use doubles again to demonstrate this.\nFor reference, below are the type of Rust vectors that can be utilized with extendr.\n\n\n\nR type\nextendr type\nRust type\n\n\n\n\ninteger()\nIntegers\nVec&lt;i32&gt;\n\n\ndouble()\nDoubles\nVec&lt;f64&gt;\n\n\ncomplex()\nComplexes\nVec&lt;Complex&lt;f64&gt;&gt;\n\n\ncharacter()\nStrings\nVec&lt;String&gt;\n\n\nraw()\nRaw\n&[u8]\n\n\nlogical()\nLogicals\n\n\n\nlist()\nList\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nYou might have anticipated Vec&lt;bool&gt; to be a supported Rust vector type. This is not possible because in R, logical vectors do not contain only true and false like Rust’s bool type. They also can be an NA value which has no corresponding representation in Rust.\n\n\nBelow defines Rust function which takes in a vector of f64 values and prints them out.\n\n#[extendr]\nfn vector_double(x: Vec&lt;f64&gt;) {\n    rprintln!(\"The values of x are {x:?}\");\n}\n\nThat function can be called from R which prints the Debug format of the vector.\n\n\n\n\n\n\nTip\n\n\n\nRust’s vector do not implement the Display trait so the debug format (:?) is used.\n\n\n\nvector_double(c(4.2, 1.3, 2.5))\n#&gt; The values of x are [4.2, 1.3, 2.5]\n\nReturning values using Rust follows the same rules as R. You do not need to explicitly return a value as long as the last item in an expression is not followed by a ;.\n\n#[extendr]\nfn vector_double(x: Vec&lt;f64&gt;) -&gt; Vec&lt;f64&gt; { \n    x \n}\n\nCalling the function returns the input as a double vector\n\nx &lt;- vector_double(c(4.2, 1.3, 2.5))\ntypeof(x)\n#&gt; [1] \"double\"\nx + 1\n#&gt; [1] 5.2 2.3 3.5\n\n\n\nThese same principles can be extended to other supported vector types such as Vec&lt;i32&gt; and Vec&lt;String&gt;.\n\n#[extendr]\nfn vector_integer(x: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; { \n    x\n}\n\n#[extendr]\nfn vector_character(x: Vec&lt;String&gt;) -&gt; Vec&lt;String&gt; {\n    x \n}\n\n\nvector_integer(c(4L, 6L, 8L))\n#&gt; [1] 4 6 8\n\nvector_character(c(\"Hello world!\", \"Hello extendr!\", \"Hello R!\"))\n#&gt; [1] \"Hello world!\"   \"Hello extendr!\" \"Hello R!\"",
    "crumbs": [
      "Type Mapping",
      "Vector Type Mapping"
    ]
  },
  {
    "objectID": "changelog.html",
    "href": "changelog.html",
    "title": "Changelog",
    "section": "",
    "text": "Arguments can be (mutable) typed slices such as &[Rbool], &mut [Rint] etc. [#790]\nNew optional faer feature which enables conversion between faer matrix and RMatrix&lt;f64&gt; [#706]\nAdds TryFrom&lt;Robj&gt; and &lt;TryFrom&lt;&Robj&gt; for impl blocks marked with #[extendr] macro allowing falliable conversion to &Self &mut Self [#730]\nAdds From&lt;T&gt; for Robj for impl blocks marked with #[extendr] macro\nThe new ExpectedExternalNonNullPtr error variant provides a more informative error when a null pointer is accessed\nRArray::data_mut provides a mutable slice to the underlying array data [#657]\nImplements the Attributes trait for all R vector wrapper structs (e.g. Integers , Doubles, Strings, etc.), allowing for easy access and setting of the attributes of an R object [#745]. This comes with breaking changes. See below.\nfeature non-api that gives access to non-API items; Requires compile-time generation of bindings [#754]\nTryFrom&lt;&Robj&gt; for StrIter, HashMap&lt;K, Robj&gt; for K = String and K = &str [#759]\n\n\n\n\n\n[Potentially breaking]: RArray::from_parts no longer requires a pointer to the underlying data vector [#657]\n#[extendr(use_try_from = true) is now the default setting, therefore the option use_try_from has been removed [#759]\n\n\n\n\nR-devel Non-API changes:\n\nR’s C API is being formalized. While the changes are formalized, non-API functions are hidden behind a feature flag to prevent removal from CRAN.\nNon-API changes are in flux in R-devel, however, CRAN has set a July 9th date to remove any package that uses non-API functions. This includes almost every extendr based package on CRAN.\nSee [Rd] clarifying and adjusting the C API for R\nnonAPI.txt functions are hidden behind the non-api feature flag.\nRemoved from default include (but may not be limited to):\n\nglobal_var(), local_var(), base_env(), various Environment, Function, Primitive, and Promise methods.\n\n\nAttributes trait now returns a mutable reference to Self. [#745]. Previously .set_attrib() would modify an object in place, and then return an untyped owned pointer (Robj). Instead, now we return &mut Self.\nIn AltRep the unserialize_ex, set_parent, set_envflags are now hidden behind the feature flag non-api. Also, Promise::from_parts is marked as non-API.\nFloating point numbers with decimal part can no longer be converted to integer types via rounding [#757]\nYou can no longer create an Robj from a reference &T, where T is an extendr-impl. [#759]\nYou can no longer use from_robj, as the trait FromRobj as been removed. Instead, use try_from.\nIt is no longer possible to access an R integer vector as a &[u32] [#767]\nIt is no longer possible to generate bindings as part of the compilation of extendr. Feature non-api is broken and will not compile. Related https://github.com/extendr/libR-sys/issues/251\n\n\n\n\n\n\nreturning &Self or &mut Self from a method in an #[extendr]-impl would result in unintended cloning [#614]\nTryFrom&lt;&Robj&gt; and FromRobj for integer scalars now correctly handles conversions from f64 [#757]\n\n\n\n\n\n\n\n\nALTLIST support allowing users to represent structs as R list objects [#600]\n[either] TryFrom&lt;&Robj&gt; for Either&lt;T, R&gt; and From&lt;Either&lt;T, R&gt;&gt; for Robj if T and R are themselves implement these traits. This unblocks scenarios like accepting any numeric vector from R via Either&lt;Integers, Doubles&gt; without extra memory allocation [#480]\nPartialOrd trait implementation for Rfloat, Rint and Rbool. Rfloat and Rint gained min() and max() methods [#573]\nuse_rng option for the extendr attribute macro, which enables the use of random number sampling methods from R, e.g. #[extendr(use_rng = true) [#476]\n[T; N] conversions to Robj [#594]\nToVectorValue for Rfloat, Rint and Rbool [#593]\nTryFrom&lt;_&gt; on Vec&lt;_&gt; for Integers (i32), Complexes (c64), Doubles (f64), and Logicals (bool / i32). [#593]\nRstr can now be constructed from Option&lt;String&gt; [#630]\n\n\n\n\n\nYou can now create ArrayView1 from &Robj as well as Robj [#501]\nRaw literals from Rust can be used for function and argument names. e.g. fn r#type() in Rust is converted to type() in R. [#531]\nFix memory leaks on errors and panics [#555]\nFixed error when collecting too many objects into List, etc. [#540]\n\n\n\n\n\n\n\n\nSupport for setting the default value of arguments to struct methods, using #[default = \"...\"] [#436]\n[ndarray] TryFrom&lt;&Robj&gt; for ArrayView1&lt;T&gt; and ArrayView2&lt;T&gt;, where T is i32, f64, c64, Rint, Rfloat, Rcplx, Rstr, Rbool [#443]\nDebug trait implementation for Rcplx and Complexes [#444]\nTryFrom&lt;Robj&gt;, From&lt;Option&lt;T&gt;&gt;, Into&lt;Option&lt;T&gt;&gt; and their variations for Nullable&lt;T&gt; [#446]\nNullable&lt;T&gt;::map() that acts on not null value and propagates NULL [#446]\n[ndarray] Conversion from owned arrays (ie ndarray::Array) into Robj [#450]\n[ndarray][docs] Documentation for the robj_ndarray module [#450]\nSum for scalars like Rint, Rfloat and Rcplx, which accept Iterator&lt;Item = &Rtype&gt; [#454]\nA new collect_rarray method that can be used to collect arbitrary iterables into an R matrix [#466]\n[docs] Documentation for RArray::new_matrix() [#466]\n\n\n\n\n\n[docs] Use bindgen on docs.rs, to ensure newer R features will still be documented [#426]\nUnify the tagging mechanism used to identify Rust types inside ExternalPtr. This allows #[extendr]-annotated functions to directly accept ExternalPtr&lt;MyStruct&gt; as well as MyStruct [#433]\nNullable&lt;T&gt; is now part of extendr_api::prelude [#446]\nBump the Rust edition from 2018 to 2021 [#458]\nWhen converted to STRSXP, strings are now correctly marked as UTF-8 even on non-UTF-8 platforms (i.e., R &lt; 4.2 on Windows), which shouldn’t matter for most of the users [#467]\n\n\n\n\n\nThe R CMD check note “Found non-API calls to R” by moving use extendr_engine; inside test! macro [#424]\nThe clippy lint “this public function might dereference a raw pointer but is not marked unsafe” [#451]\nA bug where importing a submodule via use some_module; inside the extendr_module! macro wasn’t working [#469]\n\n\n\n\n\n\n\n\nFunction type that wraps an R function, which can be invoked using the call() method. [#188]\npairlist! macro for generating Pairlist objects, e.g. for use in function calls. [#202]\nuse_try_from option for the extendr macro, which allows the use of any type that implements TryInto&lt;Robj&gt;/TryFrom&lt;Robj&gt;, e.g. #[extendr(use_try_from = true)]. [#222]\nSupport for R version 4.2. [#235]\ncall! macro, which can be used to call an R function whose name is provided as a string. [#238]\nLarge Rust integer types (u32, u64 and i64) can now be converted to R’s numeric type, which can handle large integer values. [#242]\nTryFrom&lt;Robj&gt; for a large number of Rust types. [#249], [#258]\nSupport for ALTREP. [#250], [#274]\nS4 struct, which wraps an S4 class in R. [#268]\n[ndarray] Implemented TryFrom&lt;&ArrayBase&gt; for Robj, allowing extendr-annotated functions to return Arrays from the ndarray crate and have them automatically converted to R arrays. [#275]\nRint, Rdouble, Rbool and Rcplx: NA-aware wrappers for scalar elements of R vectors [#274], [#284], [#301], [#338], [#350]\nIntegers, Doubles, Strings, Logicals and Complexes: wrappers for R vectors that deref to slices of the above types (RInt etc). [#274], [#284], [#301], [#338], [#350]\nExternalPtr, a wrapper class for creating R objects containing any Rust object. [#260]\n[graphics] Support for R graphics and graphics devices. The graphics feature flag is disabled by default. [#279], [#360], [#373], [#379], [#380], [#389]\nDeref implementation for vector types (Rint/Rfloat/Rbool/Rstr/Robj) to appropriately typed Rust slices. [#327]\ndefault option for extendr-annotated functions, allowing them to have default values, e.g. fn fred(#[default=\"NULL\"] x: Option&lt;i32&gt;) { }. [#334]\nr_name option for extendr-annotated functions, allowing the generated R function to have a different name. e.g.\n#[extendr(\n    use_try_from = true,\n    r_name = \"test.rename.rlike\",\n    mod_name = \"test_rename_mymod\"\n)]\nfn test_rename() { }\n[#335]\nserde::Serialize implementation for R types. [#305], [#355]\nRany type and the as_any conversion method. [#320]\nstd::fmt::Debug implementation for wrapper types. [#345]\n#[derive(TryFromRobj) and #[derive(IntoRobj)] which provide an automatic conversion from and to any custom Rust struct and Robj [#347]\n[[ operator that works with Rust classes. Its behavior is identical to that of the $ operator. [#359]\nLoad and Save, traits that, once implemented, provide the ability to load and save R data in the RDS format. These traits are implemented for all Robj. [#363]\nDataframe wrapper struct. [#393]\nIntoDataFrame trait, which can be derived to allow arbitrary Rust structs to be converted to rows of a data frame. [#393]\n\n\n\n\n\nStrings::elt now returns an Rstr. [#345]\nRenamed RType to Rtype. [#345]\nWrapper types now contain Robj fields. [#190]\nThe R! macro now accepts strings that contain R code. This is now the recommended way of using the macro, especially with raw strings e.g.\nR!(r#\"\n    print(\"hello\")\n\"#);\n[#203]\nImproved error handling for &lt;&str&gt;::try_from(Robj). [#226]\nSymPair::sym_pair() now returns (Option&lt;Robj&gt;, Robj). [#225]\nMore detailed error messages when converting Rust integer types to R. [#243]\nCharacter is now called Rstr. [#273]\n[ndarray] Bumped ndarray to 0.15.3. Under RFC 1977 this is a “public dependency” change, and therefore can be considered a breaking change, as consumers of extendr that use an older version of ndarray will no longer be compatible until they also bump ndarray to a compatible version. [#275]\nIsNA trait has been renamed to CanBeNA. [#288]\nlist! has been rewritten, and now returns a List struct. [#303]\n\n\n\n\n\nCalling the R! macro with non-string types (e.g. R!(1)) is now deprecated. [#203]\n\n\n\n\n\nReal, Int, Bool and the redundant trait SliceIter, which should be replaced with Rdouble, Rint, and Rbool respectively. [#304], [#338]\nTryFrom conversions between Robj and HashMap for consistency. List::into_hashmap() and List::from_hashmap() should be used instead. [#254]\n\n\n\n\n\n\nAdded contributing guidelines and code of conduct.\nMade use of ndarray optional.\nMade #[extendr] calls panic and thread safe.\nAdded NA handling to the #[extendr] macro.\nAdded a separate extendr-engine crate that is needed when calling R from Rust.\nWrapper classes for pairlists, environment, raw, symbols and others.\nMore iterator support.\nOperators index, slice, dollar, double_colon, +, -, * and /`.\nDebug printing support expanded to use wrappers.\nConversion of Robj to wrapper types.\nMultithreaded support - allows multithreaded testing using a recursive spinlock.\nBool type extended and implemented using TRUE, FALSE and NA_BOOLEAN.\nOptional parameters to support NA handing.\nErrors thrown if input parameters without Option are NA.\nHarmonising of function names into integer, real, logical, symbol, raw, list, pairlist and env.\nRefactored robj code into several source files.\nMany functions updated to use generic types.\nR! macro for executing R source code.\ncall! macro to call R code.\nsym! macro to generate symbols.\nSimplification of vector generation using collect_robj and ToVectorValue.\nAdded array types [1, 2, 3] as Robj::from targets.\nMacros now mostly return errors.\n\n\n\n\n\nFix build on Windows and MacOS."
  },
  {
    "objectID": "changelog.html#section",
    "href": "changelog.html#section",
    "title": "Changelog",
    "section": "",
    "text": "Arguments can be (mutable) typed slices such as &[Rbool], &mut [Rint] etc. [#790]\nNew optional faer feature which enables conversion between faer matrix and RMatrix&lt;f64&gt; [#706]\nAdds TryFrom&lt;Robj&gt; and &lt;TryFrom&lt;&Robj&gt; for impl blocks marked with #[extendr] macro allowing falliable conversion to &Self &mut Self [#730]\nAdds From&lt;T&gt; for Robj for impl blocks marked with #[extendr] macro\nThe new ExpectedExternalNonNullPtr error variant provides a more informative error when a null pointer is accessed\nRArray::data_mut provides a mutable slice to the underlying array data [#657]\nImplements the Attributes trait for all R vector wrapper structs (e.g. Integers , Doubles, Strings, etc.), allowing for easy access and setting of the attributes of an R object [#745]. This comes with breaking changes. See below.\nfeature non-api that gives access to non-API items; Requires compile-time generation of bindings [#754]\nTryFrom&lt;&Robj&gt; for StrIter, HashMap&lt;K, Robj&gt; for K = String and K = &str [#759]\n\n\n\n\n\n[Potentially breaking]: RArray::from_parts no longer requires a pointer to the underlying data vector [#657]\n#[extendr(use_try_from = true) is now the default setting, therefore the option use_try_from has been removed [#759]\n\n\n\n\nR-devel Non-API changes:\n\nR’s C API is being formalized. While the changes are formalized, non-API functions are hidden behind a feature flag to prevent removal from CRAN.\nNon-API changes are in flux in R-devel, however, CRAN has set a July 9th date to remove any package that uses non-API functions. This includes almost every extendr based package on CRAN.\nSee [Rd] clarifying and adjusting the C API for R\nnonAPI.txt functions are hidden behind the non-api feature flag.\nRemoved from default include (but may not be limited to):\n\nglobal_var(), local_var(), base_env(), various Environment, Function, Primitive, and Promise methods.\n\n\nAttributes trait now returns a mutable reference to Self. [#745]. Previously .set_attrib() would modify an object in place, and then return an untyped owned pointer (Robj). Instead, now we return &mut Self.\nIn AltRep the unserialize_ex, set_parent, set_envflags are now hidden behind the feature flag non-api. Also, Promise::from_parts is marked as non-API.\nFloating point numbers with decimal part can no longer be converted to integer types via rounding [#757]\nYou can no longer create an Robj from a reference &T, where T is an extendr-impl. [#759]\nYou can no longer use from_robj, as the trait FromRobj as been removed. Instead, use try_from.\nIt is no longer possible to access an R integer vector as a &[u32] [#767]\nIt is no longer possible to generate bindings as part of the compilation of extendr. Feature non-api is broken and will not compile. Related https://github.com/extendr/libR-sys/issues/251\n\n\n\n\n\n\nreturning &Self or &mut Self from a method in an #[extendr]-impl would result in unintended cloning [#614]\nTryFrom&lt;&Robj&gt; and FromRobj for integer scalars now correctly handles conversions from f64 [#757]"
  },
  {
    "objectID": "changelog.html#section-1",
    "href": "changelog.html#section-1",
    "title": "Changelog",
    "section": "",
    "text": "ALTLIST support allowing users to represent structs as R list objects [#600]\n[either] TryFrom&lt;&Robj&gt; for Either&lt;T, R&gt; and From&lt;Either&lt;T, R&gt;&gt; for Robj if T and R are themselves implement these traits. This unblocks scenarios like accepting any numeric vector from R via Either&lt;Integers, Doubles&gt; without extra memory allocation [#480]\nPartialOrd trait implementation for Rfloat, Rint and Rbool. Rfloat and Rint gained min() and max() methods [#573]\nuse_rng option for the extendr attribute macro, which enables the use of random number sampling methods from R, e.g. #[extendr(use_rng = true) [#476]\n[T; N] conversions to Robj [#594]\nToVectorValue for Rfloat, Rint and Rbool [#593]\nTryFrom&lt;_&gt; on Vec&lt;_&gt; for Integers (i32), Complexes (c64), Doubles (f64), and Logicals (bool / i32). [#593]\nRstr can now be constructed from Option&lt;String&gt; [#630]\n\n\n\n\n\nYou can now create ArrayView1 from &Robj as well as Robj [#501]\nRaw literals from Rust can be used for function and argument names. e.g. fn r#type() in Rust is converted to type() in R. [#531]\nFix memory leaks on errors and panics [#555]\nFixed error when collecting too many objects into List, etc. [#540]"
  },
  {
    "objectID": "changelog.html#section-2",
    "href": "changelog.html#section-2",
    "title": "Changelog",
    "section": "",
    "text": "Support for setting the default value of arguments to struct methods, using #[default = \"...\"] [#436]\n[ndarray] TryFrom&lt;&Robj&gt; for ArrayView1&lt;T&gt; and ArrayView2&lt;T&gt;, where T is i32, f64, c64, Rint, Rfloat, Rcplx, Rstr, Rbool [#443]\nDebug trait implementation for Rcplx and Complexes [#444]\nTryFrom&lt;Robj&gt;, From&lt;Option&lt;T&gt;&gt;, Into&lt;Option&lt;T&gt;&gt; and their variations for Nullable&lt;T&gt; [#446]\nNullable&lt;T&gt;::map() that acts on not null value and propagates NULL [#446]\n[ndarray] Conversion from owned arrays (ie ndarray::Array) into Robj [#450]\n[ndarray][docs] Documentation for the robj_ndarray module [#450]\nSum for scalars like Rint, Rfloat and Rcplx, which accept Iterator&lt;Item = &Rtype&gt; [#454]\nA new collect_rarray method that can be used to collect arbitrary iterables into an R matrix [#466]\n[docs] Documentation for RArray::new_matrix() [#466]\n\n\n\n\n\n[docs] Use bindgen on docs.rs, to ensure newer R features will still be documented [#426]\nUnify the tagging mechanism used to identify Rust types inside ExternalPtr. This allows #[extendr]-annotated functions to directly accept ExternalPtr&lt;MyStruct&gt; as well as MyStruct [#433]\nNullable&lt;T&gt; is now part of extendr_api::prelude [#446]\nBump the Rust edition from 2018 to 2021 [#458]\nWhen converted to STRSXP, strings are now correctly marked as UTF-8 even on non-UTF-8 platforms (i.e., R &lt; 4.2 on Windows), which shouldn’t matter for most of the users [#467]\n\n\n\n\n\nThe R CMD check note “Found non-API calls to R” by moving use extendr_engine; inside test! macro [#424]\nThe clippy lint “this public function might dereference a raw pointer but is not marked unsafe” [#451]\nA bug where importing a submodule via use some_module; inside the extendr_module! macro wasn’t working [#469]"
  },
  {
    "objectID": "changelog.html#section-3",
    "href": "changelog.html#section-3",
    "title": "Changelog",
    "section": "",
    "text": "Function type that wraps an R function, which can be invoked using the call() method. [#188]\npairlist! macro for generating Pairlist objects, e.g. for use in function calls. [#202]\nuse_try_from option for the extendr macro, which allows the use of any type that implements TryInto&lt;Robj&gt;/TryFrom&lt;Robj&gt;, e.g. #[extendr(use_try_from = true)]. [#222]\nSupport for R version 4.2. [#235]\ncall! macro, which can be used to call an R function whose name is provided as a string. [#238]\nLarge Rust integer types (u32, u64 and i64) can now be converted to R’s numeric type, which can handle large integer values. [#242]\nTryFrom&lt;Robj&gt; for a large number of Rust types. [#249], [#258]\nSupport for ALTREP. [#250], [#274]\nS4 struct, which wraps an S4 class in R. [#268]\n[ndarray] Implemented TryFrom&lt;&ArrayBase&gt; for Robj, allowing extendr-annotated functions to return Arrays from the ndarray crate and have them automatically converted to R arrays. [#275]\nRint, Rdouble, Rbool and Rcplx: NA-aware wrappers for scalar elements of R vectors [#274], [#284], [#301], [#338], [#350]\nIntegers, Doubles, Strings, Logicals and Complexes: wrappers for R vectors that deref to slices of the above types (RInt etc). [#274], [#284], [#301], [#338], [#350]\nExternalPtr, a wrapper class for creating R objects containing any Rust object. [#260]\n[graphics] Support for R graphics and graphics devices. The graphics feature flag is disabled by default. [#279], [#360], [#373], [#379], [#380], [#389]\nDeref implementation for vector types (Rint/Rfloat/Rbool/Rstr/Robj) to appropriately typed Rust slices. [#327]\ndefault option for extendr-annotated functions, allowing them to have default values, e.g. fn fred(#[default=\"NULL\"] x: Option&lt;i32&gt;) { }. [#334]\nr_name option for extendr-annotated functions, allowing the generated R function to have a different name. e.g.\n#[extendr(\n    use_try_from = true,\n    r_name = \"test.rename.rlike\",\n    mod_name = \"test_rename_mymod\"\n)]\nfn test_rename() { }\n[#335]\nserde::Serialize implementation for R types. [#305], [#355]\nRany type and the as_any conversion method. [#320]\nstd::fmt::Debug implementation for wrapper types. [#345]\n#[derive(TryFromRobj) and #[derive(IntoRobj)] which provide an automatic conversion from and to any custom Rust struct and Robj [#347]\n[[ operator that works with Rust classes. Its behavior is identical to that of the $ operator. [#359]\nLoad and Save, traits that, once implemented, provide the ability to load and save R data in the RDS format. These traits are implemented for all Robj. [#363]\nDataframe wrapper struct. [#393]\nIntoDataFrame trait, which can be derived to allow arbitrary Rust structs to be converted to rows of a data frame. [#393]\n\n\n\n\n\nStrings::elt now returns an Rstr. [#345]\nRenamed RType to Rtype. [#345]\nWrapper types now contain Robj fields. [#190]\nThe R! macro now accepts strings that contain R code. This is now the recommended way of using the macro, especially with raw strings e.g.\nR!(r#\"\n    print(\"hello\")\n\"#);\n[#203]\nImproved error handling for &lt;&str&gt;::try_from(Robj). [#226]\nSymPair::sym_pair() now returns (Option&lt;Robj&gt;, Robj). [#225]\nMore detailed error messages when converting Rust integer types to R. [#243]\nCharacter is now called Rstr. [#273]\n[ndarray] Bumped ndarray to 0.15.3. Under RFC 1977 this is a “public dependency” change, and therefore can be considered a breaking change, as consumers of extendr that use an older version of ndarray will no longer be compatible until they also bump ndarray to a compatible version. [#275]\nIsNA trait has been renamed to CanBeNA. [#288]\nlist! has been rewritten, and now returns a List struct. [#303]\n\n\n\n\n\nCalling the R! macro with non-string types (e.g. R!(1)) is now deprecated. [#203]\n\n\n\n\n\nReal, Int, Bool and the redundant trait SliceIter, which should be replaced with Rdouble, Rint, and Rbool respectively. [#304], [#338]\nTryFrom conversions between Robj and HashMap for consistency. List::into_hashmap() and List::from_hashmap() should be used instead. [#254]"
  },
  {
    "objectID": "changelog.html#extendr-0.2.0",
    "href": "changelog.html#extendr-0.2.0",
    "title": "Changelog",
    "section": "",
    "text": "Added contributing guidelines and code of conduct.\nMade use of ndarray optional.\nMade #[extendr] calls panic and thread safe.\nAdded NA handling to the #[extendr] macro.\nAdded a separate extendr-engine crate that is needed when calling R from Rust.\nWrapper classes for pairlists, environment, raw, symbols and others.\nMore iterator support.\nOperators index, slice, dollar, double_colon, +, -, * and /`.\nDebug printing support expanded to use wrappers.\nConversion of Robj to wrapper types.\nMultithreaded support - allows multithreaded testing using a recursive spinlock.\nBool type extended and implemented using TRUE, FALSE and NA_BOOLEAN.\nOptional parameters to support NA handing.\nErrors thrown if input parameters without Option are NA.\nHarmonising of function names into integer, real, logical, symbol, raw, list, pairlist and env.\nRefactored robj code into several source files.\nMany functions updated to use generic types.\nR! macro for executing R source code.\ncall! macro to call R code.\nsym! macro to generate symbols.\nSimplification of vector generation using collect_robj and ToVectorValue.\nAdded array types [1, 2, 3] as Robj::from targets.\nMacros now mostly return errors."
  },
  {
    "objectID": "changelog.html#extendr-0.1.10",
    "href": "changelog.html#extendr-0.1.10",
    "title": "Changelog",
    "section": "",
    "text": "Fix build on Windows and MacOS."
  }
]