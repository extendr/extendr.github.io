[
  {
    "objectID": "get-started.html",
    "href": "get-started.html",
    "title": "Get Started",
    "section": "",
    "text": "To build R packages with extendr, you need to have the right tools."
  },
  {
    "objectID": "get-started.html#step-1-install-rust",
    "href": "get-started.html#step-1-install-rust",
    "title": "Get Started",
    "section": "Step 1 Install Rust",
    "text": "Step 1 Install Rust\n\n\n\n\nFollow the rustup installation instructions to install Rust. Note that the current minimum supported Rust version (msrv) in extendr is 1.64. This is to ensure CRAN compliance. Windows users will also need to install the GNU toolchain as it matches Rtools. This can be done via rustup in the terminal: rustup target add x86_64-pc-windows-gnu."
  },
  {
    "objectID": "get-started.html#step-2-update-r",
    "href": "get-started.html#step-2-update-r",
    "title": "Get Started",
    "section": "Step 2 Update R",
    "text": "Step 2 Update R\n\n\n\n\nWe recommend using a moderately new version of R (&gt;= 4.2.0). You can get that from CRAN."
  },
  {
    "objectID": "get-started.html#step-3-install-rextendr",
    "href": "get-started.html#step-3-install-rextendr",
    "title": "Get Started",
    "section": "Step 3 Install rextendr",
    "text": "Step 3 Install rextendr\n\n\n\n\nThe R package {rextendr} provides scaffolding for extendr projects and tools for documenting Rust functions and objects. To install the latest development version, use pak::pak(\"extendr/rextendr\"). Note that rextendr provides a function to check your Rust installation: rextendr::rust_sitrep()."
  },
  {
    "objectID": "get-started.html#step-4-use-rust-analyzer",
    "href": "get-started.html#step-4-use-rust-analyzer",
    "title": "Get Started",
    "section": "Step 4 Use rust-analyzer",
    "text": "Step 4 Use rust-analyzer\nThis is optional, but strongly recommended. If you use Visual Studio Code (VS Code) or a similar IDE, the rust-analyzer will provide you type hinting and auto-completion suggestions. It is very helpful!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "extendr",
    "section": "",
    "text": "The extendr suite of software packages provides a Rust extension mechanism for R, thus bringing the computing power of Rust to the statistical programming environment of R. The following code provides a simple illustration of how extendr achieves this.\nThe #[extendr] attribute causes the compiler to generate wrapper and registration functions for R which are called when the package is loaded, thus allowing one to access Rust functions and structures in an R session:\nThis, of course, is just the tip of the iceberg, for there are many ways to use extendr in R:"
  },
  {
    "objectID": "index.html#software-overview",
    "href": "index.html#software-overview",
    "title": "extendr",
    "section": "Software Overview",
    "text": "Software Overview\nThe software packages that make up extendr include:\n\nRust crates:\n\nextendr-api - provides the ergonomic, opinionated, and safe interface to R in Rust\nextendr-macros - crate responsible generation of wrappers, derive macros for conversion to R, etc.\nextendr-engine - crate that enables launching R sessions from Rust code;\n\nAn R package rextendr that helps scaffolding extendr-enabled packages or compiling Rust code interactively; and\nlibR-sys - provides auto-generated bindings to R’s C-facilities (or C-API) in Rust"
  },
  {
    "objectID": "user-guide/complete-example.html",
    "href": "user-guide/complete-example.html",
    "title": "A Complete Example",
    "section": "",
    "text": "The Rust crate ecosystem is rich with very small and very powerful utility libraries. One of the most downloaded crates is heck. It provides traits and structs to perform some of the most common case conversions.\nIn this tutorial we’ll create a 0 dependency R package to provide the common case conversions. The resultant R package will be more performant but less flexible than the {snakecase} R package.\nThis tutorial covers:",
    "crumbs": [
      "User Guide",
      "A Complete Example"
    ]
  },
  {
    "objectID": "user-guide/complete-example.html#getting-started",
    "href": "user-guide/complete-example.html#getting-started",
    "title": "A Complete Example",
    "section": "Getting started",
    "text": "Getting started\nCreate a new R package:\nusethis::create_package(\"heck\")\nWhen the new R package has opened up, add extendr.\nrextendr::use_extendr(crate_name = \"rheck\", lib_name = \"rheck\")\n\n\n\n\n\n\nNote\n\n\n\nWhen adding the extendr dependency, make sure that the crate_name and lib_name arguments are not heck. In order to add the heck crate as a dependency, the crate itself cannot be called heck because it creates a recursive dependency. Doing this allows us to name the R package {heck}, but the internal Rust crate is called rheck.\n\n\nNext, heck is needed as a dependency. From your terminal, navigate to src/rust and run cargo add heck. With this, you have everything you need to get started.",
    "crumbs": [
      "User Guide",
      "A Complete Example"
    ]
  },
  {
    "objectID": "user-guide/complete-example.html#snek-case-conversion",
    "href": "user-guide/complete-example.html#snek-case-conversion",
    "title": "A Complete Example",
    "section": "snek case conversion",
    "text": "snek case conversion\n\nuse heck::ToSnekCase;\n\nLet’s start by creating a simple function to take a single string, and convert it to snake case. First, the trait ToSnekCase needs to be imported so that the method to_snek_case() is available to &str.\n\nuse heck::ToSnekCase;\n\n#[extendr]\nfn to_snek_case(x: &str) -&gt; String {\n    x.to_snek_case()\n}\n\nSimple enough, right? Let’s give it a shot. To make it accessible from your R session, it needs to be included in your extendr_module! {} macro.\nextendr_module! {\n    mod heck;\n    fn to_snek_case;\n}\nFrom your R session, run rextendr::document() followed by devtools::load_all() to make the function available. We’ll skip these step from now on, but be sure to remember it!\n\nto_snek_case(\"MakeMe-Snake case\")\n#&gt; [1] \"make_me_snake_case\"\n\nRarely is it useful to run a function on just a scalar character value. Rust, though, works with scalars by default and adding vectorization is another step.\n\nto_snek_case(c(\"DontStep\", \"on-Snek\"))\n#&gt; Error in to_snek_case(c(\"DontStep\", \"on-Snek\")): Expected Scalar, got Strings\n\nProviding a character vector causes an error. So how do you go about vectorizing?",
    "crumbs": [
      "User Guide",
      "A Complete Example"
    ]
  },
  {
    "objectID": "user-guide/complete-example.html#vectorizing-snek-case-conversion",
    "href": "user-guide/complete-example.html#vectorizing-snek-case-conversion",
    "title": "A Complete Example",
    "section": "vectorizing snek case conversion",
    "text": "vectorizing snek case conversion\nTo vectorize this function, you need to be apply the conversion to each element in a character vector. The extendr wrapper struct for a character vector is called Strings. To take in a character vector and also return one, the function signature should look like this:\n#[extendr]\nfn to_snek_case(x: Strings) -&gt; Strings {\n}\nThis says there is an argument x which must be a character vector and this function must also -&gt; return the Strings (a character vector).\nTo iterate through this you can use the .into_iter() method on the character vector.\n#[extendr]\nfn to_snek_case(x: Strings) -&gt; Strings {\n    x\n        .into_iter()\n        // the rest of the function\n}\nIterators have a method called .map() (yes, just like purrr::map()). It lets you apply a closure (an anonymous function) to each element of the iterator. In this case, each element is an Rstr. The Rstr has a method .as_str() which will return a string slice &str. You can take this slice and pass it on to .to_snek_case(). After having mapped over each element, the results are .collect()ed into another Strings.\n\n#[extendr]\nfn to_snek_case(x: Strings) -&gt; Strings {\n    x\n        .into_iter()\n        .map(|xi| {\n            xi.as_str().to_snek_case()\n        })\n        .collect::&lt;Strings&gt;()\n}\n\nThis new version of the function can be used in a vectorized manner:\n\nto_snek_case(c(\"DontStep\", \"on-Snek\"))\n#&gt; [1] \"dont_step\" \"on_snek\"\n\nBut can it handle a missing value out of the box?\n\nto_snek_case(c(\"DontStep\", NA_character_, \"on-Snek\"))\n#&gt; [1] \"dont_step\" \"na\"        \"on_snek\"\n\nWell, sort of. The as_str() method when used on a missing value will return \"NA\" which is not in a user’s best interest.",
    "crumbs": [
      "User Guide",
      "A Complete Example"
    ]
  },
  {
    "objectID": "user-guide/complete-example.html#handling-missing-values",
    "href": "user-guide/complete-example.html#handling-missing-values",
    "title": "A Complete Example",
    "section": "handling missing values",
    "text": "handling missing values\nInstead of returning \"na\", it would be better to return an actual missing value. Those can be created each scalar’s na() method e.g. Rstr::na().\nYou can modify the .map() statement to check if an NA is present, and, if so, return an NA value. To perform this check, use the is_na() method which returns a bool which is either true or false. The result can be matched. When it is missing, the match arm returns the NA scalar value. When it is not missing, the Rstr is converted to snek case. However, since the true arm is an Rstr the other false arm must also be an Rstr. To accomplish this use the Rstr::from() method.\n\n#[extendr]\nfn to_snek_case(x: Strings) -&gt; Strings {\n    x.into_iter()\n        .map(|xi| match xi.is_na() {\n            true =&gt; Rstr::na(),\n            false =&gt; Rstr::from(xi.as_str().to_snek_case()),\n        })\n        .collect::&lt;Strings&gt;()\n}\n\nThis function can now handle missing values!\n\nto_snek_case(c(\"DontStep\", NA_character_, \"on-Snek\"))\n#&gt; [1] \"dont_step\" NA          \"on_snek\"",
    "crumbs": [
      "User Guide",
      "A Complete Example"
    ]
  },
  {
    "objectID": "user-guide/complete-example.html#automating-other-methods-with-a-macro",
    "href": "user-guide/complete-example.html#automating-other-methods-with-a-macro",
    "title": "A Complete Example",
    "section": "automating other methods with a macro!",
    "text": "automating other methods with a macro!\nThere are traits for the other case conversions such as ToKebabCase, ToPascalCase, ToShoutyKebabCase and others. The each have a similar method name: .to_kebab_case(), to_pascal_case(), .to_shouty_kebab_case(). You can either choose to copy the above and change the method call multiple times, or use a macro as a form of code generation.\nA macro allows you to generate code in a short hand manner. This macro take an identifier which has a placeholder called $fn_name: $fn_name:ident.\nmacro_rules! make_heck_fn {\n    ($fn_name:ident) =&gt; {\n        #[extendr]\n        /// @export\n        fn $fn_name(x: Strings) -&gt; Strings {\n            x.into_iter()\n                .map(|xi| match xi.is_na() {\n                    true =&gt; Rstr::na(),\n                    false =&gt; Rstr::from(xi.as_str().$fn_name()),\n                })\n                .collect::&lt;Strings&gt;()\n        }\n    };\n}\nThe $fn_name placeholder is put as the function name definition which is the same as the method name. To use this macro to generate the rest of the functions the other traits need to be imported.\n\nuse heck::{\n    ToKebabCase, ToShoutyKebabCase,\n    ToSnekCase, ToShoutySnakeCase,\n    ToPascalCase, ToUpperCamelCase,\n    ToTrainCase, ToTitleCase,\n};\n\nWith the traits in scope, the macro can be invoked to generate the other functions.\nmake_heck_fn!(to_snek_case);\nmake_heck_fn!(to_shouty_snake_case);\nmake_heck_fn!(to_kebab_case);\nmake_heck_fn!(to_shouty_kebab_case);\nmake_heck_fn!(to_pascal_case);\nmake_heck_fn!(to_upper_camel_case);\nmake_heck_fn!(to_train_case);\nmake_heck_fn!(to_title_case);\nNote that each of these functions should be added to the extendr_module! {} macro in order for them to be available from R.\nTest it out with the to_shouty_kebab_case() function!\n\nto_shouty_kebab_case(\"lorem:IpsumDolor__sit^amet\")\n#&gt; [1] \"LOREM-IPSUM-DOLOR-SIT-AMET\"\n\nAnd with that, you’ve created an R package that provides case conversion using heck and with very little code!",
    "crumbs": [
      "User Guide",
      "A Complete Example"
    ]
  },
  {
    "objectID": "user-guide/complete-example.html#bench-marking-with-snakecase",
    "href": "user-guide/complete-example.html#bench-marking-with-snakecase",
    "title": "A Complete Example",
    "section": "bench marking with {snakecase}",
    "text": "bench marking with {snakecase}\nTo illustrate the performance gains from using a vectorized Rust funciton, a bench::mark() is created between to_snek_case() and snakecase::to_snake_case().\nThe bench mark will use 5000 randomly generated lorem ipsum sentences.\n\nx &lt;- unlist(lorem::ipsum(5000, 1, 25))\n\nhead(x)\n#&gt; [1] \"Adipiscing fusce dui habitasse porta libero blandit massa suscipit vulputate vel facilisis lobortis euismod lacinia dictum id ullamcorper faucibus vulputate viverra integer aenean augue curae purus.\"        \n#&gt; [2] \"Adipiscing morbi magnis mi ultrices taciti ullamcorper nascetur sociis volutpat nulla iaculis urna tristique in massa auctor semper cubilia luctus erat vivamus vestibulum lectus varius integer lacinia?\"     \n#&gt; [3] \"Lorem nisi et velit ornare nam odio rhoncus vulputate scelerisque est convallis enim habitasse inceptos praesent leo taciti nullam sagittis himenaeos natoque sapien praesent cras.\"                           \n#&gt; [4] \"Consectetur auctor neque aliquet id vivamus varius cum tempor ac duis potenti tempus dui enim ad netus magna facilisi venenatis curabitur quisque pharetra cras tristique platea.\"                             \n#&gt; [5] \"Sit rutrum facilisis pharetra velit sem primis per nec et iaculis sociosqu duis a praesent justo nec netus faucibus in non hac magnis dapibus tempor in per iaculis?\"                                          \n#&gt; [6] \"Ipsum nullam dis risus vehicula ante donec varius risus fermentum tempor fermentum litora mi litora est magna sem porttitor morbi hendrerit taciti arcu ultricies est arcu porttitor mattis cum vitae aliquam.\"\n\nbench::mark(\n  rust = to_snek_case(x),\n  snakecase = snakecase::to_snake_case(x)\n)\n#&gt; # A tibble: 2 × 6\n#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 rust         13.9ms   13.9ms     71.2     1.16MB     0   \n#&gt; 2 snakecase   206.4ms  207.5ms      4.75   12.27MB     7.92",
    "crumbs": [
      "User Guide",
      "A Complete Example"
    ]
  },
  {
    "objectID": "user-guide/complete-example.html#the-whole-thing",
    "href": "user-guide/complete-example.html#the-whole-thing",
    "title": "A Complete Example",
    "section": "The whole thing",
    "text": "The whole thing\nIn just 42 lines of code (empty lines included), you can create a very performant R package!\nuse extendr_api::prelude::*;\n\nuse heck::{\n    ToKebabCase, ToPascalCase, ToShoutyKebabCase, ToShoutySnakeCase, ToSnekCase, ToTitleCase,\n    ToTrainCase, ToUpperCamelCase,\n};\n\nmacro_rules! make_heck_fn {\n    ($fn_name:ident) =&gt; {\n        #[extendr]\n        /// @export\n        fn $fn_name(x: Strings) -&gt; Strings {\n            x.into_iter()\n                .map(|xi| match xi.is_na() {\n                    true =&gt; Rstr::na(),\n                    false =&gt; Rstr::from(xi.as_str().$fn_name()),\n                })\n                .collect::&lt;Strings&gt;()\n        }\n    };\n}\n\nmake_heck_fn!(to_snek_case);\nmake_heck_fn!(to_shouty_snake_case);\nmake_heck_fn!(to_kebab_case);\nmake_heck_fn!(to_shouty_kebab_case);\nmake_heck_fn!(to_pascal_case);\nmake_heck_fn!(to_upper_camel_case);\nmake_heck_fn!(to_train_case);\nmake_heck_fn!(to_title_case);\n\nextendr_module! {\n    mod heck;\n    fn to_snek_case;\n    fn to_shouty_snake_case;\n    fn to_kebab_case;\n    fn to_shouty_kebab_case;\n    fn to_pascal_case;\n    fn to_upper_camel_case;\n    fn to_title_case;\n    fn to_train_case;\n}",
    "crumbs": [
      "User Guide",
      "A Complete Example"
    ]
  },
  {
    "objectID": "user-guide/index.html",
    "href": "user-guide/index.html",
    "title": "User Guide",
    "section": "",
    "text": "~~~ THIS IS A WORK IN PROGRESS!!! ~~~\nThis user guide serves two primary functions:\nGiven these goals, the guide is primarily geared towards R users and R developers who also have a decent grasp of Rust.",
    "crumbs": [
      "User Guide"
    ]
  },
  {
    "objectID": "user-guide/index.html#whats-in-this-guide",
    "href": "user-guide/index.html#whats-in-this-guide",
    "title": "User Guide",
    "section": "What’s in this guide?",
    "text": "What’s in this guide?\nWe’re working on that…",
    "crumbs": [
      "User Guide"
    ]
  },
  {
    "objectID": "user-guide/index.html#whats-not-in-this-guide",
    "href": "user-guide/index.html#whats-not-in-this-guide",
    "title": "User Guide",
    "section": "What’s not in this guide?",
    "text": "What’s not in this guide?\nThis book is not intended to be a comprehensive introduction to Rust. While do go over some of the basics, more often than not, concepts are introduced only to help explain extendr tools. That said, we do try to include copious references and links to additional resources that the reader can follow to learn more about specific topics. Of course, the biggest reference will be “The Book”.\nThis book is also not intended to be a comprehensive guide to R package development! There are, quite frankly, better resources for that, notably R Packages (2e). As with Rust specifics, we will strive to point you in the right direction to get more details and advice when you need it.",
    "crumbs": [
      "User Guide"
    ]
  },
  {
    "objectID": "user-guide/type-mapping/vectors.html",
    "href": "user-guide/type-mapping/vectors.html",
    "title": "Vector Type Mapping",
    "section": "",
    "text": "What happens if we try to pass more than one value to scalar_double()?\n\nscalar_double(c(4.2, 1.3, 2.5))\n#&gt; Error in scalar_double(c(4.2, 1.3, 2.5)): Expected Scalar, got Doubles\n\nIt errors because the function expects a scalar of the f64 type, not a vector of f64.\nIn this section, we show you how to pass Rust vectors between R and Rust.\n\n\n\n\n\n\nImportant\n\n\n\nWhile using a Rust vector is possible in some cases, it is strongly not recommended. Instead, extendr types should be used as they provide access directly to R objectes. Whereas using Rust vectors requires additional allocations.\n\n\nThe syntax is basically the same as with scalars, with just some minor changes. We’ll use doubles again to demonstrate this.\nFor reference, below are the type of Rust vectors that can be utilized with extendr.\n\n\n\nR type\nextendr type\nRust type\n\n\n\n\ninteger()\nIntegers\nVec&lt;i32&gt;\n\n\ndouble()\nDoubles\nVec&lt;f64&gt;\n\n\ncomplex()\nComplexes\nVec&lt;Complex&lt;f64&gt;&gt;\n\n\ncharacter()\nStrings\nVec&lt;String&gt;\n\n\nraw()\nRaw\n&[u8]\n\n\nlogical()\nLogicals\n\n\n\nlist()\nList\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nYou might have anticipated Vec&lt;bool&gt; to be a supported Rust vector type. This is not possible because in R, logical vectors do not contain only true and false like Rust’s bool type. They also can be an NA value which has no corresponding representation in Rust.\n\n\nBelow defines Rust function which takes in a vector of f64 values and prints them out.\n\n#[extendr]\nfn vector_double(x: Vec&lt;f64&gt;) {\n    rprintln!(\"The values of x are {x:?}\");\n}\n\nThat function can be called from R which prints the Debug format of the vector.\n\n\n\n\n\n\nTip\n\n\n\nRust’s vector do not implement the Display trait so the debug format (:?) is used.\n\n\n\nvector_double(c(4.2, 1.3, 2.5))\n#&gt; The values of x are [4.2, 1.3, 2.5]\n\nReturning values using Rust follows the same rules as R. You do not need to explicitly return a value as long as the last item in an expression is not followed by a ;.\n\n#[extendr]\nfn vector_double(x: Vec&lt;f64&gt;) -&gt; Vec&lt;f64&gt; { \n    x \n}\n\nCalling the function returns the input as a double vector\n\nx &lt;- vector_double(c(4.2, 1.3, 2.5))\ntypeof(x)\n#&gt; [1] \"double\"\nx + 1\n#&gt; [1] 5.2 2.3 3.5\n\n\n\nThese same principles can be extended to other supported vector types such as Vec&lt;i32&gt; and Vec&lt;String&gt;.\n\n#[extendr]\nfn vector_integer(x: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; { \n    x\n}\n\n#[extendr]\nfn vector_character(x: Vec&lt;String&gt;) -&gt; Vec&lt;String&gt; {\n    x \n}\n\n\nvector_integer(c(4L, 6L, 8L))\n#&gt; [1] 4 6 8\n\nvector_character(c(\"Hello world!\", \"Hello extendr!\", \"Hello R!\"))\n#&gt; [1] \"Hello world!\"   \"Hello extendr!\" \"Hello R!\"",
    "crumbs": [
      "User Guide",
      "Type Mapping",
      "Vector Type Mapping"
    ]
  },
  {
    "objectID": "user-guide/type-mapping/vectors.html#vector-type-mapping-with-rust-types",
    "href": "user-guide/type-mapping/vectors.html#vector-type-mapping-with-rust-types",
    "title": "Vector Type Mapping",
    "section": "",
    "text": "What happens if we try to pass more than one value to scalar_double()?\n\nscalar_double(c(4.2, 1.3, 2.5))\n#&gt; Error in scalar_double(c(4.2, 1.3, 2.5)): Expected Scalar, got Doubles\n\nIt errors because the function expects a scalar of the f64 type, not a vector of f64.\nIn this section, we show you how to pass Rust vectors between R and Rust.\n\n\n\n\n\n\nImportant\n\n\n\nWhile using a Rust vector is possible in some cases, it is strongly not recommended. Instead, extendr types should be used as they provide access directly to R objectes. Whereas using Rust vectors requires additional allocations.\n\n\nThe syntax is basically the same as with scalars, with just some minor changes. We’ll use doubles again to demonstrate this.\nFor reference, below are the type of Rust vectors that can be utilized with extendr.\n\n\n\nR type\nextendr type\nRust type\n\n\n\n\ninteger()\nIntegers\nVec&lt;i32&gt;\n\n\ndouble()\nDoubles\nVec&lt;f64&gt;\n\n\ncomplex()\nComplexes\nVec&lt;Complex&lt;f64&gt;&gt;\n\n\ncharacter()\nStrings\nVec&lt;String&gt;\n\n\nraw()\nRaw\n&[u8]\n\n\nlogical()\nLogicals\n\n\n\nlist()\nList\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nYou might have anticipated Vec&lt;bool&gt; to be a supported Rust vector type. This is not possible because in R, logical vectors do not contain only true and false like Rust’s bool type. They also can be an NA value which has no corresponding representation in Rust.\n\n\nBelow defines Rust function which takes in a vector of f64 values and prints them out.\n\n#[extendr]\nfn vector_double(x: Vec&lt;f64&gt;) {\n    rprintln!(\"The values of x are {x:?}\");\n}\n\nThat function can be called from R which prints the Debug format of the vector.\n\n\n\n\n\n\nTip\n\n\n\nRust’s vector do not implement the Display trait so the debug format (:?) is used.\n\n\n\nvector_double(c(4.2, 1.3, 2.5))\n#&gt; The values of x are [4.2, 1.3, 2.5]\n\nReturning values using Rust follows the same rules as R. You do not need to explicitly return a value as long as the last item in an expression is not followed by a ;.\n\n#[extendr]\nfn vector_double(x: Vec&lt;f64&gt;) -&gt; Vec&lt;f64&gt; { \n    x \n}\n\nCalling the function returns the input as a double vector\n\nx &lt;- vector_double(c(4.2, 1.3, 2.5))\ntypeof(x)\n#&gt; [1] \"double\"\nx + 1\n#&gt; [1] 5.2 2.3 3.5\n\n\n\nThese same principles can be extended to other supported vector types such as Vec&lt;i32&gt; and Vec&lt;String&gt;.\n\n#[extendr]\nfn vector_integer(x: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; { \n    x\n}\n\n#[extendr]\nfn vector_character(x: Vec&lt;String&gt;) -&gt; Vec&lt;String&gt; {\n    x \n}\n\n\nvector_integer(c(4L, 6L, 8L))\n#&gt; [1] 4 6 8\n\nvector_character(c(\"Hello world!\", \"Hello extendr!\", \"Hello R!\"))\n#&gt; [1] \"Hello world!\"   \"Hello extendr!\" \"Hello R!\"",
    "crumbs": [
      "User Guide",
      "Type Mapping",
      "Vector Type Mapping"
    ]
  },
  {
    "objectID": "user-guide/r-pkgs/package-structure.html",
    "href": "user-guide/r-pkgs/package-structure.html",
    "title": "Project Structure",
    "section": "",
    "text": "A extendr-powered R package has a fairly unique structure. This section briefly outlines the structure of an extendr package and the important files.\nextendr works by creating a Rust library crate in src/rust that is defined by src/rust/Cargo.toml.\nNote the crate-type = [ 'staticlib' ]. When this library is compiled, it creates a static library which can then be called from R.",
    "crumbs": [
      "User Guide",
      "R Packages",
      "Project Structure"
    ]
  },
  {
    "objectID": "user-guide/r-pkgs/package-structure.html#controlling-exports-to-r-lib.rs",
    "href": "user-guide/r-pkgs/package-structure.html#controlling-exports-to-r-lib.rs",
    "title": "Project Structure",
    "section": "Controlling exports to R: lib.rs",
    "text": "Controlling exports to R: lib.rs\nThe lib.rs file determines what will be exposed to your R package. The extendr_module! macro in lib.rs controls what will have wrappers provided to your R package.\nextendr_module! {\n    mod hellorust;\n    fn hello_world;\n}\nThe mod hellorust is the name of the R package. Additional functions, impls, and modules can also be added to this macro.",
    "crumbs": [
      "User Guide",
      "R Packages",
      "Project Structure"
    ]
  },
  {
    "objectID": "user-guide/r-pkgs/package-structure.html#building-the-package-makevars",
    "href": "user-guide/r-pkgs/package-structure.html#building-the-package-makevars",
    "title": "Project Structure",
    "section": "Building the package: Makevars",
    "text": "Building the package: Makevars\nWhen creating an R package that uses compiled code, a file called Makevars is used.\n\n\n\n\n\n\nNote\n\n\n\nSee Using Makevars in Writing R Extensions for a thorough discussion.\n\n\nMakevars is used as a preprocessing step for compiling an R package. The files Makevars and Makevars.win compile the Rust library in src/rust, and link to the library.\n\n\n\n\n\n\nTip\n\n\n\nMakevars is used for *nix operating systems and Makevars.win is used for Windows.",
    "crumbs": [
      "User Guide",
      "R Packages",
      "Project Structure"
    ]
  },
  {
    "objectID": "CONTRIBUTING.html",
    "href": "CONTRIBUTING.html",
    "title": "Contributing",
    "section": "",
    "text": "We welcome contributions to the extendr project. Contributions come in many forms. Please carefully read and follow these guidelines. This will help us make the contribution process easy and effective for everyone involved. It also communicates that you agree to respect the time of the developers managing and developing this project.\n\n\n\nCode of Conduct\nGetting Started\n\nIssues\nPull Requests\n\nGetting Help\nAuthorship\nAttribution\n\n\n\n\nWe take our open source community seriously and hold ourselves and other contributors to high standards of communication. By participating and contributing to this project, you agree to uphold our Code of Conduct.\n\n\n\nContributions can be made via Issues and Pull Requests (PRs). A few general guidelines cover both:\n\nPlease search for existing Issues and PRs before creating your own.\nWe work hard to makes sure issues are handled in a timely manner but, depending on the problem and maintainer availability, it could take a while to investigate the problem. A friendly ping in the comment thread can help draw attention if an issue has not received any attention for a while. Please keep in mind that all contributors to this project are volunteers and may have other commitments they need to attend to.\n\n\n\nIssues should be used to report problems with the library, request a new feature, or to discuss potential changes before a PR is created. Please do not use Issues to request user support.\nWhenever possible, please provide a minimal reproducible example (reprex) to any bug report that you are filing. The more minimal your example, the more likely that somebody else can figure out what the problem is, so please remove any code that isn’t relevant to the problem you are reporting.\nPlease keep issues focused on one particular problem. Don’t feel shy about opening multiple issues if you’re encountering more than one problem.\nIf you find an Issue that addresses the problem you’re having, please add your own reproduction information to the existing issue rather than creating a new one. Adding a reaction can also help be indicating to our maintainers that a particular problem is affecting more than just the reporter.\n\n\n\nPRs are always welcome and can be a quick way to get your fix or improvement slated for the next release. However, please always open an Issue before submitting a PR.\nIn general, PRs should:\n\nAddress a single concern in the least number of changed lines as possible.\nOnly fix/add the functionality in question OR address wide-spread whitespace/style issues, not both.\nAdd unit or integration tests for fixed or changed functionality.\nInclude documentation.\nIndicate which Issue they address by using the words Closes #&lt;issue number&gt; or Fixes #&lt;issue number&gt; in the body of the PR and/or the git commit message. (See the GitHub Documentation for details about linking PRs to Issues and automatically closing Issues when merging PRs.)\n\nIn general, we follow the GitHub flow development model:\n\nFork the repository to your own Github account\nClone the project to your machine\nCreate a branch locally with a succinct but descriptive name\nCommit changes to the branch\nPush changes to your fork\nOpen a PR in our repository and follow the PR template so that we can efficiently review the changes.\n\n\n\n\n\nPlease join us on our Discord server for general conversations and questions that don’t belong into a GitHub issue.\n\n\n\nContributors who have made multiple, sustained, and/or non-trivial contributions to the project may be added to the author list. New author names will always be added at the end of the list, so that author order reflects chronological order of joining the project. All authorship decisions are at the discretion of the current maintainers of the project.\n\n\n\nThis document was adapted from the General Contributing Guidelines of the auth0 project."
  },
  {
    "objectID": "CONTRIBUTING.html#quicklinks",
    "href": "CONTRIBUTING.html#quicklinks",
    "title": "Contributing",
    "section": "",
    "text": "Code of Conduct\nGetting Started\n\nIssues\nPull Requests\n\nGetting Help\nAuthorship\nAttribution"
  },
  {
    "objectID": "CONTRIBUTING.html#code-of-conduct",
    "href": "CONTRIBUTING.html#code-of-conduct",
    "title": "Contributing",
    "section": "",
    "text": "We take our open source community seriously and hold ourselves and other contributors to high standards of communication. By participating and contributing to this project, you agree to uphold our Code of Conduct."
  },
  {
    "objectID": "CONTRIBUTING.html#getting-started",
    "href": "CONTRIBUTING.html#getting-started",
    "title": "Contributing",
    "section": "",
    "text": "Contributions can be made via Issues and Pull Requests (PRs). A few general guidelines cover both:\n\nPlease search for existing Issues and PRs before creating your own.\nWe work hard to makes sure issues are handled in a timely manner but, depending on the problem and maintainer availability, it could take a while to investigate the problem. A friendly ping in the comment thread can help draw attention if an issue has not received any attention for a while. Please keep in mind that all contributors to this project are volunteers and may have other commitments they need to attend to.\n\n\n\nIssues should be used to report problems with the library, request a new feature, or to discuss potential changes before a PR is created. Please do not use Issues to request user support.\nWhenever possible, please provide a minimal reproducible example (reprex) to any bug report that you are filing. The more minimal your example, the more likely that somebody else can figure out what the problem is, so please remove any code that isn’t relevant to the problem you are reporting.\nPlease keep issues focused on one particular problem. Don’t feel shy about opening multiple issues if you’re encountering more than one problem.\nIf you find an Issue that addresses the problem you’re having, please add your own reproduction information to the existing issue rather than creating a new one. Adding a reaction can also help be indicating to our maintainers that a particular problem is affecting more than just the reporter.\n\n\n\nPRs are always welcome and can be a quick way to get your fix or improvement slated for the next release. However, please always open an Issue before submitting a PR.\nIn general, PRs should:\n\nAddress a single concern in the least number of changed lines as possible.\nOnly fix/add the functionality in question OR address wide-spread whitespace/style issues, not both.\nAdd unit or integration tests for fixed or changed functionality.\nInclude documentation.\nIndicate which Issue they address by using the words Closes #&lt;issue number&gt; or Fixes #&lt;issue number&gt; in the body of the PR and/or the git commit message. (See the GitHub Documentation for details about linking PRs to Issues and automatically closing Issues when merging PRs.)\n\nIn general, we follow the GitHub flow development model:\n\nFork the repository to your own Github account\nClone the project to your machine\nCreate a branch locally with a succinct but descriptive name\nCommit changes to the branch\nPush changes to your fork\nOpen a PR in our repository and follow the PR template so that we can efficiently review the changes."
  },
  {
    "objectID": "CONTRIBUTING.html#getting-help",
    "href": "CONTRIBUTING.html#getting-help",
    "title": "Contributing",
    "section": "",
    "text": "Please join us on our Discord server for general conversations and questions that don’t belong into a GitHub issue."
  },
  {
    "objectID": "CONTRIBUTING.html#authorship",
    "href": "CONTRIBUTING.html#authorship",
    "title": "Contributing",
    "section": "",
    "text": "Contributors who have made multiple, sustained, and/or non-trivial contributions to the project may be added to the author list. New author names will always be added at the end of the list, so that author order reflects chronological order of joining the project. All authorship decisions are at the discretion of the current maintainers of the project."
  },
  {
    "objectID": "CONTRIBUTING.html#attribution",
    "href": "CONTRIBUTING.html#attribution",
    "title": "Contributing",
    "section": "",
    "text": "This document was adapted from the General Contributing Guidelines of the auth0 project."
  },
  {
    "objectID": "user-guide/r-pkgs/package-setup.html",
    "href": "user-guide/r-pkgs/package-setup.html",
    "title": "Package Setup",
    "section": "",
    "text": "Once you have Rust and {rextendr} installed, you can begin creating Rust-powered R packages.\nThe first step to using extendr is to create an R package. It is recommend to create a new package using the package {usethis}.\nusethis::create_package(\"hellorust\")\nIf you are in the RStudio IDE, a new R project will be opened up for you with the file structure of a new R package.\n.\n├── DESCRIPTION\n├── NAMESPACE\n├── R\n└── hellorust.Rproj\nNow that you have a new R package, you can add extendr to it.\nrextendr::use_extendr()\nThis will add an extendr package template to the R packge. We will go through the package structure in more depth shortly.\n.\n├── DESCRIPTION\n├── NAMESPACE\n├── R\n│   └── extendr-wrappers.R\n├── hellorust.Rproj\n└── src\n    ├── Makevars\n    ├── Makevars.ucrt\n    ├── Makevars.win\n    ├── entrypoint.c\n    ├── hellorust-win.def\n    └── rust\n        ├── Cargo.toml\n        └── src\n            └── lib.rs\nInside of the file src/rust/src/lib.rs is a hello world function.\n/// Return string `\"Hello world!\"` to R.\n/// @export\n#[extendr]\nfn hello_world() -&gt; &'static str {\n    \"Hello world!\"\n}\n\n\n\n\n\n\nTip\n\n\n\nNote that roxygen2 can be used with Rust documentation comments /// instead of //.\n\n\nThe function is made available to R via the macro extendr_module!.\n// Macro to generate exports.\n// This ensures exported functions are registered with R.\n// See corresponding C code in `entrypoint.c`.\nextendr_module! {\n    mod hellorust;\n    fn hello_world;\n}\nUse the function rextendr::document() to automatically create R function wrappers to call the Rust function. This will recompile the Rust library.\nrextendr::document()\n#&gt;  rextendr::document()\n#&gt; ✔ Saving changes in the open files.\n#&gt; ℹ Generating extendr wrapper functions for package: hellorust.\n#&gt; ℹ Re-compiling hellorust (debug build)\n#&gt; .... truncated ....\n#&gt; ─  DONE (hellorust)\n#&gt; ✔ Writing 'R/extendr-wrappers.R'\n#&gt; ℹ Updating hellorust documentation\n#&gt; Writing NAMESPACE\n#&gt; ℹ Loading hellorust\n#&gt; Writing NAMESPACE\n#&gt; Writing hellorust-package.Rd\n#&gt; Writing hello_world.Rd\nThe file R/extendr-wrappers.R was updated and now contains\n#' Return string `\"Hello world!\"` to R.\n#' @export\nhello_world &lt;- function() .Call(wrap__hello_world)\nRun devtools::load_all() to make the function available to your session.\ndevtools::load_all()\n#&gt; ℹ Loading hellorust\nThe package hellorust has been loaded and now you can run hello_world()\nhello_world()\n#&gt; \"Hello world!\"",
    "crumbs": [
      "User Guide",
      "R Packages",
      "Package Setup"
    ]
  },
  {
    "objectID": "user-guide/type-mapping/scalars.html",
    "href": "user-guide/type-mapping/scalars.html",
    "title": "Scalar Type Mapping",
    "section": "",
    "text": "This tutorial demonstrates some of the basics of passing scalar data types back and forth between Rust and R. We’ll start with simple examples using explicit Rust types but then move on to showing their extendr alternatives. Why does extendr have its own data types? For a number of reasons, of course, but the most important reason is probably that Rust types do not allow for missing values, so no NA, NaN, NULL, or what have you. Fortunately, extendr types will handle missing values for you. For this reason, it is strongly recommended that you work with the extendr types whenever possible.",
    "crumbs": [
      "User Guide",
      "Type Mapping",
      "Scalar Type Mapping"
    ]
  },
  {
    "objectID": "user-guide/type-mapping/scalars.html#scalar-types",
    "href": "user-guide/type-mapping/scalars.html#scalar-types",
    "title": "Scalar Type Mapping",
    "section": "Scalar types",
    "text": "Scalar types\nA scalar type consists of a single value, and it can only consist of a single value, whether that value is a single character string, integer, or logical. As it happens, R doesn’t have a way of representing a scalar value. That’s because everything is a vector in R, and vectors can have any arbitrary length you want. So, the closest thing to a scalar you will ever encounter in R is a vector that just so happens to have a length of one. In Rust, however, scalars are the building blocks of everything, and they come in a bewildering variety, at least for the traditional R user. Consider, for example, integers. R has just one way to represent this type of numeric value. Rust, on the other hand, has twelve!\nThe table below shows the most common R “scalar” types, along with their Rust and extendr equivalents.\n\n\n\nR type\nextendr type\nRust type\n\n\n\n\ninteger(1)\nRint\ni32\n\n\ndouble(1)\nRfloat\nf64\n\n\nlogical(1)\nRbool\nbool\n\n\ncomplex(1)\nRcplx\nComplex&lt;f64&gt;\n\n\ncharacter(1)\nRstr\nString\n\n\n\nTo learn more about Rust types, see section 3.2 of The Book.",
    "crumbs": [
      "User Guide",
      "Type Mapping",
      "Scalar Type Mapping"
    ]
  },
  {
    "objectID": "user-guide/type-mapping/scalars.html#sharing-scalars",
    "href": "user-guide/type-mapping/scalars.html#sharing-scalars",
    "title": "Scalar Type Mapping",
    "section": "Sharing scalars",
    "text": "Sharing scalars\nTo see how scalars get passed back and forth between Rust and R, we’ll first explore Rust’s f64 value which is a 64-bit float. This is equivalent to R’s double(1). We’ll write a very simple Rust function that prints the value of the input and does not return anything.\n\n#[extendr]\nfn scalar_double(x: f64) { \n    rprintln!(\"The value of x is {x}\"); \n}\n\nThrough the magic of extendr, we can now call this function in R and pass it a single double value.\n\nscalar_double(4.2)\n#&gt; The value of x is 4.2\n\nThere are several things to note about this example. First, in Rust, x: f64 tells us that the type of x being passed to the function (fn) is a single double vector or “float” value. Second, rprintln!(\"{}\", x); is an extendr macro that makes it easier to print information from Rust to the console in R. R users will perhaps notice that the syntax is vaguely {glue}-like in that the value of x is inserted into the curly brackets. Finally, if you are not working inside of an extendr R package, you can create the scalar_double() function locally using rextendr::rust_function().\nrextendr::rust_function(\"\nfn scalar_double(x: f64) { \n    rprintln!(\"The value of x is {x}\"); \n}\n\")\nNow, what if, rather than printing the value of x to the R console, we wanted instead to return that value to R? To do that, we just need to let Rust know what type is being returned by our function. This is done with the -&gt; type notation. The extendr crate understands this notation and knows how to handle the scalar f64 type returned by the Rust function and pass it to R as double.\n\n#[extendr]\nfn return_scalar_double(x: f64) -&gt; f64 { \n    x \n}\n\n\nx &lt;- return_scalar_double(4.2)\n\ntypeof(x)\n#&gt; [1] \"double\"\n\nx + 1.0\n#&gt; [1] 5.2",
    "crumbs": [
      "User Guide",
      "Type Mapping",
      "Scalar Type Mapping"
    ]
  },
  {
    "objectID": "user-guide/type-mapping/scalars.html#missing-values",
    "href": "user-guide/type-mapping/scalars.html#missing-values",
    "title": "Scalar Type Mapping",
    "section": "Missing values",
    "text": "Missing values\nAs noted above, Rust does not allow a scalar type to have a missing value, so you cannot simply pass a missing value like NA to Rust and expect it to just work. Here is a demonstration of this issue using a simple function which adds 1.0 to x.\n\n#[extendr]\nfn plus_one(x: f64) -&gt; f64 { \n    x + 1.0 \n}\n\nYou will notice that this function expects x to be f64, not a missing value. Passing a missing value from R to this Rust function will, therefore, result in an error.\n\nplus_one(NA_real_)\n#&gt; Error in plus_one(NA_real_): Must not be NA.\n\nFortunately, the extendr types are NA-aware, so you can, for instance, use extendr’s Rfloat in place of f64 to handle missing values without error. Below, you will see that we have done this for the function plus_one().\n\n#[extendr]\nfn plus_one(x: Rfloat) -&gt; Rfloat { \n    x + 1.0 \n}\n\n\nplus_one(NA_real_)\n#&gt; [1] NA\n\nplus_one(4.2)\n#&gt; [1] 5.2",
    "crumbs": [
      "User Guide",
      "Type Mapping",
      "Scalar Type Mapping"
    ]
  },
  {
    "objectID": "user-guide/type-mapping/scalars.html#additional-examples",
    "href": "user-guide/type-mapping/scalars.html#additional-examples",
    "title": "Scalar Type Mapping",
    "section": "Additional examples",
    "text": "Additional examples\nHere are some additional examples showing how to pass scalars to Rust and return them to R using Rust scalar types.\n\n#[extendr]\nfn scalar_integer(x: i32) -&gt; i32 { x }\n\n#[extendr]\nfn scalar_logical(x: bool) -&gt; bool { x }\n\n\nscalar_integer(4L)\n#&gt; [1] 4\n\nscalar_logical(TRUE)\n#&gt; [1] TRUE\n\nAnd here are the same examples with extendr scalar types.\n\n#[extendr]\nfn scalar_integer(x: Rint) -&gt; Rint { x }\n\n#[extendr]\nfn scalar_logical(x: Rbool) -&gt; Rbool { x }\n\n\nscalar_integer(4L)\n#&gt; [1] 4\n\nscalar_logical(TRUE)\n#&gt; [1] TRUE\n\nDid you notice that we didn’t give an example with character strings? Yeah, well, there’s a good reason for that. You can find out what that is by heading over to the tutorial on Character Strings.",
    "crumbs": [
      "User Guide",
      "Type Mapping",
      "Scalar Type Mapping"
    ]
  },
  {
    "objectID": "user-guide/type-mapping/extendr-macro.html",
    "href": "user-guide/type-mapping/extendr-macro.html",
    "title": "The extendr Macro",
    "section": "",
    "text": "The power of extendr is in its ability to use Rust from R. The #[extendr] macro is what determines what is exported to R from Rust. This section covers the basic usage of the #[extendr] macro.\n#[extendr] is what is referred to as an attribute macro (which itself is a type of procedural macro). An attribute macro is attached to an item such as a function, struct, enum, or impl.\nThe #[extendr] attribute macro indicates that an item should be made available to R. However, it can only be used with a function or an impl block.",
    "crumbs": [
      "User Guide",
      "Type Mapping",
      "The extendr Macro"
    ]
  },
  {
    "objectID": "user-guide/type-mapping/extendr-macro.html#exporting-functions",
    "href": "user-guide/type-mapping/extendr-macro.html#exporting-functions",
    "title": "The extendr Macro",
    "section": "Exporting functions",
    "text": "Exporting functions\nIn order to make a function available to R, two things must happen. First, the #[extendr] macro must be attached to the function. For example, you can create a function answer_to_life()\n\n\n\n\n\n\nNote\n\n\n\n\n\nIn the Hitchhiker’s Guide to the Galaxy, the number 42 is the answer to the universe. See this fun article from Scientific American\n\n\n\n#[extendr]\nfn answer_to_life() -&gt; i32 {\n    42\n}\nBy adding the #[extendr] attribute macro to the answer_to_life() function, we are indicating that this function has to be compatible with R. This alone, however, does not make the function available to R. It must be made available via the extendr_module! {} macro in lib.rs.\nextendr_module! {\n    mod hellorust;\n    fn answer_to_life;\n}\n\n\n\n\n\n\nTip\n\n\n\nEverything that is made available in the extendr_module! {} macro in lib.rs must be compatible with R as indicated by the #[extendr] macro. Note that the module name mod hellorust must be the name of the R package that this is part of. If you have created your package with rextendr::use_extendr() this should be set automatically. See Hello, world!.\n\n\nWhat happens if you try and return something that cannot be represented by R? Take this example, an enum Shape is defined and a function takes a string &str. Based on the value of the arugment, an enum variant is returned.\n#[derive(Debug)]\nenum Shape {\n    Triangle,\n    Rectangle,\n    Pentagon,\n    Hexagon,\n}\n\n#[extendr]\nfn make_shape(shape: &str) -&gt; Shape {\n    match shape {\n        \"triangle\" =&gt; Shape::Triangle,\n        \"rectangle\" =&gt; Shape::Rectangle,\n        \"pentagon\" =&gt; Shape::Pentagon,\n        \"hexagon\" =&gt; Shape::Hexagon,\n        &_ =&gt; unimplemented!()\n    }\n}\nWhen this is compiled, an error occurs because extendr does not know how to convert the Shape enum into something that R can use. The error is fairly informative!\n   | ^^^^^^^^^^ the trait `ToVectorValue` is not implemented for `Shape`, which is required by `extendr_api::Robj: From&lt;Shape&gt;`\n   |\n   = help: the following other types implement trait `ToVectorValue`:\n             bool\n             i8\n             i16\n             i32\n             i64\n             usize\n             u8\n             u16\n           and 45 others\n   = note: required for `extendr_api::Robj` to implement `From&lt;Shape&gt;`\n   = note: this error originates in the attribute macro `extendr` \nIt tells you that Shape does not implement the ToVectorValue trait. The ToVectorValue trait is what enables items from Rust to be returned to R.",
    "crumbs": [
      "User Guide",
      "Type Mapping",
      "The extendr Macro"
    ]
  },
  {
    "objectID": "user-guide/type-mapping/extendr-macro.html#tovectorvalue-trait",
    "href": "user-guide/type-mapping/extendr-macro.html#tovectorvalue-trait",
    "title": "The extendr Macro",
    "section": "ToVectorValue trait",
    "text": "ToVectorValue trait\nIn order for an item to be returned from a function marked with the #[extendr] attribute macro, it must be able to be turned into an R object. In extendr, the struct Robj is a catch all for any type of R object.\n\n\n\n\n\n\nNote\n\n\n\nFor those familiar with PyO3, the Robj struct is similar in concept to the PyAny struct.\n\n\nThe ToVectorValue trait is what is used to convert Rust items into R objects. The trait is implemented on a number of standard Rust types such as i32, f64, usize, String and more (see all foreign implementations here) which enables these functions to be returned from a Rust function marked with #[extendr].\n\n\n\n\n\n\nNote\n\n\n\nIn essence, all items that are returned from a function must be able to be turned into an Robj. Other extendr types such as List, for example, have a From&lt;T&gt; for Robj implementation that defines how it is converted into an Robj.\n\n\nThis means that with a little extra work, the Shape enum can be returned to R. To do so, the #[extendr] macro needs to be added to an impl block.",
    "crumbs": [
      "User Guide",
      "Type Mapping",
      "The extendr Macro"
    ]
  },
  {
    "objectID": "user-guide/type-mapping/extendr-macro.html#exporting-impl-blocks",
    "href": "user-guide/type-mapping/extendr-macro.html#exporting-impl-blocks",
    "title": "The extendr Macro",
    "section": "Exporting impl blocks",
    "text": "Exporting impl blocks\nThe other supported item that can be made available to R is an impl block. impl is a keyword that allows you to implement a trait or an inherent implementation. The #[extendr] macro works with inherent implementations. These are impls on a type such as an enum or a struct. extendr does not support using #[extendr] on trait impls.\n\n\n\n\n\n\nNote\n\n\n\nYou can only add an inherent implementation on a type that you have own and not provided by a third party crate. This would violate the orphan rules.\n\n\nContinuing with the Shape example, this enum alone cannot be returned to R. For example, the following code will result in a compilation error\n#[derive(Debug)]\nenum Shape {\n    Triangle,\n    Rectangle,\n    Pentagon,\n    Hexagon,\n}\n\n#[extendr]\nfn make_shape(shape: &str) -&gt; Shape {\n    match shape {\n        \"triangle\" =&gt; Shape::Triangle,\n        \"rectangle\" =&gt; Shape::Rectangle,\n        \"pentagon\" =&gt; Shape::Pentagon,\n        \"hexagon\" =&gt; Shape::Hexagon,\n        &_ =&gt; unimplemented!()\n    }\n}\nerror[E0277]: the trait bound `Shape: ToVectorValue` is not satisfied\n  --&gt; src/lib.rs:19:1\n   |\n19 | #[extendr]\n   | ^^^^^^^^^^ the trait `ToVectorValue` is not implemented for `Shape`, which is required by `extendr_api::Robj: From&lt;Shape&gt;`\n   |\nHowever, if an impl block is added to the Shape enum, it can be returned to R.\n\n#[derive(Debug)]\nenum Shape {\n    Triangle,\n    Rectangle,\n    Pentagon,\n    Hexagon,\n}\n\n#[extendr]\nimpl Shape {\n    fn new(x: &str) -&gt; Self {\n        match x {\n            \"triangle\" =&gt; Self::Triangle,\n            \"rectangle\" =&gt; Self::Rectangle,\n            \"pentagon\" =&gt; Self::Pentagon,\n            \"hexagon\" =&gt; Self::Hexagon,\n            &_ =&gt; unimplemented!(),\n        }\n    }\n\n    fn n_coords(&self) -&gt; usize {\n        match &self {\n            Shape::Triangle =&gt; 3,\n            Shape::Rectangle =&gt; 4,\n            Shape::Pentagon =&gt; 4,\n            Shape::Hexagon =&gt; 5,\n        }\n    }\n}\n\nIn this example two new methods are added to the Shape enum. The first new() is like the make_shape() function that was shown earlier: it takes a &str and returns an enum variant. Now that the enum has an impl block with #[extendr] attribute macro, it can be exported to R by inclusion in the extendr_module! {} macro.\nextendr_module! {\n    mod hellorust;\n    impl Shape;\n}\nDoing so creates an environment in your package called Shape. The environment contains all of the methods that are available to you.\n\n\n\n\n\n\nTip\n\n\n\nThere are use cases where you may not want to expose any methods but do want to make it possible to return a struct or an enum to the R. You can do this by adding an empty impl block with the #[extendr] attribute macro.\n\n\nIf you run as.list(Shape) you will see that there are two functions in the environment which enable you to call the methods defined in the impl block. You might think that this feel like an R6 object and you’d be right because an R6 object essentially is an environment!\n\nas.list(Shape)\n#&gt; $n_coords\n#&gt; function () \n#&gt; .Call(\"wrap__Shape__n_coords\", self, PACKAGE = \"librextendr1.dylib\")\n#&gt; \n#&gt; $new\n#&gt; function (x) \n#&gt; .Call(\"wrap__Shape__new\", x, PACKAGE = \"librextendr1.dylib\")\n\nCalling the new() method instantiates a new enum variant.\n\ntri &lt;- Shape$new(\"triangle\")\ntri\n#&gt; &lt;pointer: 0x122f29b40&gt;\n#&gt; attr(,\"class\")\n#&gt; [1] \"Shape\"\n\nThe newly made tri object is an external pointer to the Shape enum in Rust. This pointer has the same methods as the Shape environment—though they cannot be seen in the same way. For example you can run the n_coords() method on the newly created object.\n\ntri$n_coords()\n#&gt; [1] 3\n\n\n\n\n\n\n\nTip\n\n\n\nTo make the methods visible to the Shape class you can define a .DollarNames method which will allow you to preview the methods and attributes when using the $ syntax. This is very handy to define when making an impl a core part of your package.\n\n.DollarNames.Shape = function(env, pattern = \"\") {\n  ls(Shape, pattern = pattern)\n}\n\n\n\n\nimpl ownership\nAdding the #[extendr] macro to an impl allows the struct or enum to be made available to R as an external pointer. Once you create an external pointer, that is then owned by R. So you can only get references to it or mutable references. If you need an owned version of the type, then you will need to clone it.",
    "crumbs": [
      "User Guide",
      "Type Mapping",
      "The extendr Macro"
    ]
  },
  {
    "objectID": "user-guide/type-mapping/extendr-macro.html#accessing-exported-impls-from-rust",
    "href": "user-guide/type-mapping/extendr-macro.html#accessing-exported-impls-from-rust",
    "title": "The extendr Macro",
    "section": "Accessing exported impls from Rust",
    "text": "Accessing exported impls from Rust\nInvariably, if you have made an impl available to R via the #[extendr] macro, you may want to define functions that take the impl as a function argument.\nDue to R owning the impl’s external pointer, these functions cannot take an owned version of the impl as an input. For example trying to define a function that subtracts an integer from the n_coords() output like below returns a compiler error.\n#[extendr]\nfn subtract_coord(x: Shape, n: i32) -&gt; i32 {\n    (x.n_coords() as i32) - n\n}\nthe trait bound `Shape: extendr_api::FromRobj&lt;'_&gt;` is not satisfied\n  --&gt; src/lib.rs:53:22\n   |\n   | fn subtract_coord(x: Shape, n: i32) -&gt; i32 {\n   |                      ^^^^^ the trait `extendr_api::FromRobj&lt;'_&gt;` is not implemented for `Shape`\n   |\nhelp: consider borrowing here\n   |\n   | fn subtract_coord(x: &Shape, n: i32) -&gt; i32 {\n   |                      +\n   | fn subtract_coord(x: &mut Shape, n: i32) -&gt; i32 {\n   |                      ++++\nAs most often, the compiler’s suggestion is a good one. Use &Shape to use a reference.",
    "crumbs": [
      "User Guide",
      "Type Mapping",
      "The extendr Macro"
    ]
  },
  {
    "objectID": "user-guide/type-mapping/extendr-macro.html#externalptr-returning-arbitrary-rust-types",
    "href": "user-guide/type-mapping/extendr-macro.html#externalptr-returning-arbitrary-rust-types",
    "title": "The extendr Macro",
    "section": "ExternalPtr: returning arbitrary Rust types",
    "text": "ExternalPtr: returning arbitrary Rust types\nIn the event that you need to return a Rust type to R that doesn’t have a compatible impl or is a type that you don’t own, you can use ExternalPtr&lt;T&gt;. The ExternalPtr struct allows any item to be captured as a pointer and returned to R.\nHere, for example, an ExternalPtr&lt;Shape&gt; is returned from the shape_ptr() function.\n\n\n\n\n\n\nTip\n\n\n\nAnything that is wrapped in ExternalPtr&lt;T&gt; must implement the Debug trait.\n\n\n\n#[derive(Debug)]\nenum Shape {\n    Triangle,\n    Rectangle,\n    Pentagon,\n    Hexagon,\n}\n\n#[extendr]\nfn shape_ptr(shape: &str) -&gt; ExternalPtr&lt;Shape&gt; {\n    let variant = match shape {\n        \"triangle\" =&gt; Shape::Triangle,\n        \"rectangle\" =&gt; Shape::Rectangle,\n        \"pentagon\" =&gt; Shape::Pentagon,\n        \"hexagon\" =&gt; Shape::Hexagon,\n        &_ =&gt; unimplemented!(),\n    };\n\n    ExternalPtr::new(variant)\n}\n\nUsing an external pointer, however, is far more limiting than the impl block. For example, you cannot access any of its methods.\n\ntri_ptr &lt;- shape_ptr(\"triangle\")\ntri_ptr$n_coords()\n#&gt; Error in tri_ptr$n_coords: object of type 'externalptr' is not subsettable\n\nTo use an ExternalPtr&lt;T&gt;, you have to go through a bit of extra work for it.\n#[extendr]\nfn n_coords_ptr(x: Robj) -&gt; i32 {\n    let shape = TryInto::&lt;ExternalPtr&lt;Shape&gt;&gt;::try_into(x); \n    \n    match shape {\n        Ok(shp) =&gt; shp.n_coords() as i32,\n        Err(_) =&gt; 0\n    }\n}\nThis function definition takes an Robj and from it, tries to create an ExternalPtr&lt;Shape&gt;. Then, if the conversion did not error, it returns the number of coordinates as an i32 (R’s version of an integer) and if there was an error converting, it returns 0.\n\ntri_ptr &lt;- shape_ptr(\"triangle\")\n\nn_coords_ptr(tri_ptr)\n#&gt; [1] 3\n\nn_coords_ptr(list())\n#&gt; [1] 0\n\nFor a good example of using ExternalPtr&lt;T&gt; within an R package, refer to the b64 R package.",
    "crumbs": [
      "User Guide",
      "Type Mapping",
      "The extendr Macro"
    ]
  },
  {
    "objectID": "faq.html",
    "href": "faq.html",
    "title": "Frequently Asked Questions",
    "section": "",
    "text": "What can I use extendr for?\n\n\nHow do I install extendr?\n\n\nWho are the developers of extendr?\nAuthors and maintainers include:\n\nAmy Thomason (author and creator, @andy-thomason)\nMossa M. Reimert (author and maintainer, @CGMossa)\nClaus O. Wilke (author, @clauswilke)\nHiroaki Yutani (author, @yutannihilation)\nIlia Kosenkov (author and maintainer, @Ilia-Kosenkov)\nDaniel Falbel (author, @dfalbel)\nJosiah Parry (maintainer, @JosiahParry)"
  },
  {
    "objectID": "blog/index.html",
    "href": "blog/index.html",
    "title": "extendr Blog",
    "section": "",
    "text": "Migration guide for extendr 0.7.0\n\n\n\n\n\n\nRelease\n\n\nUpdates\n\n\n\nA new version of extendr has arrived, so we explain how to address major changes. \n\n\n\n\n\nJun 30, 2024\n\n\nJosiah Parry\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "changelog.html",
    "href": "changelog.html",
    "title": "Changelog",
    "section": "",
    "text": "Arguments can be (mutable) typed slices such as &[Rbool], &mut [Rint] etc. [#790]\nNew optional faer feature which enables conversion between faer matrix and RMatrix&lt;f64&gt; [#706]\nAdds TryFrom&lt;Robj&gt; and &lt;TryFrom&lt;&Robj&gt; for impl blocks marked with #[extendr] macro allowing falliable conversion to &Self &mut Self [#730]\nAdds From&lt;T&gt; for Robj for impl blocks marked with #[extendr] macro\nThe new ExpectedExternalNonNullPtr error variant provides a more informative error when a null pointer is accessed\nRArray::data_mut provides a mutable slice to the underlying array data [#657]\nImplements the Attributes trait for all R vector wrapper structs (e.g. Integers , Doubles, Strings, etc.), allowing for easy access and setting of the attributes of an R object [#745]. This comes with breaking changes. See below.\nfeature non-api that gives access to non-API items; Requires compile-time generation of bindings [#754]\nTryFrom&lt;&Robj&gt; for StrIter, HashMap&lt;K, Robj&gt; for K = String and K = &str [#759]\n\n\n\n\n\n[Potentially breaking]: RArray::from_parts no longer requires a pointer to the underlying data vector [#657]\n#[extendr(use_try_from = true) is now the default setting, therefore the option use_try_from has been removed [#759]\n\n\n\n\nR-devel Non-API changes:\n\nR’s C API is being formalized. While the changes are formalized, non-API functions are hidden behind a feature flag to prevent removal from CRAN.\nNon-API changes are in flux in R-devel, however, CRAN has set a July 9th date to remove any package that uses non-API functions. This includes almost every extendr based package on CRAN.\nSee [Rd] clarifying and adjusting the C API for R\nnonAPI.txt functions are hidden behind the non-api feature flag.\nRemoved from default include (but may not be limited to):\n\nglobal_var(), local_var(), base_env(), various Environment, Function, Primitive, and Promise methods.\n\n\nAttributes trait now returns a mutable reference to Self. [#745]. Previously .set_attrib() would modify an object in place, and then return an untyped owned pointer (Robj). Instead, now we return &mut Self.\nIn AltRep the unserialize_ex, set_parent, set_envflags are now hidden behind the feature flag non-api. Also, Promise::from_parts is marked as non-API.\nFloating point numbers with decimal part can no longer be converted to integer types via rounding [#757]\nYou can no longer create an Robj from a reference &T, where T is an extendr-impl. [#759]\nYou can no longer use from_robj, as the trait FromRobj as been removed. Instead, use try_from.\nIt is no longer possible to access an R integer vector as a &[u32] [#767]\nIt is no longer possible to generate bindings as part of the compilation of extendr. Feature non-api is broken and will not compile. Related https://github.com/extendr/libR-sys/issues/251\n\n\n\n\n\n\nreturning &Self or &mut Self from a method in an #[extendr]-impl would result in unintended cloning [#614]\nTryFrom&lt;&Robj&gt; and FromRobj for integer scalars now correctly handles conversions from f64 [#757]\n\n\n\n\n\n\n\n\nALTLIST support allowing users to represent structs as R list objects [#600]\n[either] TryFrom&lt;&Robj&gt; for Either&lt;T, R&gt; and From&lt;Either&lt;T, R&gt;&gt; for Robj if T and R are themselves implement these traits. This unblocks scenarios like accepting any numeric vector from R via Either&lt;Integers, Doubles&gt; without extra memory allocation [#480]\nPartialOrd trait implementation for Rfloat, Rint and Rbool. Rfloat and Rint gained min() and max() methods [#573]\nuse_rng option for the extendr attribute macro, which enables the use of random number sampling methods from R, e.g. #[extendr(use_rng = true) [#476]\n[T; N] conversions to Robj [#594]\nToVectorValue for Rfloat, Rint and Rbool [#593]\nTryFrom&lt;_&gt; on Vec&lt;_&gt; for Integers (i32), Complexes (c64), Doubles (f64), and Logicals (bool / i32). [#593]\nRstr can now be constructed from Option&lt;String&gt; [#630]\n\n\n\n\n\nYou can now create ArrayView1 from &Robj as well as Robj [#501]\nRaw literals from Rust can be used for function and argument names. e.g. fn r#type() in Rust is converted to type() in R. [#531]\nFix memory leaks on errors and panics [#555]\nFixed error when collecting too many objects into List, etc. [#540]\n\n\n\n\n\n\n\n\nSupport for setting the default value of arguments to struct methods, using #[default = \"...\"] [#436]\n[ndarray] TryFrom&lt;&Robj&gt; for ArrayView1&lt;T&gt; and ArrayView2&lt;T&gt;, where T is i32, f64, c64, Rint, Rfloat, Rcplx, Rstr, Rbool [#443]\nDebug trait implementation for Rcplx and Complexes [#444]\nTryFrom&lt;Robj&gt;, From&lt;Option&lt;T&gt;&gt;, Into&lt;Option&lt;T&gt;&gt; and their variations for Nullable&lt;T&gt; [#446]\nNullable&lt;T&gt;::map() that acts on not null value and propagates NULL [#446]\n[ndarray] Conversion from owned arrays (ie ndarray::Array) into Robj [#450]\n[ndarray][docs] Documentation for the robj_ndarray module [#450]\nSum for scalars like Rint, Rfloat and Rcplx, which accept Iterator&lt;Item = &Rtype&gt; [#454]\nA new collect_rarray method that can be used to collect arbitrary iterables into an R matrix [#466]\n[docs] Documentation for RArray::new_matrix() [#466]\n\n\n\n\n\n[docs] Use bindgen on docs.rs, to ensure newer R features will still be documented [#426]\nUnify the tagging mechanism used to identify Rust types inside ExternalPtr. This allows #[extendr]-annotated functions to directly accept ExternalPtr&lt;MyStruct&gt; as well as MyStruct [#433]\nNullable&lt;T&gt; is now part of extendr_api::prelude [#446]\nBump the Rust edition from 2018 to 2021 [#458]\nWhen converted to STRSXP, strings are now correctly marked as UTF-8 even on non-UTF-8 platforms (i.e., R &lt; 4.2 on Windows), which shouldn’t matter for most of the users [#467]\n\n\n\n\n\nThe R CMD check note “Found non-API calls to R” by moving use extendr_engine; inside test! macro [#424]\nThe clippy lint “this public function might dereference a raw pointer but is not marked unsafe” [#451]\nA bug where importing a submodule via use some_module; inside the extendr_module! macro wasn’t working [#469]\n\n\n\n\n\n\n\n\nFunction type that wraps an R function, which can be invoked using the call() method. [#188]\npairlist! macro for generating Pairlist objects, e.g. for use in function calls. [#202]\nuse_try_from option for the extendr macro, which allows the use of any type that implements TryInto&lt;Robj&gt;/TryFrom&lt;Robj&gt;, e.g. #[extendr(use_try_from = true)]. [#222]\nSupport for R version 4.2. [#235]\ncall! macro, which can be used to call an R function whose name is provided as a string. [#238]\nLarge Rust integer types (u32, u64 and i64) can now be converted to R’s numeric type, which can handle large integer values. [#242]\nTryFrom&lt;Robj&gt; for a large number of Rust types. [#249], [#258]\nSupport for ALTREP. [#250], [#274]\nS4 struct, which wraps an S4 class in R. [#268]\n[ndarray] Implemented TryFrom&lt;&ArrayBase&gt; for Robj, allowing extendr-annotated functions to return Arrays from the ndarray crate and have them automatically converted to R arrays. [#275]\nRint, Rdouble, Rbool and Rcplx: NA-aware wrappers for scalar elements of R vectors [#274], [#284], [#301], [#338], [#350]\nIntegers, Doubles, Strings, Logicals and Complexes: wrappers for R vectors that deref to slices of the above types (RInt etc). [#274], [#284], [#301], [#338], [#350]\nExternalPtr, a wrapper class for creating R objects containing any Rust object. [#260]\n[graphics] Support for R graphics and graphics devices. The graphics feature flag is disabled by default. [#279], [#360], [#373], [#379], [#380], [#389]\nDeref implementation for vector types (Rint/Rfloat/Rbool/Rstr/Robj) to appropriately typed Rust slices. [#327]\ndefault option for extendr-annotated functions, allowing them to have default values, e.g. fn fred(#[default=\"NULL\"] x: Option&lt;i32&gt;) { }. [#334]\nr_name option for extendr-annotated functions, allowing the generated R function to have a different name. e.g.\n#[extendr(\n    use_try_from = true,\n    r_name = \"test.rename.rlike\",\n    mod_name = \"test_rename_mymod\"\n)]\nfn test_rename() { }\n[#335]\nserde::Serialize implementation for R types. [#305], [#355]\nRany type and the as_any conversion method. [#320]\nstd::fmt::Debug implementation for wrapper types. [#345]\n#[derive(TryFromRobj) and #[derive(IntoRobj)] which provide an automatic conversion from and to any custom Rust struct and Robj [#347]\n[[ operator that works with Rust classes. Its behavior is identical to that of the $ operator. [#359]\nLoad and Save, traits that, once implemented, provide the ability to load and save R data in the RDS format. These traits are implemented for all Robj. [#363]\nDataframe wrapper struct. [#393]\nIntoDataFrame trait, which can be derived to allow arbitrary Rust structs to be converted to rows of a data frame. [#393]\n\n\n\n\n\nStrings::elt now returns an Rstr. [#345]\nRenamed RType to Rtype. [#345]\nWrapper types now contain Robj fields. [#190]\nThe R! macro now accepts strings that contain R code. This is now the recommended way of using the macro, especially with raw strings e.g.\nR!(r#\"\n    print(\"hello\")\n\"#);\n[#203]\nImproved error handling for &lt;&str&gt;::try_from(Robj). [#226]\nSymPair::sym_pair() now returns (Option&lt;Robj&gt;, Robj). [#225]\nMore detailed error messages when converting Rust integer types to R. [#243]\nCharacter is now called Rstr. [#273]\n[ndarray] Bumped ndarray to 0.15.3. Under RFC 1977 this is a “public dependency” change, and therefore can be considered a breaking change, as consumers of extendr that use an older version of ndarray will no longer be compatible until they also bump ndarray to a compatible version. [#275]\nIsNA trait has been renamed to CanBeNA. [#288]\nlist! has been rewritten, and now returns a List struct. [#303]\n\n\n\n\n\nCalling the R! macro with non-string types (e.g. R!(1)) is now deprecated. [#203]\n\n\n\n\n\nReal, Int, Bool and the redundant trait SliceIter, which should be replaced with Rdouble, Rint, and Rbool respectively. [#304], [#338]\nTryFrom conversions between Robj and HashMap for consistency. List::into_hashmap() and List::from_hashmap() should be used instead. [#254]\n\n\n\n\n\n\nAdded contributing guidelines and code of conduct.\nMade use of ndarray optional.\nMade #[extendr] calls panic and thread safe.\nAdded NA handling to the #[extendr] macro.\nAdded a separate extendr-engine crate that is needed when calling R from Rust.\nWrapper classes for pairlists, environment, raw, symbols and others.\nMore iterator support.\nOperators index, slice, dollar, double_colon, +, -, * and /`.\nDebug printing support expanded to use wrappers.\nConversion of Robj to wrapper types.\nMultithreaded support - allows multithreaded testing using a recursive spinlock.\nBool type extended and implemented using TRUE, FALSE and NA_BOOLEAN.\nOptional parameters to support NA handing.\nErrors thrown if input parameters without Option are NA.\nHarmonising of function names into integer, real, logical, symbol, raw, list, pairlist and env.\nRefactored robj code into several source files.\nMany functions updated to use generic types.\nR! macro for executing R source code.\ncall! macro to call R code.\nsym! macro to generate symbols.\nSimplification of vector generation using collect_robj and ToVectorValue.\nAdded array types [1, 2, 3] as Robj::from targets.\nMacros now mostly return errors.\n\n\n\n\n\nFix build on Windows and MacOS."
  },
  {
    "objectID": "changelog.html#section",
    "href": "changelog.html#section",
    "title": "Changelog",
    "section": "",
    "text": "Arguments can be (mutable) typed slices such as &[Rbool], &mut [Rint] etc. [#790]\nNew optional faer feature which enables conversion between faer matrix and RMatrix&lt;f64&gt; [#706]\nAdds TryFrom&lt;Robj&gt; and &lt;TryFrom&lt;&Robj&gt; for impl blocks marked with #[extendr] macro allowing falliable conversion to &Self &mut Self [#730]\nAdds From&lt;T&gt; for Robj for impl blocks marked with #[extendr] macro\nThe new ExpectedExternalNonNullPtr error variant provides a more informative error when a null pointer is accessed\nRArray::data_mut provides a mutable slice to the underlying array data [#657]\nImplements the Attributes trait for all R vector wrapper structs (e.g. Integers , Doubles, Strings, etc.), allowing for easy access and setting of the attributes of an R object [#745]. This comes with breaking changes. See below.\nfeature non-api that gives access to non-API items; Requires compile-time generation of bindings [#754]\nTryFrom&lt;&Robj&gt; for StrIter, HashMap&lt;K, Robj&gt; for K = String and K = &str [#759]\n\n\n\n\n\n[Potentially breaking]: RArray::from_parts no longer requires a pointer to the underlying data vector [#657]\n#[extendr(use_try_from = true) is now the default setting, therefore the option use_try_from has been removed [#759]\n\n\n\n\nR-devel Non-API changes:\n\nR’s C API is being formalized. While the changes are formalized, non-API functions are hidden behind a feature flag to prevent removal from CRAN.\nNon-API changes are in flux in R-devel, however, CRAN has set a July 9th date to remove any package that uses non-API functions. This includes almost every extendr based package on CRAN.\nSee [Rd] clarifying and adjusting the C API for R\nnonAPI.txt functions are hidden behind the non-api feature flag.\nRemoved from default include (but may not be limited to):\n\nglobal_var(), local_var(), base_env(), various Environment, Function, Primitive, and Promise methods.\n\n\nAttributes trait now returns a mutable reference to Self. [#745]. Previously .set_attrib() would modify an object in place, and then return an untyped owned pointer (Robj). Instead, now we return &mut Self.\nIn AltRep the unserialize_ex, set_parent, set_envflags are now hidden behind the feature flag non-api. Also, Promise::from_parts is marked as non-API.\nFloating point numbers with decimal part can no longer be converted to integer types via rounding [#757]\nYou can no longer create an Robj from a reference &T, where T is an extendr-impl. [#759]\nYou can no longer use from_robj, as the trait FromRobj as been removed. Instead, use try_from.\nIt is no longer possible to access an R integer vector as a &[u32] [#767]\nIt is no longer possible to generate bindings as part of the compilation of extendr. Feature non-api is broken and will not compile. Related https://github.com/extendr/libR-sys/issues/251\n\n\n\n\n\n\nreturning &Self or &mut Self from a method in an #[extendr]-impl would result in unintended cloning [#614]\nTryFrom&lt;&Robj&gt; and FromRobj for integer scalars now correctly handles conversions from f64 [#757]"
  },
  {
    "objectID": "changelog.html#section-1",
    "href": "changelog.html#section-1",
    "title": "Changelog",
    "section": "",
    "text": "ALTLIST support allowing users to represent structs as R list objects [#600]\n[either] TryFrom&lt;&Robj&gt; for Either&lt;T, R&gt; and From&lt;Either&lt;T, R&gt;&gt; for Robj if T and R are themselves implement these traits. This unblocks scenarios like accepting any numeric vector from R via Either&lt;Integers, Doubles&gt; without extra memory allocation [#480]\nPartialOrd trait implementation for Rfloat, Rint and Rbool. Rfloat and Rint gained min() and max() methods [#573]\nuse_rng option for the extendr attribute macro, which enables the use of random number sampling methods from R, e.g. #[extendr(use_rng = true) [#476]\n[T; N] conversions to Robj [#594]\nToVectorValue for Rfloat, Rint and Rbool [#593]\nTryFrom&lt;_&gt; on Vec&lt;_&gt; for Integers (i32), Complexes (c64), Doubles (f64), and Logicals (bool / i32). [#593]\nRstr can now be constructed from Option&lt;String&gt; [#630]\n\n\n\n\n\nYou can now create ArrayView1 from &Robj as well as Robj [#501]\nRaw literals from Rust can be used for function and argument names. e.g. fn r#type() in Rust is converted to type() in R. [#531]\nFix memory leaks on errors and panics [#555]\nFixed error when collecting too many objects into List, etc. [#540]"
  },
  {
    "objectID": "changelog.html#section-2",
    "href": "changelog.html#section-2",
    "title": "Changelog",
    "section": "",
    "text": "Support for setting the default value of arguments to struct methods, using #[default = \"...\"] [#436]\n[ndarray] TryFrom&lt;&Robj&gt; for ArrayView1&lt;T&gt; and ArrayView2&lt;T&gt;, where T is i32, f64, c64, Rint, Rfloat, Rcplx, Rstr, Rbool [#443]\nDebug trait implementation for Rcplx and Complexes [#444]\nTryFrom&lt;Robj&gt;, From&lt;Option&lt;T&gt;&gt;, Into&lt;Option&lt;T&gt;&gt; and their variations for Nullable&lt;T&gt; [#446]\nNullable&lt;T&gt;::map() that acts on not null value and propagates NULL [#446]\n[ndarray] Conversion from owned arrays (ie ndarray::Array) into Robj [#450]\n[ndarray][docs] Documentation for the robj_ndarray module [#450]\nSum for scalars like Rint, Rfloat and Rcplx, which accept Iterator&lt;Item = &Rtype&gt; [#454]\nA new collect_rarray method that can be used to collect arbitrary iterables into an R matrix [#466]\n[docs] Documentation for RArray::new_matrix() [#466]\n\n\n\n\n\n[docs] Use bindgen on docs.rs, to ensure newer R features will still be documented [#426]\nUnify the tagging mechanism used to identify Rust types inside ExternalPtr. This allows #[extendr]-annotated functions to directly accept ExternalPtr&lt;MyStruct&gt; as well as MyStruct [#433]\nNullable&lt;T&gt; is now part of extendr_api::prelude [#446]\nBump the Rust edition from 2018 to 2021 [#458]\nWhen converted to STRSXP, strings are now correctly marked as UTF-8 even on non-UTF-8 platforms (i.e., R &lt; 4.2 on Windows), which shouldn’t matter for most of the users [#467]\n\n\n\n\n\nThe R CMD check note “Found non-API calls to R” by moving use extendr_engine; inside test! macro [#424]\nThe clippy lint “this public function might dereference a raw pointer but is not marked unsafe” [#451]\nA bug where importing a submodule via use some_module; inside the extendr_module! macro wasn’t working [#469]"
  },
  {
    "objectID": "changelog.html#section-3",
    "href": "changelog.html#section-3",
    "title": "Changelog",
    "section": "",
    "text": "Function type that wraps an R function, which can be invoked using the call() method. [#188]\npairlist! macro for generating Pairlist objects, e.g. for use in function calls. [#202]\nuse_try_from option for the extendr macro, which allows the use of any type that implements TryInto&lt;Robj&gt;/TryFrom&lt;Robj&gt;, e.g. #[extendr(use_try_from = true)]. [#222]\nSupport for R version 4.2. [#235]\ncall! macro, which can be used to call an R function whose name is provided as a string. [#238]\nLarge Rust integer types (u32, u64 and i64) can now be converted to R’s numeric type, which can handle large integer values. [#242]\nTryFrom&lt;Robj&gt; for a large number of Rust types. [#249], [#258]\nSupport for ALTREP. [#250], [#274]\nS4 struct, which wraps an S4 class in R. [#268]\n[ndarray] Implemented TryFrom&lt;&ArrayBase&gt; for Robj, allowing extendr-annotated functions to return Arrays from the ndarray crate and have them automatically converted to R arrays. [#275]\nRint, Rdouble, Rbool and Rcplx: NA-aware wrappers for scalar elements of R vectors [#274], [#284], [#301], [#338], [#350]\nIntegers, Doubles, Strings, Logicals and Complexes: wrappers for R vectors that deref to slices of the above types (RInt etc). [#274], [#284], [#301], [#338], [#350]\nExternalPtr, a wrapper class for creating R objects containing any Rust object. [#260]\n[graphics] Support for R graphics and graphics devices. The graphics feature flag is disabled by default. [#279], [#360], [#373], [#379], [#380], [#389]\nDeref implementation for vector types (Rint/Rfloat/Rbool/Rstr/Robj) to appropriately typed Rust slices. [#327]\ndefault option for extendr-annotated functions, allowing them to have default values, e.g. fn fred(#[default=\"NULL\"] x: Option&lt;i32&gt;) { }. [#334]\nr_name option for extendr-annotated functions, allowing the generated R function to have a different name. e.g.\n#[extendr(\n    use_try_from = true,\n    r_name = \"test.rename.rlike\",\n    mod_name = \"test_rename_mymod\"\n)]\nfn test_rename() { }\n[#335]\nserde::Serialize implementation for R types. [#305], [#355]\nRany type and the as_any conversion method. [#320]\nstd::fmt::Debug implementation for wrapper types. [#345]\n#[derive(TryFromRobj) and #[derive(IntoRobj)] which provide an automatic conversion from and to any custom Rust struct and Robj [#347]\n[[ operator that works with Rust classes. Its behavior is identical to that of the $ operator. [#359]\nLoad and Save, traits that, once implemented, provide the ability to load and save R data in the RDS format. These traits are implemented for all Robj. [#363]\nDataframe wrapper struct. [#393]\nIntoDataFrame trait, which can be derived to allow arbitrary Rust structs to be converted to rows of a data frame. [#393]\n\n\n\n\n\nStrings::elt now returns an Rstr. [#345]\nRenamed RType to Rtype. [#345]\nWrapper types now contain Robj fields. [#190]\nThe R! macro now accepts strings that contain R code. This is now the recommended way of using the macro, especially with raw strings e.g.\nR!(r#\"\n    print(\"hello\")\n\"#);\n[#203]\nImproved error handling for &lt;&str&gt;::try_from(Robj). [#226]\nSymPair::sym_pair() now returns (Option&lt;Robj&gt;, Robj). [#225]\nMore detailed error messages when converting Rust integer types to R. [#243]\nCharacter is now called Rstr. [#273]\n[ndarray] Bumped ndarray to 0.15.3. Under RFC 1977 this is a “public dependency” change, and therefore can be considered a breaking change, as consumers of extendr that use an older version of ndarray will no longer be compatible until they also bump ndarray to a compatible version. [#275]\nIsNA trait has been renamed to CanBeNA. [#288]\nlist! has been rewritten, and now returns a List struct. [#303]\n\n\n\n\n\nCalling the R! macro with non-string types (e.g. R!(1)) is now deprecated. [#203]\n\n\n\n\n\nReal, Int, Bool and the redundant trait SliceIter, which should be replaced with Rdouble, Rint, and Rbool respectively. [#304], [#338]\nTryFrom conversions between Robj and HashMap for consistency. List::into_hashmap() and List::from_hashmap() should be used instead. [#254]"
  },
  {
    "objectID": "changelog.html#extendr-0.2.0",
    "href": "changelog.html#extendr-0.2.0",
    "title": "Changelog",
    "section": "",
    "text": "Added contributing guidelines and code of conduct.\nMade use of ndarray optional.\nMade #[extendr] calls panic and thread safe.\nAdded NA handling to the #[extendr] macro.\nAdded a separate extendr-engine crate that is needed when calling R from Rust.\nWrapper classes for pairlists, environment, raw, symbols and others.\nMore iterator support.\nOperators index, slice, dollar, double_colon, +, -, * and /`.\nDebug printing support expanded to use wrappers.\nConversion of Robj to wrapper types.\nMultithreaded support - allows multithreaded testing using a recursive spinlock.\nBool type extended and implemented using TRUE, FALSE and NA_BOOLEAN.\nOptional parameters to support NA handing.\nErrors thrown if input parameters without Option are NA.\nHarmonising of function names into integer, real, logical, symbol, raw, list, pairlist and env.\nRefactored robj code into several source files.\nMany functions updated to use generic types.\nR! macro for executing R source code.\ncall! macro to call R code.\nsym! macro to generate symbols.\nSimplification of vector generation using collect_robj and ToVectorValue.\nAdded array types [1, 2, 3] as Robj::from targets.\nMacros now mostly return errors."
  },
  {
    "objectID": "changelog.html#extendr-0.1.10",
    "href": "changelog.html#extendr-0.1.10",
    "title": "Changelog",
    "section": "",
    "text": "Fix build on Windows and MacOS."
  }
]