{
  "hash": "23f3a3ed07d9f7905ecd8f3f82ce483a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Async with Tokio\ndate: \"2025-08-24\"\n---\n\n\n\n\n\n\n\n\nMany crates in the Rust ecosystem utilize an **asynchronous** runtime through the [tokio](https://crates.io/crates/tokio) crate. Tokio provides a **multithreaded** runtime and is used by popular libraries like [reqwest](https://crates.io/crates/reqwest), [axum](https://crates.io/crates/axum), [DataFusion](https://crates.io/crates/datafusion), [sqlx](https://crates.io/crates/sqlx), and many more. \n\nextendr doesn't provide an async function interface because there is not a true async runtime for R let alone any C API infrastructure for it. But that does not mean we cannot harness the vast async ecosystem in Rust. \n\n## Add tokio\n\n\nTo utilize tokio with extendr we will need to bump the msrv of our package to `1.70` as that is the MSRV of `tokio` and we will be using a langauge feature called [`OnceLock`](https://doc.rust-lang.org/std/sync/struct.OnceLock.html) that wasn't stabilized until 1.70.\n\n\n```r\nrextendr::use_msrv(\"1.70\")\nrextendr::use_crate(\"tokio\", features = \"rt-multi-thread\")\n```\n\nThe `use_msrv()` function will bump the MSRV specified in your package's `DESCRIPTION` file. The `use_crate()` function will call `cargo add` on your behalf and add the crate to your `Cargo.toml`. \n\n## Creating your runtime\n\nYour R package should share one runtime across all function calls. This approach:\n\n- Creates a global static variable using `OnceLock<>` (thread-safe, write-once)\n- Uses lazy initialization—runtime is created only when first needed\n- Returns a reference to the same runtime on subsequent calls\n\n::: callout-note\n## Futures\n\nSee [Futures and the Async Syntax](https://doc.rust-lang.org/book/ch17-01-futures-and-syntax.html) section of The Book™.\n\n:::\n\nIn your `lib.rs` we define a static called `TOKIO_RUNTIME` which contains a `Runtime`. \n\nThe function `get_rt()` will create a new `Runtime` the first time it is called. Each subsequent call returns a reference to that created runtime. \n\n```rust\nuse extendr_api::prelude::*;\nuse std::sync::OnceLock;\nuse tokio::runtime::{Builder, Runtime};\n\n// Initialize a shared tokio runtime for the package\nstatic TOKIO_RUNTIME: OnceLock<Runtime> = OnceLock::new();\n\n// Helper function to get a tokio runtime\nfn get_rt() -> &'static Runtime {\n    TOKIO_RUNTIME.get_or_init(|| {\n        Builder::new_multi_thread()\n            .enable_all()\n            .build()\n            .expect(\"Failed to create tokio runtime\")\n    })\n}\n```\n\nNow, in any function we want to use the tokio run time can first call `get_rt()` to get a reference to it.\n\n## Blocking on `async` futures\n\nFor a motivating example we can use the async file reader from tokio using our new runtime. \n\n\n```rust\n#[extendr]\nfn read_file_async(path: &str) -> String {\n    // get the tokio runtime\n    let rt = get_rt();\n\n    // define a future, typically we would `.await`\n    let file_content_fut = tokio::fs::read_to_string(path);\n\n    // use `.block_on()` to await the future\n    rt.block_on(file_content_fut).expect(\"failed to read file\")\n}\n```\n\nThe first step is to get the tokio runtime. Then we call the async function, which typically we would `.await` to get the result. Instead, we call `.block_on()` to execute the future and get the result.\n\n## Example: read many files async\n\nFor a more complete / complex example we can create a function that reads multiple files in parallel and awaits all of the futures asynchronously.\n\n\n```rust\n#[extendr]\nfn read_files_async(paths: Vec<String>) -> Strings {\n    // get the tokio runtime\n    let rt = get_rt();\n\n    // create a joinset to await multiple futures asynchronously\n    let mut set = tokio::task::JoinSet::new();\n\n    // spawn each future in the join set\n    for p in paths {\n        set.spawn(tokio::fs::read_to_string(p));\n    }\n\n    // wait for all futures to resolve\n    let all_file_bodies = rt.block_on(set.join_all());\n\n    // filter out any files that failed to read\n    // return the contents as a character vector\n    all_file_bodies\n        .into_iter()\n        .filter_map(|contents| contents.ok().map(Rstr::from))\n        .collect::<Strings>()\n}\n```\n\n## What this unlocks\n\nWith tokio working in extendr, we now have access to the entire async Rust ecosystem. This means we can build R packages using:\n\n- [DataFusion](https://github.com/apache/datafusion) - high-performance SQL query engine\n- [DataFusion Comet](https://github.com/apache/datafusion-comet) - Spark accelerator \n- [lancedb](https://github.com/lancedb/lancedb) - vector database for AI applications\n- [qdrant](https://github.com/qdrant/qdrant) - vector search engine for next-gen AI\n- [burn](https://github.com/tracel-ai/burn) - deep learning framework \n- [sail](https://github.com/lakehq/sail) - unified batch and stream processing\n\nThe async ecosystem is massive and growing. Now R can be part of it.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}