{
  "hash": "fb51c04fe5f76d43a75eff43d14430b4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Rust Structs to Lists\"\n---\n\n\n::: {.cell}\n\n:::\n\n\nWhen returning structured data from Rust to R, named lists are often the most natural representation. The `IntoList` derive macro converts Rust structs into R lists where each field becomes a named element.\n\n## Basic Usage\n\nDerive `IntoList` on a struct to convert it into a named R list. Each field is converted to an `Robj` and assembled into a named list. This approach has some overhead but provides a straightforward way to return structured results. Note that this creates a one-way conversion—there is no built-in method to convert the list back into the Rust struct. For stateful objects that need methods, use `#[extendr]` on an `impl` block with external pointers instead. See [IntoList vs External Pointers](#intolist-vs-external-pointers) below for additional details.\n\n\n::: {.cell}\n\n```{.rust .cell-code}\n#[derive(IntoList)]\nstruct Person {\n    name: String,\n    age: i32,\n}\n\n#[extendr]\nfn create_person() -> Person {\n    Person {\n        name: String::from(\"Alice\"),\n        age: 30,\n    }\n}\n```\n:::\n\n\nThe field names become element names in the resulting list:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreate_person()\n#> $name\n#> [1] \"Alice\"\n#> \n#> $age\n#> [1] 30\n```\n:::\n\n\n\n::: {.cell}\n\n```{.rust .cell-code}\n#[derive(IntoList)]\nstruct Analysis {\n    id: i32,\n    values: Vec<f64>,\n    passed: bool,\n}\n\n#[extendr]\nfn run_analysis() -> Analysis {\n    Analysis {\n        id: 123,\n        values: vec![1.5, 2.7, 3.9],\n        passed: true,\n    }\n}\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_analysis()\n#> $id\n#> [1] 123\n#> \n#> $values\n#> [1] 1.5 2.7 3.9\n#> \n#> $passed\n#> [1] TRUE\n```\n:::\n\n\nAny type that can be converted into an `Robj` can be used as a field. If a field type cannot be converted, exclude it using `#[into_list(ignore)]` or reconsider the approach.\n\n## Ignoring Fields\n\nNot all types in Rust can be converted to R. Skip serializing these fields by using `#[into_list(ignore)]`:\n\n\n::: {.cell}\n\n```{.rust .cell-code}\n#[derive(IntoList)]\nstruct Config {\n    setting: String,\n    value: i32,\n    #[into_list(ignore)]\n    internal_cache: Vec<u8>,\n}\n\n#[extendr]\nfn get_config() -> Config {\n    Config {\n        setting: String::from(\"timeout\"),\n        value: 30,\n        internal_cache: vec![1, 2, 3],\n    }\n}\n```\n:::\n\n\nNote that the ignored field does not appear in the resultant list:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconfig <- get_config()\nconfig\n#> $setting\n#> [1] \"timeout\"\n#> \n#> $value\n#> [1] 30\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconfig$internal_cache\n#> NULL\n```\n:::\n\n\n## IntoList vs External Pointers\n\n`IntoList` takes Rust structs and serializes them as an R list. The result is just that—an R list. The list does not store any reference to the Rust struct. That is lost.\n\nThe `#[extendr]` macro creates a reference to the Rust struct itself. This can then be used to pass the Rust struct from function to function.\n\n\n::: {.cell}\n\n```{.rust .cell-code}\n#[extendr]\nstruct StatefulCounter {\n    count: i32,\n}\n\n#[extendr]\nimpl StatefulCounter {\n    fn new() -> Self {\n        StatefulCounter { count: 0 }\n    }\n\n    fn increment(&mut self) {\n        self.count += 1;\n    }\n\n    fn get(&self) -> i32 {\n        self.count\n    }\n}\n```\n:::\n\n\n`StatefulCounter` keeps state in Rust and exposes methods:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounter <- StatefulCounter$new()\ncounter$increment()\ncounter$increment()\ncounter$get()\n#> [1] 2\n```\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}